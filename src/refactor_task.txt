
We need to refactor a large C++ "God Object" or Blob class called `Service` that contains hundreds of virtual public member functions. 
The `Service` class happens to have a private member variable, `Data` which also defines a large number of get/set methods. 
Unfortunately, at some point in the past, a developer thought it would be a good idea to add "convenience" methods to the 
`Service` public interface to directly access the encapusated `Data` methods as is illustrated below:

```
class Data {
public:
  // other methods
  int get_value() const { return value_; }
  void set_value( int value ) { value_ = value; }

private:
  int value_;
};


class Service {
public:
  // other methods 
  const Data& get_data() const { return data_; }
  Data& get_data() { return data_; }
  // "Convenience" methods to be removed
  int get_value() const { return get_data().get_value(); }
  void set_value( int value ) { get_data().set_value(value); }
private:
  Data data_;
};
```

Now what we would like to do is, to the extent possible, find instances of `Service` objects using these convenience methods in
our code base

```
Service service;
std::cout << service.get_value() << "\n";
```

and replace them with the expanded form 

```
Service service;
std::cout << service.get_data().get_value() << "\n";
```

so that we may remove the method `Service::get_data`. We already have a small refactoring code that uses clang's LibTooling 
library that we could extend for this purpose, or since the code base seems to very consistently use the same names for
`Service` objects, we could consider a `sed` based approach. What would you suggest?


