<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE DAKOTA_XML  [
    <!-- BMA: For all tabular formats, custom_annotated must be first
         or parser doesn't recognize header, eval_id, interface_id -->

    <!-- Reusable definition for a method's approximation data import format -->
    <!ENTITY method_import_build_format '
	     <optional>
               <oneOf label="Tabular Format" >
		 <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,importBuildFormat_TABULAR_NONE)}" label="custom_annotated"  default="annotated format" >
		   <keyword  id="header" name="header" code="{N_mdm(augment_utype,importBuildFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" default="no header" />
		   <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,importBuildFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" default="no eval_id column" />
		   <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,importBuildFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" default="no interface_id column" />
		 </keyword>
		 <keyword  id="annotated" name="annotated" code="{N_mdm(utype,importBuildFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated format" />
		 <keyword  id="freeform" name="freeform" code="{N_mdm(utype,importBuildFormat_TABULAR_NONE)}" label="freeform"  default="annotated format" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY method_import_approx_format '
             <optional>
               <oneOf label="Tabular Format" >
		 <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,importApproxFormat_TABULAR_NONE)}" label="custom_annotated"  default="annotated format" >
		   <keyword  id="header" name="header" code="{N_mdm(augment_utype,importApproxFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" default="no header" />
		   <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,importApproxFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" default="no eval_id column" />
		   <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,importApproxFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" default="no interface_id column" />
		 </keyword>
		 <keyword  id="annotated" name="annotated" code="{N_mdm(utype,importApproxFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated format" />
		 <keyword  id="freeform" name="freeform" code="{N_mdm(utype,importApproxFormat_TABULAR_NONE)}" label="freeform"  default="annotated format" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY method_export_approx_format '
	     <optional>
               <oneOf label="Tabular Format" >
		 <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,exportApproxFormat_TABULAR_NONE)}" label="custom_annotated"  default="annotated format" >
		   <keyword  id="header" name="header" code="{N_mdm(augment_utype,exportApproxFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" default="no header" />
		   <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,exportApproxFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" default="no eval_id column" />
		   <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,exportApproxFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" default="no interface_id column" />
		 </keyword>
		 <keyword  id="annotated" name="annotated" code="{N_mdm(utype,exportApproxFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated format" />
		 <keyword  id="freeform" name="freeform" code="{N_mdm(utype,exportApproxFormat_TABULAR_NONE)}" label="freeform"  default="annotated format" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY method_export_samples_format '
	     <optional>
	       <oneOf label="Tabular Format" >
		 <keyword  name="custom_annotated" code="{N_mdm(utype,exportSamplesFormat_TABULAR_NONE)}" label="custom_annotated"  >
		   <keyword  name="header" code="{N_mdm(augment_utype,exportSamplesFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		   <keyword  name="eval_id" code="{N_mdm(augment_utype,exportSamplesFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		   <keyword  name="interface_id" code="{N_mdm(augment_utype,exportSamplesFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		 </keyword>
		 <keyword  name="annotated" code="{N_mdm(utype,exportSamplesFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated" />
		 <keyword  name="freeform" code="{N_mdm(utype,exportSamplesFormat_TABULAR_NONE)}" label="freeform"  default="annotated" />
	       </oneOf>
	     </optional>
	     ' >

    <!-- Legacy scalar data format supports exp_id and header options -->
    <!ENTITY response_scalar_data_format '
	     <optional>
               <oneOf label="Tabular Format" >
        	 <keyword  id="custom_annotated" name="custom_annotated" code="{N_rem(utype,scalarDataFormat_TABULAR_NONE)}" label="custom_annotated"  default="annotated format" >
        	   <keyword  id="header" name="header" code="{N_rem(augment_utype,scalarDataFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" default="no header" />
        	   <keyword  id="exp_id" name="exp_id" code="{N_rem(augment_utype,scalarDataFormat_TABULAR_EVAL_ID)}" label="exp_id"  minOccurs="0" default="no exp_id column" />
        	 </keyword>
		 <keyword  id="annotated" name="annotated" code="{N_rem(utype,scalarDataFormat_TABULAR_EXPER_ANNOT)}" label="annotated"  default="annotated format" />
		 <keyword  id="freeform" name="freeform" code="{N_rem(utype,scalarDataFormat_TABULAR_NONE)}" label="freeform"  default="annotated format" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY model_full_surfpack_export_format '
	     <keyword  id="export_model" name="export_model" minOccurs="0" maxOccurs="1" code="{N_mom(true,exportSurrogate)}" label="Export Surrogate Model"  complexity="1">
               <keyword  id="filename_prefix" name="filename_prefix" minOccurs="0" code="{N_mom(str,modelExportPrefix)}" label="Exported Surrogate Filename Prefix"  default="exported_surrogate" complexity="1">
		 <param type="STRING" />
               </keyword>
               <keyword id="formats" name="formats" code="{0}" label="Formats" maxOccurs="1" group="Surrogate Export Formats" complexity="1">
		 <keyword id="text_archive" name="text_archive" code="{N_mom(augment_utype,modelExportFormat_TEXT_ARCHIVE)}" label="Text Archive" maxOccurs="1" minOccurs="0" />
		 <keyword id="binary_archive" name="binary_archive" code="{N_mom(augment_utype,modelExportFormat_BINARY_ARCHIVE)}" label="Binary Archive" maxOccurs="1" minOccurs="0"  />
		 <keyword id="algebraic_file" name="algebraic_file" code="{N_mom(augment_utype,modelExportFormat_ALGEBRAIC_FILE)}" label="Algebraic File" maxOccurs="1" minOccurs="0"  />
		 <keyword id="algebraic_console" name="algebraic_console" code="{N_mom(augment_utype,modelExportFormat_ALGEBRAIC_CONSOLE)}" label="Algebraic Console" maxOccurs="1" minOccurs="0"  />
               </keyword>
	     </keyword>
	     ' >

    <!-- Used for both surfpack and new surrogate models -->
    <!ENTITY model_surrogate_import '
	     <keyword  id="import_model" name="import_model" minOccurs="0" maxOccurs="1" code="{N_mom(true,importSurrogate)}" label="Import Surrogate Model"  complexity="1">
               <keyword  id="filename_prefix" name="filename_prefix" minOccurs="0" code="{N_mom(str,modelImportPrefix)}" label="Imported Surrogate Filename Prefix"  default="exported_surrogate" complexity="1" >
		 <param type="STRING" />
               </keyword>
               <oneOf label="Surrogate Import Format">
		 <keyword id="text_archive" name="text_archive" code="{N_mom(augment_utype,modelImportFormat_TEXT_ARCHIVE)}" label="Text Input" maxOccurs="1" />
		 <keyword id="binary_archive" name="binary_archive" code="{N_mom(augment_utype,modelImportFormat_BINARY_ARCHIVE)}" label="Binary Input" maxOccurs="1" />
               </oneOf>
	     </keyword>
	     ' >

    <!-- Used for both surfpack and new surrogate models -->
    <!ENTITY model_partial_surrogate_export_format '
	     <keyword  id="export_model" name="export_model" minOccurs="0" maxOccurs="1" code="{N_mom(true,exportSurrogate)}" label="Export Surrogate Model"  complexity="1">
               <keyword  id="filename_prefix" name="filename_prefix" minOccurs="0" code="{N_mom(str,modelExportPrefix)}" label="Exported Surrogate Filename Prefix"  default="exported_surrogate" complexity="1">
		 <param type="STRING" />
               </keyword>
               <keyword id="formats" name="formats" code="{0}" label="Formats" maxOccurs="1" group="Surrogate Export Formats" complexity="1">
		 <keyword id="text_archive" name="text_archive" code="{N_mom(augment_utype,modelExportFormat_TEXT_ARCHIVE)}" label="Text Output" maxOccurs="1" minOccurs="0" />
		 <keyword id="binary_archive" name="binary_archive" code="{N_mom(augment_utype,modelExportFormat_BINARY_ARCHIVE)}" label="Binary Output" maxOccurs="1" minOccurs="0"  />
               </keyword>
	     </keyword>
	     ' >

    <!ENTITY model_variance_export '
          <keyword  id="export_approx_variance_file" name="export_approx_variance_file" code="{N_mom(str,exportApproxVarianceFile)}" label="File Export of Global Approximation Variance"  minOccurs="0" default="no variance export to a file" >
	    <param type="OUTPUT_FILE" />
	    <optional>
	      <oneOf label="Tabular Format" >
		<keyword  id="custom_annotated" name="custom_annotated" code="{N_mom(utype,exportApproxVarianceFormat_TABULAR_NONE)}" label="Custom Annotated"  >
		  <keyword  id="header" name="header" code="{N_mom(augment_utype,exportApproxVarianceFormat_TABULAR_HEADER)}" label="Header"  minOccurs="0" />
		  <keyword  id="eval_id" name="eval_id" code="{N_mom(augment_utype,exportApproxVarianceFormat_TABULAR_EVAL_ID)}" label="Eval ID"  minOccurs="0" />
		  <keyword  id="interface_id" name="interface_id" code="{N_mom(augment_utype,exportApproxVarianceFormat_TABULAR_IFACE_ID)}" label="Interface ID"  minOccurs="0" />
		</keyword>
		<keyword  id="annotated" name="annotated" code="{N_mom(utype,exportApproxVarianceFormat_TABULAR_ANNOTATED)}" label="Annotated"   default="annotated" />
		<keyword  id="freeform" name="freeform" code="{N_mom(utype,exportApproxVarianceFormat_TABULAR_NONE)}" label="Freeform"  default="annotated" />
	      </oneOf>
	    </optional>
          </keyword>
	     ' >

    <!ENTITY method_export_model '
	     <keyword  id="export_model" name="export_model" minOccurs="0" maxOccurs="1" code="{N_mdm(true,exportSurrogate)}" label="Export Surrogate Model"  complexity="1">
               <keyword  id="filename_prefix" name="filename_prefix" minOccurs="0" code="{N_mdm(str,modelExportPrefix)}" label="Exported Surrogate Filename Prefix"  default="exported_surrogate" complexity="1">
		 <param type="STRING" />
               </keyword>
               <keyword id="formats" name="formats" code="{0}" label="Formats" maxOccurs="1" group="Surrogate Export Formats" complexity="1">
		 <keyword id="text_archive" name="text_archive" code="{N_mdm(augment_utype,modelExportFormat_TEXT_ARCHIVE)}" label="Text Output" maxOccurs="1" minOccurs="0" />
		 <keyword id="binary_archive" name="binary_archive" code="{N_mdm(augment_utype,modelExportFormat_BINARY_ARCHIVE)}" label="Binary Output" maxOccurs="1" minOccurs="0"  />
               </keyword>
	     </keyword>
             ' >

    <!ENTITY method_gaussian_process '
 	     <keyword  id="gaussian_process1" name="gaussian_process" code="{0}" label="gaussian_process"  minOccurs="0" default="Surfpack Gaussian process" >
	       <alias name="kriging"/>
	       <oneOf label="GP Implementation">
		 <keyword  id="surfpack1" name="surfpack" code="{N_mdm(type,emulatorType_KRIGING_EMULATOR)}" label="surfpack"   />
		 <keyword  id="dakota1" name="dakota" code="{N_mdm(type,emulatorType_GP_EMULATOR)}" label="dakota"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY method_use_derivatives '
	     <keyword  id="use_derivatives3" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="use_derivatives"  minOccurs="0" default="use function values only" />
	     '>

    <!ENTITY surrogate_correction '
	     <keyword  id="correction" name="correction" code="{0}" label="Surrogate Correction Approach"  minOccurs="0" default="no surrogate correction" >
                  <oneOf label="Correction Order">
                    <keyword  id="zeroth_order" name="zeroth_order" code="{N_mom(order,approxCorrectionOrder_0)}" label="Zeroth Order"   />
                    <keyword  id="first_order" name="first_order" code="{N_mom(order,approxCorrectionOrder_1)}" label="First Order"   />
                    <keyword  id="second_order" name="second_order" code="{N_mom(order,approxCorrectionOrder_2)}" label="Second Order"   />
                  </oneOf>
                  <oneOf label="Correction Type">
                    <keyword  id="additive" name="additive" code="{N_mom(type,approxCorrectionType_ADDITIVE_CORRECTION)}" label="Additive"   />
                    <keyword  id="multiplicative" name="multiplicative" code="{N_mom(type,approxCorrectionType_MULTIPLICATIVE_CORRECTION)}" label="Multiplicative"   />
                    <keyword  id="combined" name="combined" code="{N_mom(type,approxCorrectionType_COMBINED_CORRECTION)}" label="Combined"   />
                  </oneOf>
		</keyword>
	     '>
 
    <!ENTITY method_export_approx_points_file '
	     <keyword  id="export_approx_points_file5" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="export_approx_points_file"  minOccurs="0" default="no point export to a file" >
	       <alias name="export_points_file"/>
	       <param type="OUTPUT_FILE" />
	       &method_export_approx_format;
	     </keyword>
	     ' >

    <!ENTITY method_refine_metric_scale '
	     <keyword  id="metric_scale" name="metric_scale" code="{0}" label="Refinement metric scale"  minOccurs="0" default="relative" >
	       <oneOf label="scale of refinement metric">
		 <keyword  id="relative" name="relative" code="{N_mdm(true,relativeConvMetric)}" label="relative refinement metric"   />
                 <keyword  id="absolute" name="absolute" code="{N_mdm(false,relativeConvMetric)}" label="absolute refinement metric"   />
	       </oneOf>
             </keyword>
	     ' >

    <!ENTITY method_mf_refine_stats_mode '
	     <keyword  id="statistics_mode" name="statistics_mode" code="{0}" label="Statistics mode for computing refinement metrics"  minOccurs="0" default="DEFAULT_EXPANSION_STATS" >
	       <oneOf label="Statistics mode for refinement metric">
		 <keyword  id="active" name="active" code="{N_mdm(type,statsMetricMode_ACTIVE_EXPANSION_STATS)}" label="refinement metric computed from active statistics"   />
                 <keyword  id="combined" name="combined" code="{N_mdm(type,statsMetricMode_COMBINED_EXPANSION_STATS)}" label="refinement computed from combined statistics"   />
	       </oneOf>
             </keyword>
	     ' >

    <!ENTITY method_convergence_tolerance '
	     <keyword  id="convergence_tolerance" name="convergence_tolerance" code="{N_mdm(Real,convergenceTolerance)}" label="Convergence tolerance"  minOccurs="0" default="1.e-4" >
               <param type="REAL" />
             </keyword>
	     ' >

    <!ENTITY method_exp_convergence_tolerance '
	     &method_convergence_tolerance;
             &method_refine_metric_scale;
	     ' >

    <!ENTITY method_mf_exp_convergence_tolerance '
	     &method_convergence_tolerance;
             &method_refine_metric_scale;
             &method_mf_refine_stats_mode;
	     ' >

    <!ENTITY method_max_iterations '
	     <keyword  id="max_iterations" name="max_iterations" code="{N_mdm(sizet,maxIterations)}" label="Maximum iterations"  minOccurs="0" default="100 (exceptions: fsu_cvt , local_reliability: 25; global_{reliability , interval_est , evidence} / efficient_global: 25*n)" >
               <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     ' >

    <!ENTITY method_max_solver_iterations '
	     <keyword  id="max_solver_iterations" name="max_solver_iterations" code="{N_mdm(sizet,maxSolverIterations)}" label="Maximum solver iterations"  minOccurs="0" default="100" >
               <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     ' >

    <!ENTITY method_max_refinement_iterations '
	     <keyword  id="max_refinement_iterations" name="max_refinement_iterations" code="{N_mdm(sizet,maxRefineIterations)}" label="Maximum refinement iterations"  minOccurs="0" default="100" >
               <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     ' >

    <!ENTITY default_constraint_tolerance '
	     <keyword  id="constraint_tolerance" name="constraint_tolerance" code="{N_mdm(Real,constraintTolerance)}" label="Constraint tolerance"  minOccurs="0" default="Library default" >
               <param type="REAL" />
	     </keyword>
	     ' >

    <!ENTITY method_max_function_evaluations '
	     <keyword  id="max_function_evaluations" name="max_function_evaluations" code="{N_mdm(sizet,maxFunctionEvals)}" label="Maximum function evaluations"  minOccurs="0" default="1000" >
               <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     ' >

    <!ENTITY sbgo_sub_problem_solver '
	    <keyword  id="sbgo" name="sbgo" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_SBGO)}" label="sbgo" >
	       <!-- &method_gaussian_process; -->
	       &method_gp_alternatives_no_export;
	       &method_use_derivatives;
	       &import_build;
	       &method_export_approx_points_file;
	     </keyword>
	     ' >

    <!ENTITY ego_sub_problem_solver '
	     <keyword  id="ego1" name="ego" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_EGO)}" label="ego" >
	       <!-- &method_gaussian_process; -->
	       &method_gp_alternatives_with_export;
	       &method_use_derivatives;
	       &import_build;
	       &method_export_approx_points_file;
	     </keyword>
	     ' >

    <!ENTITY sblo_sub_problem_solver '
	    <keyword  id="sblo" name="sbgo" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_SBLO)}" label="sblo" >
	       &method_export_approx_points_file;
	     </keyword>
	     ' >

    <!ENTITY method_gradient_sub_problem_solver '
             <optional>
	       <oneOf label="Optimization Solver">
                 <keyword  id="sqp" name="sqp" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_NPSOL)}" label="sqp" />
                 <keyword  id="nip" name="nip" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_OPTPP)}" label="nip" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY method_local_sub_problem_solver '
             <optional>
	       <oneOf label="Optimization Solver">
                 <keyword  id="sqp" name="sqp" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_NPSOL)}" label="sqp" />
                 <keyword  id="nip" name="nip" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_OPTPP)}" label="nip" />
	         &sblo_sub_problem_solver;
	         &pattern_search_sub_problem_solver;
	       </oneOf>
             </optional>
	     ' >

    <!ENTITY method_global_sub_problem_solver '
             <optional>
	       <oneOf label="Solution Approach">
	         &sbgo_sub_problem_solver;
	         &ego_sub_problem_solver;
	         <keyword  id="ea1" name="ea" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_EA)}" label="ea" />
	         <keyword  id="lhs4" name="lhs" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_LHS)}" label="lhs" />
	       </oneOf>
	     </optional>
	     ' >

    <!ENTITY method_sub_problem_solver '
             <optional>
	       <oneOf label="Optimization Solver">
                 <keyword  id="sqp" name="sqp" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_NPSOL)}" label="sqp" />
                 <keyword  id="nip" name="nip" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_OPTPP)}" label="nip" />
	         &sblo_sub_problem_solver;
	         &pattern_search_sub_problem_solver;
	         &sbgo_sub_problem_solver;
	         &ego_sub_problem_solver;
	         <keyword  id="ea1" name="ea" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_EA)}" label="ea" />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY mfmc_numerical_solve '
	    <keyword  id="numerical_solve" name="numerical_solve" code="{0}" label="numerical_solve" minOccurs="0" >
               <optional>
	         <oneOf label="Employ numerical solve">
                   <keyword  id="fallback" name="fallback" code="{N_mdm(utype,numericalSolveMode_NUMERICAL_FALLBACK)}" label="fallback" />
                   <keyword  id="override" name="override" code="{N_mdm(utype,numericalSolveMode_NUMERICAL_OVERRIDE)}" label="override" />
                 </oneOf>
               </optional>
               &method_gradient_sub_problem_solver;
	     </keyword>
	     ' >

    <!ENTITY default_trust_region '
	     <keyword  id="trust_region" name="trust_region" code="{0,0,NIDRProblemDescDB::method_tr_final}" label="Trust region group specification"  minOccurs="0" >
               <keyword  id="initial_size" name="initial_size" code="{N_mdm(RealDL,trustRegionInitSize)}" label="Trust region initial size (relative to bounds)"  minOccurs="0" >
		 <param type="REALLIST" />
               </keyword>
               <keyword  id="minimum_size" name="minimum_size" code="{N_mdm(Real,trustRegionMinSize)}" label="Trust region minimum size"  minOccurs="0" default="1.e-6" >
		 <param type="REAL" />
               </keyword>
               <keyword  id="contract_threshold" name="contract_threshold" code="{N_mdm(Real,trustRegionContractTrigger)}" label="Shrink trust region if trust region ratio is below this value"  minOccurs="0" default="0.25" >
		 <param type="REAL" />
               </keyword>
               <keyword  id="expand_threshold" name="expand_threshold" code="{N_mdm(Real,trustRegionExpandTrigger)}" label="Expand trust region if trust region ratio is above this value"  minOccurs="0" default="0.75" >
		 <param type="REAL" />
               </keyword>
               <keyword  id="contraction_factor" name="contraction_factor" code="{N_mdm(Real,trustRegionContract)}" label="Trust region contraction factor"  minOccurs="0" default="0.25">
		 <param type="REAL" />
               </keyword>
               <keyword  id="expansion_factor" name="expansion_factor" code="{N_mdm(Real,trustRegionExpand)}" label="Trust region expansion factor"  minOccurs="0" default="2.0" >
		 <param type="REAL" />
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY default_final_moments '
	     <keyword  id="final_moments" name="final_moments" code="{0}" label="Type of moments in final statistics"  minOccurs="0" default="standard" >
               <oneOf label="Final moment type">
		 <keyword  id="none" name="none" code="{N_mdm(type,finalMomentsType_NO_MOMENTS)}" label="no moments"   />
		 <keyword  id="standard" name="standard" code="{N_mdm(type,finalMomentsType_STANDARD_MOMENTS)}" label="standardized moments"   />
		 <keyword  id="central" name="central" code="{N_mdm(type,finalMomentsType_CENTRAL_MOMENTS)}" label="central moments"   />
               </oneOf>
	     </keyword>
	     ' >

    <!ENTITY default_speculative '
	     <keyword  id="speculative" name="speculative" code="{N_mdm(true,speculativeFlag)}" label="Speculative gradients and Hessians"  minOccurs="0" default="no speculation" />
	     ' >

    <!ENTITY default_scaling '
	     <keyword  id="scaling" name="scaling" code="{N_mdm(true,methodScaling)}" label="Scaling flag"  minOccurs="0" default="no scaling" />
	     ' >
    <!-- # TO DO: flatten this group and review contexts for inclusion: -->
    <!-- Defaults from old reference manual to be inserted:
	 local_reliability: 0
	 PCE: 0 (samples on approximation)
	 MCMC: 10000
	 FSU, QMC, CVT: 0 (or min req for surrogate build)
	 PSUADE: 10*(numVars+1)
	 Global interval, evidence: 10000 LHS, numVars^2 for EGO
	 DACE, sampling: minimum required
      -->

    <!ENTITY final_stats_perf_res '
             <keyword  id="final_statistics" name="final_statistics" code="{0}" label="final_statistics"  minOccurs="0" default="qoi_statistics" >
               <oneOf label="Final statistics type" >
		 <keyword  id="estimator_performance" name="estimator_performance" code="{N_mdm(utype,finalStatsType_ESTIMATOR_PERFORMANCE)}" label="Final algorithm performance" />
		 <keyword  id="qoi_statistics" name="qoi_statistics" code="{N_mdm(utype,finalStatsType_QOI_STATISTICS)}" label="Final algorithm results" >
		   &default_final_moments;
		   <!-- &response_levels_compute_rel; TO DO: support moment-based mappings -->
		   <!-- &reliability_levels;          TO DO: support moment-based mappings -->
		   &distribution_cumul_compl;               <!-- inactive without mappings -->
	         </keyword>
               </oneOf>
             </keyword>
	     ' >

    <!ENTITY import_build '
       	     <keyword  id="import_build_points_file" name="import_build_points_file" code="{N_mdm(str,importBuildPtsFile)}" label="import_build_points_file"  minOccurs="0" default="no point import from a file" >
	       <alias name="import_points_file"/>
	       <param type="INPUT_FILE" />
	       &method_import_build_format;
	       <keyword  id="active_only" name="active_only" code="{N_mdm(true,importBuildActive)}" label="Active variables only"  minOccurs="0" />
	     </keyword>
	     ' >

    <!ENTITY pce_refinement '
	     <keyword  id="p_refinement" name="p_refinement" code="{N_mdm(type,refinementType_P_REFINEMENT)}" label="Automated polynomial order refinement"  minOccurs="0" default="no refinement" >
               <oneOf label="p-refinement Type">
		 <keyword  id="uniform1" name="uniform" code="{N_mdm(type,refinementControl_UNIFORM_CONTROL)}" label="uniform"   />
		 <keyword  id="dimension_adaptive" name="dimension_adaptive" code="{0}" label="dimension_adaptive"  >
		   <oneOf label="Dimension Adaptivity Estimation Approach">
		     <keyword  id="sobol" name="sobol" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_SOBOL)}" label="sobol"   default="generalized" />
		     <keyword  id="decay" name="decay" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_DECAY)}" label="decay"   />
		     <keyword  id="generalized" name="generalized" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_GENERALIZED)}" label="generalized"   />
		   </oneOf>
		 </keyword>
	       </oneOf>
	     </keyword>
	     &method_max_refinement_iterations;
	     ' >

    <!ENTITY sc_refinement '
             <optional>
	       <oneOf label="Automated Refinement Type">
		 <keyword  id="p_refinement1" name="p_refinement" code="{N_mdm(type,refinementType_P_REFINEMENT)}" label="p_refinement"  default="no refinement" >
		   <oneOf label="p-refinement Type">
		     <keyword  id="uniform2" name="uniform" code="{N_mdm(type,refinementControl_UNIFORM_CONTROL)}" label="uniform"   />
		     <keyword  id="dimension_adaptive1" name="dimension_adaptive" code="{0}" label="dimension_adaptive"  >
		       <oneOf label="Dimension Adaptivity Estimation Approach">
			 <keyword  id="sobol1" name="sobol" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_SOBOL)}" label="sobol"   default="generalized" />
			 <keyword  id="generalized2" name="generalized" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_GENERALIZED)}" label="generalized"   />
		       </oneOf>
		     </keyword>
		   </oneOf>
		 </keyword>
		 <keyword  id="h_refinement" name="h_refinement" code="{N_mdm(type,refinementType_H_REFINEMENT)}" label="h_refinement"   default="no refinement" >
		   <oneOf label="h-refinement Type">
		     <keyword  id="uniform3" name="uniform" code="{N_mdm(type,refinementControl_UNIFORM_CONTROL)}" label="uniform"   />
		     <keyword  id="dimension_adaptive2" name="dimension_adaptive" code="{0}" label="dimension_adaptive"  >
		       <oneOf label="Dimension Adaptivity Estimation Approach">
			 <keyword  id="sobol2" name="sobol" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_SOBOL)}" label="sobol"   default="generalized" />
			 <keyword  id="generalized3" name="generalized" code="{N_mdm(type,refinementControl_DIMENSION_ADAPTIVE_CONTROL_GENERALIZED)}" label="generalized"   />
		       </oneOf>
		     </keyword>
		     <keyword  id="local_adaptive" name="local_adaptive" code="{N_mdm(type,refinementControl_LOCAL_ADAPTIVE_CONTROL)}" label="local_adaptive"   />
		   </oneOf>
		 </keyword>
	       </oneOf>
	     </optional>
	     &method_max_refinement_iterations;
	     ' >

    <!ENTITY ft_method_refinement '
             <keyword  id="p_refinement" name="p_refinement" code="{N_mdm(type,refinementType_P_REFINEMENT)}" label="Automated polynomial order refinement"  minOccurs="0" default="no refinement" >
	       <keyword  id="uniform4" name="uniform" code="{N_mdm(type,refinementControl_UNIFORM_CONTROL)}" label="uniform" >
		 <oneOf label="Uniform Refinement Approach">
		   <keyword  id="increment_start_rank" name="increment_start_rank" code="{N_mdm(type,c3AdvanceType_START_RANK_ADVANCEMENT)}" label="refinement by increment in start rank" />
		   <keyword  id="increment_start_order" name="increment_start_order" code="{N_mdm(type,c3AdvanceType_START_ORDER_ADVANCEMENT)}" label="refinement by increment in start order" />
		   <keyword  id="increment_max_rank" name="increment_max_rank" code="{N_mdm(type,c3AdvanceType_MAX_RANK_ADVANCEMENT)}" label="refinement by increment in max rank" />
		   <keyword  id="increment_max_order" name="increment_max_order" code="{N_mdm(type,c3AdvanceType_MAX_ORDER_ADVANCEMENT)}" label="refinement by increment in max order" />
		   <keyword  id="increment_max_rank_order" name="increment_max_rank_order" code="{N_mdm(type,c3AdvanceType_MAX_RANK_ORDER_ADVANCEMENT)}" label="refinement by increment in max rank and max order" />
		 </oneOf>
	       </keyword>
	     </keyword>
	     &method_max_refinement_iterations;
	     ' >

    <!ENTITY expansion_rule_nesting '
	     <optional>
	       <oneOf label="Quadrature Rule Nesting">
		 <keyword  id="nested" name="nested" code="{N_mdm(type,nestingOverride_NESTED)}" label="nested"   default="quadrature: non_nested unless automated refinement; sparse grids: nested" />
		 <keyword  id="non_nested" name="non_nested" code="{N_mdm(type,nestingOverride_NON_NESTED)}" label="non_nested" />
	       </oneOf>
	     </optional>
	     ' >

    <!ENTITY expansion_rule_growth '
	     <optional>
               <oneOf label="Quadrature Rule Growth">
		 <keyword  id="restricted" name="restricted" code="{N_mdm(type,growthOverride_RESTRICTED)}" label="restricted"   default="restricted (except for generalized sparse grids)" />
		 <keyword  id="unrestricted" name="unrestricted" code="{N_mdm(type,growthOverride_UNRESTRICTED)}" label="unrestricted"   />
               </oneOf>
             </optional>
	     ' >

    <!ENTITY expansion_dim_pref '
             <keyword  id="dimension_preference" name="dimension_preference" code="{N_mdm(RealDL,anisoDimPref)}" label="dimension_preference"  minOccurs="0" default="isotropic grids" >
	       <param type="REALLIST" />
	     </keyword>
	     ' >

    <!ENTITY sc_sparse_interpolant '
             <optional>
	       <oneOf>
		 <keyword  id="nodal" name="nodal" code="{N_mdm(type,expansionBasisType_NODAL_INTERPOLANT)}" label="nodal"   default="nodal" />
		 <keyword  id="hierarchical" name="hierarchical" code="{N_mdm(type,expansionBasisType_HIERARCHICAL_INTERPOLANT)}" label="hierarchical"   />
	       </oneOf>
	     </optional>
	     ' >

    <!ENTITY expansion_quadrature_sequence '
	     <keyword  id="quadrature_order_sequence" name="quadrature_order_sequence" code="{N_mdm(usharray,quadratureOrderSeq)}" label="Quadrature order for PCE coefficient estimation"   >
	       <param type="INTEGERLIST" />
	       &expansion_dim_pref;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY expansion_quadrature '
	     <keyword  id="quadrature_order" name="quadrature_order" code="{N_mdm(ushint,quadratureOrder)}" label="Quadrature order for PCE coefficient estimation"   >
	       <param type="INTEGER" />
	       &expansion_dim_pref;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY pce_sparse_grid_sequence '
	     <keyword  id="sparse_grid_level_sequence" name="sparse_grid_level_sequence" code="{N_mdm(usharray,sparseGridLevelSeq)}" label="Sparse grid level for PCE coefficient estimation"  >
	       <param type="INTEGERLIST" />
	       &expansion_dim_pref;
               &expansion_rule_growth;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY pce_sparse_grid '
	     <keyword  id="sparse_grid_level" name="sparse_grid_level" code="{N_mdm(ushint,sparseGridLevel)}" label="Sparse grid level for PCE coefficient estimation"  >
	       <param type="INTEGER" />
	       &expansion_dim_pref;
               &expansion_rule_growth;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY sc_sparse_grid_sequence '
	     <keyword  id="sparse_grid_level_sequence" name="sparse_grid_level_sequence" code="{N_mdm(usharray,sparseGridLevelSeq)}" label="Sparse grid level for SC interpolation"  >
	       <param type="INTEGERLIST" />
	       &expansion_dim_pref;
	       &sc_sparse_interpolant;
               &expansion_rule_growth;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY sc_sparse_grid '
	     <keyword  id="sparse_grid_level" name="sparse_grid_level" code="{N_mdm(ushint,sparseGridLevel)}" label="Sparse grid level for for SC interpolation"  >
	       <param type="INTEGER" />
	       &expansion_dim_pref;
	       &sc_sparse_interpolant;
               &expansion_rule_growth;
	       &expansion_rule_nesting;
	     </keyword>
	     ' >

    <!ENTITY pce_cubature '
	     <keyword  id="cubature_integrand" name="cubature_integrand" code="{N_mdm(ushint,cubIntOrder)}" label="Cubature integrand order for PCE coefficient estimation"   >
	       <param type="INTEGER" />
	     </keyword>
	     ' >

    <!ENTITY pce_basis_type '
             <keyword  id="basis_type" name="basis_type" code="{0}" label="basis_type"  minOccurs="0" >
	       <oneOf label="PCE Basis Type">
		 <keyword  id="tensor_product" name="tensor_product" code="{N_mdm(type,expansionBasisType_TENSOR_PRODUCT_BASIS)}" label="tensor_product"   />
		 <keyword  id="total_order" name="total_order" code="{N_mdm(type,expansionBasisType_TOTAL_ORDER_BASIS)}" label="total_order"   />
		 <keyword  id="adapted" name="adapted" code="{N_mdm(type,expansionBasisType_ADAPTED_BASIS_EXPANDING_FRONT)}" label="adapted"  >
		   <!-- <keyword  id="adapted" name="adapted" code="{0}" label="adapted"  >
			<oneOf label="Adaptation Method">
			  <keyword  id="generalized1" name="generalized" code="{N_mdm(type,expansionBasisType_ADAPTED_BASIS_GENERALIZED)}" label="generalized"  >
			    <keyword  id="initial_level" name="initial_level" code="{N_mdm(ushint,adaptedBasisInitLevel)}" label="initial_level"  minOccurs="0" >
			      <param type="INTEGER" />
			    </keyword>
			  </keyword>
			  <keyword  id="expanding_front" name="expanding_front" code="{N_mdm(type,expansionBasisType_ADAPTED_BASIS_EXPANDING_FRONT)}" label="expanding_front"  >
			    <keyword  id="advancements" name="advancements" code="{N_mdm(ushint,adaptedBasisAdvancements)}" label="advancements"  minOccurs="0" >
			      <param type="INTEGER" />
			    </keyword>
			  </keyword>
			</oneOf>
		   </keyword> -->
		   <keyword  id="advancements" name="advancements" code="{N_mdm(ushint,adaptedBasisAdvancements)}" label="advancements"  minOccurs="0" >
		     <param type="INTEGER" />
		   </keyword>
		   <keyword  id="soft_convergence_limit1" name="soft_convergence_limit" code="{N_mdm(ushint,softConvLimit)}" label="soft_convergence_limit"  minOccurs="0" >
		     <param type="INTEGER" />
		   </keyword>
		 </keyword>
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY pce_regression_alg_select '
             <optional>
	       <oneOf label="Regression Algorithm">
		 <keyword  id="least_squares" name="least_squares" code="{N_mdm(type,regressionType_DEFAULT_LEAST_SQ_REGRESSION)}" label="least_squares"  default="svd" >
		   <optional>
		     <oneOf label="LSQ Regression Approach">
		       <keyword  id="svd" name="svd" code="{N_mdm(type,lsRegressionType_SVD_LS)}" label="svd"   />
		       <keyword  id="equality_constrained" name="equality_constrained" code="{N_mdm(type,lsRegressionType_EQ_CON_LS)}" label="equality_constrained"   />
		     </oneOf>
		   </optional>
		 </keyword>
		 <keyword  id="orthogonal_matching_pursuit" name="orthogonal_matching_pursuit" code="{N_mdm(type,regressionType_ORTHOG_MATCH_PURSUIT)}" label="orthogonal_matching_pursuit"  >
		   <alias name="omp"/>
		   <keyword  id="noise_tolerance" name="noise_tolerance" code="{N_mdm(RealDL,regressionNoiseTol)}" label="noise_tolerance"  minOccurs="0" default="1e-3 for BPDN, 0. otherwise (algorithms run until termination)" >
		     <param type="REALLIST" />
		   </keyword>
		 </keyword>
		 <keyword  id="basis_pursuit" name="basis_pursuit" code="{N_mdm(type,regressionType_BASIS_PURSUIT)}" label="basis_pursuit"   >
		   <alias name="bp"/>
		 </keyword>
		 <keyword  id="basis_pursuit_denoising" name="basis_pursuit_denoising" code="{N_mdm(type,regressionType_BASIS_PURSUIT_DENOISING)}" label="basis_pursuit_denoising"  >
		   <alias name="bpdn"/>
		   <keyword  id="noise_tolerance1" name="noise_tolerance" code="{N_mdm(RealDL,regressionNoiseTol)}" label="noise_tolerance"  minOccurs="0" default="1e-3 for BPDN, 0. otherwise (algorithms run until termination)" >
		     <param type="REALLIST" />
		   </keyword>
		 </keyword>
		 <keyword  id="least_angle_regression" name="least_angle_regression" code="{N_mdm(type,regressionType_LEAST_ANGLE_REGRESSION)}" label="least_angle_regression"  >
		   <alias name="lars"/>
		   <keyword  id="noise_tolerance2" name="noise_tolerance" code="{N_mdm(RealDL,regressionNoiseTol)}" label="noise_tolerance"  minOccurs="0" default="1e-3 for BPDN, 0. otherwise (algorithms run until termination)" >
		     <param type="REALLIST" />
		   </keyword>
		 </keyword>
		 <keyword  id="least_absolute_shrinkage" name="least_absolute_shrinkage" code="{N_mdm(type,regressionType_LASSO_REGRESSION)}" label="least_absolute_shrinkage"  >
		   <alias name="lasso"/>
		   <keyword  id="noise_tolerance3" name="noise_tolerance" code="{N_mdm(RealDL,regressionNoiseTol)}" label="noise_tolerance"  minOccurs="0" default="1e-3 for BPDN, 0. otherwise (algorithms run until termination)" >
		     <param type="REALLIST" />
		   </keyword>
		   <keyword  id="l2_penalty" name="l2_penalty" code="{N_mdm(Real,regressionL2Penalty)}" label="l2_penalty"  minOccurs="0" default="0. (reverts to standard LASSO formulation)" >
		     <param type="REAL" />
		   </keyword>
		 </keyword>
	       </oneOf>
	     </optional>
	     ' >

    <!ENTITY pce_regression_opts '
	     <keyword  id="cross_validation" name="cross_validation" code="{N_mdm(true,crossValidation)}" label="cross_validation"  minOccurs="0" >
	       <keyword  id="noise_only" name="noise_only" code="{N_mdm(true,crossValidNoiseOnly)}" label="noise_only"  minOccurs="0" default="false" />
	       <keyword  id="max_cv_order_candidates" name="max_cv_order_candidates" code="{N_mdm(ushint,maxCVOrderCandidates)}" label="Maximum number of cross-validation candidates for adapting basis order" help="" minOccurs="0" default="ushort max">
		 <param type="INTEGER" constraint=">= 0" />
	       </keyword>
	     </keyword>
	     <keyword  id="ratio_order" name="ratio_order" code="{N_mdm(Realp,collocRatioTermsOrder)}" label="ratio_order"  minOccurs="0" default="1." >
	       <param type="REAL" />
	     </keyword>
	     <keyword  id="response_scaling" name="response_scaling" code="{N_mdm(true,respScalingFlag)}" label="Scale response data prior to build" help="" minOccurs="0" default="use original data"/>
	     <keyword  id="use_derivatives1" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="use_derivatives"  minOccurs="0" default="use function values only"/>
	     <keyword  id="tensor_grid" name="tensor_grid" code="{N_mdm(true,tensorGridFlag)}" label="tensor_grid"  minOccurs="0" default="regression with LHS sample set (point collocation)" />
	     <keyword  id="reuse_points" name="reuse_points" code="{N_mdm(lit,pointReuse_all)}" label="reuse_points"  minOccurs="0" default="no sample reuse in coefficient estimation" >
	       <alias name="reuse_samples"/>
	     </keyword>
	     &method_max_solver_iterations;
	     '>

    <!ENTITY mc_pilot_samples '
      	     <keyword  id="pilot_samples" name="pilot_samples" code="{N_mdm(szarray,pilotSamples)}" label="Number of initial samples per model instance" minOccurs="0" >
	       <alias name="initial_samples"/> 
	       <param type="INTEGERLIST" />
	     </keyword>
	     ' >

    <!ENTITY mc_solution_mode '
      	     <keyword  id="solution_mode" name="solution_mode" code="{0}" label="solution_mode" help="" minOccurs="0" default="online pilot" >
	       <oneOf label="Ensemble Sampling Solution Mode">
		 <keyword  id="online_pilot" name="online_pilot" code="{N_mdm(type,ensembleSampSolnMode_ONLINE_PILOT)}" label="online_pilot" help="" />
		 <keyword  id="offline_pilot" name="offline_pilot" code="{N_mdm(type,ensembleSampSolnMode_OFFLINE_PILOT)}" label="offline_pilot" help="" />
		 <keyword  id="pilot_projection" name="pilot_projection" code="{N_mdm(type,ensembleSampSolnMode_PILOT_PROJECTION)}" label="pilot_projection" help="" />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY colloc_ratio_pts_sequence_with_pce_regress '
	     <!-- Note: options within this entity are limited by NIDR requirements for an unambiguous anchor: cannot support ratio or pts or both, so anchoring with the more useful of the two.  With a new regression anchor, could mirror ft_method_regression_sequence and allow both to be optional. -->
	     <keyword  id="collocation_ratio" name="collocation_ratio" code="{N_mdm(Realp,collocationRatio)}" label="Collocation point oversampling ratio to estimate coeffs" >
	       <param type="REAL" />
	       <keyword  id="collocation_points_sequence" name="collocation_points_sequence" code="{N_mdm(szarray,collocationPointsSeq)}" label="Number collocation points to estimate coeffs" minOccurs="0" >
	         <alias name="pilot_samples"/> 
	         <param type="INTEGERLIST" />
	       </keyword>
	       &pce_regression_alg_select;
	       &pce_regression_opts;
	     </keyword>
	     ' >

    <!ENTITY colloc_pts_with_pce_regress '
	     <keyword  id="collocation_points" name="collocation_points" code="{N_mdm(sizet,collocationPoints)}" label="Number collocation points to estimate coeffs" >
	       <param type="INTEGER" />
	       &pce_regression_alg_select;
	       &pce_regression_opts;
	     </keyword>
	     ' >

    <!ENTITY colloc_ratio_with_pce_regress '
	     <keyword  id="collocation_ratio" name="collocation_ratio" code="{N_mdm(Realp,collocationRatio)}" label="Collocation point oversampling ratio to estimate coeffs" >
	       <param type="REAL" />
	       &pce_regression_alg_select;
	       &pce_regression_opts;
	     </keyword>
	     ' >

    <!ENTITY pce_expansion_samples_sequence '
      	     <keyword  id="expansion_samples_sequence" name="expansion_samples_sequence" code="{N_mdm(szarray,expansionSamplesSeq)}" label="Number simulation samples to estimate coeffs"  >
	       <param type="INTEGERLIST" />
	       <keyword  id="reuse_points1" name="reuse_points" code="{N_mdm(lit,pointReuse_all)}" label="reuse_points"  minOccurs="0" default="no sample reuse in coefficient estimation" >
		 <alias name="reuse_samples"/>
	       </keyword>
	       <!-- <keyword  id="incremental_lhs" name="incremental_lhs" code="{N_mdm(lit,expansionSampleType_incremental_lhs)}" label="Use incremental LHS for expansion_samples"  minOccurs="0" default="no sample reuse in coefficient estimation" /> -->
	     </keyword>
	     ' >

    <!ENTITY pce_expansion_samples '
      	     <keyword  id="expansion_samples" name="expansion_samples" code="{N_mdm(sizet,expansionSamples)}" label="Number simulation samples to estimate coeffs"  >
	       <param type="INTEGER" />
	       <keyword  id="reuse_points1" name="reuse_points" code="{N_mdm(lit,pointReuse_all)}" label="reuse_points"  minOccurs="0" default="no sample reuse in coefficient estimation" >
		 <alias name="reuse_samples"/>
	       </keyword>
	       <!-- <keyword  id="incremental_lhs" name="incremental_lhs" code="{N_mdm(lit,expansionSampleType_incremental_lhs)}" label="Use incremental LHS for expansion_samples"  minOccurs="0" default="no sample reuse in coefficient estimation" /> -->
	     </keyword>
	     ' >

    <!ENTITY core_pce_expansion_order '
      	     &expansion_dim_pref;
	     &pce_basis_type;
	     <oneOf>
	       &colloc_pts_with_pce_regress;
	       &colloc_ratio_with_pce_regress;
	       &pce_expansion_samples;
	     </oneOf>
	     &import_build;
	     ' >

    <!ENTITY pce_expansion_order_sequence '
      	     <keyword  id="expansion_order_sequence" name="expansion_order_sequence" code="{N_mdm(usharray,expansionOrderSeq)}" label="Expansion order"  >
	       <param type="INTEGERLIST" />
	       &expansion_dim_pref;
	       &pce_basis_type;
	       <oneOf>
		 &colloc_ratio_pts_sequence_with_pce_regress;
		 &pce_expansion_samples_sequence;
	       </oneOf>
	       &import_build;
	     </keyword>
	     ' >

    <!ENTITY pce_expansion_order '
      	     <keyword  id="expansion_order" name="expansion_order" code="{N_mdm(ushint,expansionOrder)}" label="Expansion order"  >
	       <param type="INTEGER" />
	       &core_pce_expansion_order;
	     </keyword>
	     ' >

    <!ENTITY core_pce_orthog_least_interp '
      	     <keyword  id="collocation_points" name="collocation_points" code="{N_mdm(sizet,collocationPoints)}" label="Number collocation points to estimate coeffs"   >
	       <param type="INTEGER" />
	     </keyword>
	     <!-- [ use_derivatives {N_mdm(true,methodUseDerivsFlag)} ] -->
	     <keyword  id="tensor_grid1" name="tensor_grid" code="{N_mdm(usharray,tensorGridOrder)}" label="tensor_grid"  minOccurs="0" default="regression with LHS sample set (point collocation)" >
	       <param type="INTEGERLIST" />
	     </keyword>
	     <keyword  id="reuse_points2" name="reuse_points" code="{N_mdm(lit,pointReuse_all)}" label="reuse_points"  minOccurs="0" default="no sample reuse in coefficient estimation" >
	       <alias name="reuse_samples"/>
	     </keyword>
	     &import_build;
	     ' >

    <!ENTITY pce_orthog_least_interp_sequence '
      	     <keyword  id="orthogonal_least_interpolation" name="orthogonal_least_interpolation" code="{N_mdm(type,regressionType_ORTHOG_LEAST_INTERPOLATION)}" label="Orthogonal Least Interpolation (OLI)"  >
	       <alias name="least_interpolation"/>
	       <alias name="oli"/>
	       <keyword  id="collocation_points_sequence" name="collocation_points_sequence" code="{N_mdm(szarray,collocationPointsSeq)}" label="Number of collocation points per model instance" >
	         <param type="INTEGERLIST" />
	       </keyword>
	       <!-- [ use_derivatives {N_mdm(true,methodUseDerivsFlag)} ] -->
	       <keyword  id="tensor_grid1" name="tensor_grid" code="{N_mdm(usharray,tensorGridOrder)}" label="tensor_grid"  minOccurs="0" default="regression with LHS sample set (point collocation)" >
		 <param type="INTEGERLIST" />
	       </keyword>
	       <keyword  id="reuse_points2" name="reuse_points" code="{N_mdm(lit,pointReuse_all)}" label="reuse_points"  minOccurs="0" default="no sample reuse in coefficient estimation" >
		 <alias name="reuse_samples"/>
	       </keyword>
	       &import_build;
	     </keyword>
	     ' >

    <!ENTITY pce_orthog_least_interp '
      	     <keyword  id="orthogonal_least_interpolation" name="orthogonal_least_interpolation" code="{N_mdm(type,regressionType_ORTHOG_LEAST_INTERPOLATION)}" label="Orthogonal Least Interpolation (OLI)"  >
	       <alias name="least_interpolation"/>
	       <alias name="oli"/>
	       &core_pce_orthog_least_interp;
	     </keyword>
	     ' >

    <!ENTITY pce_expansion_import '
             <keyword  id="import_expansion_file" name="import_expansion_file" code="{N_mdm(str,importExpansionFile)}" label="File name for importing expansion values and multi index to build a PCE"   >
	       <param type="INPUT_FILE" />
             </keyword>
	     ' >

    <!ENTITY mlpce_alloc_control '
      	     <keyword  id="allocation_control" name="allocation_control" code="{0}" label="allocation_control" help="" minOccurs="0" >
	       <oneOf label="Multilevel Sample Allocation Control">
		 <keyword  id="estimator_variance" name="estimator_variance" code="{N_mdm(type,multilevAllocControl_ESTIMATOR_VARIANCE)}" label="estimator_variance" help="" >
		   <keyword  id="estimator_rate" name="estimator_rate" code="{N_mdm(Real,multilevEstimatorRate)}" label="estimator_rate" help="" minOccurs="0" default="2" >
		     <param type="REAL" />
		   </keyword>
		 </keyword>
		 <keyword  id="rip_sampling" name="rip_sampling" code="{N_mdm(type,multilevAllocControl_RIP_SAMPLING)}" label="rip_sampling" help="" />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY mlft_alloc_control '
      	     <keyword  id="allocation_control" name="allocation_control" code="{0}" label="allocation_control" help="" minOccurs="0" >
	       <oneOf label="Multilevel Sample Allocation Control">
		 <keyword  id="estimator_variance" name="estimator_variance" code="{N_mdm(type,multilevAllocControl_ESTIMATOR_VARIANCE)}" label="estimator_variance" help="" >
		   <keyword  id="estimator_rate" name="estimator_rate" code="{N_mdm(Real,multilevEstimatorRate)}" label="estimator_rate" help="" minOccurs="0" default="2" >
		     <param type="REAL" />
		   </keyword>
		 </keyword>
		 <keyword  id="rank_sampling" name="rank_sampling" code="{N_mdm(type,multilevAllocControl_RANK_SAMPLING)}" label="rank_sampling" help="" />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY mf_alloc_control '
      	     <keyword  id="allocation_control" name="allocation_control" code="{0}" label="allocation_control" help="" minOccurs="0" >
	       <oneOf label="Multifidelity Sample Allocation Control">
		 <keyword  id="greedy" name="greedy" code="{N_mdm(type,multilevAllocControl_GREEDY_REFINEMENT)}" label="greedy" help="" />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY discrep_emulation '
      	     <keyword  id="discrepancy_emulation" name="discrepancy_emulation" code="{0}" label="Multilevel-multifidelity discrepancy emulation approach"  minOccurs="0" default="distinct" >
	       <oneOf label="Discrepancy Emulation Approach">
		 <keyword  id="distinct" name="distinct" code="{N_mdm(type,multilevDiscrepEmulation_DISTINCT_EMULATION)}" label="distinct" >
	           <alias name="paired" />
	         </keyword>
		 <keyword  id="recursive" name="recursive" code="{N_mdm(type,multilevDiscrepEmulation_RECURSIVE_EMULATION)}" label="recursive"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY vbd_expansion '
      	     <keyword  id="variance_based_decomp" name="variance_based_decomp" code="{N_mdm(true,vbdFlag)}" label="Variance based decomposition (VBD)"  minOccurs="0" default="no variance-based decomposition" >
	       <keyword  id="interaction_order" name="interaction_order" code="{N_mdm(ushint,vbdOrder)}" label="Restriction of order of VBD interations"  minOccurs="0" default="Unrestricted (VBD includes all interaction orders present in the expansion)" >
		 <param type="INTEGER" constraint="> 0" />
	       </keyword>
	       <keyword  id="drop_tolerance" name="drop_tolerance" code="{N_mdm(Real,vbdDropTolerance)}" label="VBD tolerance for omitting small indices"  minOccurs="0" default="All VBD indices displayed" >
		 <param type="REAL" />
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY method_seed '
	     <keyword  id="seed1" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	       <param type="INTEGER" constraint="> 0" />
	     </keyword>
	     <keyword  id="fixed_seed" name="fixed_seed" code="{N_mdm(true,fixedSeedFlag)}" label="fixed_seed"  minOccurs="0" default="not fixed; pattern varies run-to-run" />
	     ' >

    <!ENTITY method_seed_sequence '
	     <keyword id="seed_sequence" name="seed_sequence" code="{N_mdm(szarray,randomSeedSeq)}" label="seed" minOccurs="0" default="system-generated (non-repeatable)" >
	       <param type="INTEGERLIST" />
	     </keyword>
	     <keyword  id="fixed_seed" name="fixed_seed" code="{N_mdm(true,fixedSeedFlag)}" label="fixed_seed"  minOccurs="0" default="not fixed; pattern varies run-to-run" />
	     ' >

    <!ENTITY method_sample_type_lhs_mc '
	     <keyword  id="sample_type" name="sample_type" code="{0}" label="sample_type"  minOccurs="0" default="random" >
	       <oneOf label="Sample Type">
	         <keyword  id="lhs" name="lhs" code="{N_mdm(utype,sampleType_SUBMETHOD_LHS)}" label="lhs"   />
	         <keyword  id="random" name="random" code="{N_mdm(utype,sampleType_SUBMETHOD_RANDOM)}" label="random"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY method_sample_type '
	     <keyword  id="sample_type" name="sample_type" code="{0}" label="sample_type"  minOccurs="0" default="lhs" >
	       <oneOf label="Sample Type">
	         <keyword  id="lhs" name="lhs" code="{N_mdm(utype,sampleType_SUBMETHOD_LHS)}" label="lhs"   />
	         <keyword  id="random" name="random" code="{N_mdm(utype,sampleType_SUBMETHOD_RANDOM)}" label="random"   />
	         <keyword  id="incremental_lhs" name="incremental_lhs" code="{N_mdm(utype,sampleType_SUBMETHOD_LHS)}" label="incremental_lhs"   default="no sample reuse in coefficient estimation" />
	         <keyword  id="incremental_random" name="incremental_random" code="{N_mdm(utype,sampleType_SUBMETHOD_RANDOM)}" label="incremental_random"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY samples_on_emulator_with_alias '
	     <keyword  id="samples_on_emulator" name="samples_on_emulator" code="{N_mdm(int,samplesOnEmulator)}" label="Samples on emulator"  minOccurs="0" >
	       <alias name="samples" />
	       <param type="INTEGER" />
	     </keyword>
	     ' >

    <!ENTITY expansion_options '
      	     <!-- Old reference default; samples = 0 -->
	     &samples_on_emulator_with_alias;
	     &method_sample_type_lhs_mc;
             &rng_options;
	     <keyword  id="probability_refinement" name="probability_refinement" code="{0}" label="Importance sampling refinement"  minOccurs="0" default="no refinement">
	       <!-- TODO: consider removing this alias: -->
	       <alias name="sample_refinement"/>
	       <oneOf label="Importance Sampling Approach">
		 <keyword  id="import" name="import" code="{N_mdm(utype,integrationRefine_IS)}" label="import"   />
		 <keyword  id="adapt_import" name="adapt_import" code="{N_mdm(utype,integrationRefine_AIS)}" label="adapt_import"   />
		 <keyword  id="mm_adapt_import" name="mm_adapt_import" code="{N_mdm(utype,integrationRefine_MMAIS)}" label="mm_adapt_import"   />
	       </oneOf>
	       <keyword  id="refinement_samples" name="refinement_samples" code="{N_mdm(ivec,refineSamples)}" label="Refinement samples"  minOccurs="0" >
		 <param type="INTEGERLIST" />
	       </keyword>
	     </keyword>
             &default_final_moments;
             &level_mappings;
	     &vbd_expansion;
	     <optional>
	       <oneOf label="Covariance Type">
		 <keyword  id="diagonal_covariance" name="diagonal_covariance" code="{N_mdm(type,covarianceControl_DIAGONAL_COVARIANCE)}" label="diagonal_covariance"   default="diagonal_covariance for response vector > 10; else full_covariance" />
		 <keyword  id="full_covariance" name="full_covariance" code="{N_mdm(type,covarianceControl_FULL_COVARIANCE)}" label="full_covariance"   />
	       </oneOf>
	     </optional>
	     <keyword  id="import_approx_points_file" name="import_approx_points_file" code="{N_mdm(str,importApproxPtsFile)}" label="File name for importing samples for evaluating the PCE"  minOccurs="0" default="no point import from a file" >
	       <param type="INPUT_FILE" />
	       &method_import_approx_format;
	       <keyword  id="active_only2" name="active_only" code="{N_mdm(true,importApproxActive)}" label="Active variables only"  minOccurs="0" />
	     </keyword>
	     <keyword  id="export_approx_points_file1" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="File name for exporting approximation-based samples from evaluating the PCE"  minOccurs="0" default="no point export to a file" >
	       <alias name="export_points_file"/>
	       <param type="OUTPUT_FILE" />
	       &method_export_approx_format;
	     </keyword>
	     ' >

    <!ENTITY pce_options '
      	     <optional>
	       <oneOf label="Basis Polynomial Family">
	         <keyword  id="askey" name="askey" code="{N_mdm(type,expansionType_ASKEY_U)}" label="askey"  default="extended (Askey + numerically-generated)" />
	         <keyword  id="wiener" name="wiener" code="{N_mdm(type,expansionType_STD_NORMAL_U)}" label="wiener"  default="extended (Askey + numerically-generated)" />
	         <!-- # | piecewise {N_mdm(type,expansionType_}) -->
	       </oneOf>
             </optional>
	     <keyword  id="normalized" name="normalized" code="{N_mdm(true,normalizedCoeffs)}" label="Output PCE coefficients corresponding to normalized basis"  minOccurs="0" default="PCE coefficients correspond to unnormalized basis polynomials" />
	     <keyword  id="export_expansion_file" name="export_expansion_file" code="{N_mdm(str,exportExpansionFile)}" label="File name for exporting the coefficients and multi-index of a PCE "  minOccurs="0" >
	       <param type="OUTPUT_FILE" />
	     </keyword>
	     ' >

    <!ENTITY sc_options '
             <optional>
	       <oneOf label="Basis Polynomial Family">
		 <keyword  id="piecewise" name="piecewise" code="{NIDRProblemDescDB::method_piecewise}" label="piecewise"  default="extended (Askey + numerically-generated)" />
		 <keyword  id="askey1" name="askey" code="{N_mdm(type,expansionType_ASKEY_U)}" label="askey"  default="extended (Askey + numerically-generated)"  />
		 <keyword  id="wiener1" name="wiener" code="{N_mdm(type,expansionType_STD_NORMAL_U)}" label="wiener"  default="extended (Askey + numerically-generated)" />
	       </oneOf>
	     </optional>
	     <keyword  id="use_derivatives2" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="Derivative enhancement flag"  minOccurs="0" default="use function values only" />
	     ' >

    <!ENTITY ft_method_regression_opts '
	     <keyword id="regression_type" name="regression_type" code="{0}" label="Objective formulation for FT regression" minOccurs="0" default="">
	       <oneOf label="Regression Type">
	         <keyword id="ls" name="ls" code="{N_mdm(type,regressionType_FT_LS)}" label="ls" />
	         <keyword id="rls2" name="rls2" code="{N_mdm(type,regressionType_FT_RLS2)}" label="rls2" >
	           <keyword  id="l2_penalty" name="l2_penalty" code="{N_mdm(Real,regressionL2Penalty)}" label="l2_penalty"  >
	             <param type="REAL" />
	           </keyword>
	         </keyword>
	         <!-- <keyword id="rlsd2" name="rlsd2" code="{N_mdm(type,regressionType_FT_RLSD2)}" label="rlsd2" />         EXPERIMENTAL -->
                 <!-- <keyword id="rlsrkhs" name="rlsrkhs" code="{N_mdm(type,regressionType_FT_RLSRKHS)}" label="rlsrkhs" /> EXPERIMENTAL -->
                 <!-- <keyword id="rls1" name="rls1" code="{N_mdm(type,regressionType_FT_RLS1)}" label="rls1" />             EXPERIMENTAL -->
	       </oneOf>
	     </keyword>
	     &method_max_solver_iterations;
	     <keyword  id="max_cross_iterations" name="max_cross_iterations" code="{N_mdm(int,maxCrossIterations)}" label="Maximum number of cross approximation iterations" help="" minOccurs="0" default="1">
	       <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     <keyword  id="solver_tolerance" name="solver_tolerance" code="{N_mdm(Real,solverTol)}" label="Solver Tolerance" help="" minOccurs="0" default="1.0e-10" >
	       <param type="REAL" />
	     </keyword>
	     <keyword  id="response_scaling" name="response_scaling" code="{N_mdm(true,respScalingFlag)}" label="Scale response data prior to build" help="" minOccurs="0" default="use original data"/>
	     <!-- <keyword  id="use_derivatives1" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="use_derivatives"  minOccurs="0" default="use function values only"/> -->
	     <keyword  id="tensor_grid" name="tensor_grid" code="{N_mdm(true,tensorGridFlag)}" label="tensor_grid" minOccurs="0" default="regression with random sample set" />
	     ' >

    <!ENTITY ft_method_regression_sequence '
	     &ft_method_regression_opts;
	     <keyword  id="collocation_points_sequence" name="collocation_points_sequence" code="{N_mdm(szarray,collocationPointsSeq)}" label="Number collocation points to estimate coeffs" minOccurs="0" >
	       <alias name="pilot_samples"/> 
	       <param type="INTEGERLIST" />
	     </keyword>
	     <keyword  id="collocation_ratio" name="collocation_ratio" code="{N_mdm(Realp,collocationRatio)}" label="Collocation point oversampling ratio to estimate coeffs" minOccurs="0" default="0." >
	       <param type="REAL" />
	     </keyword>
	     ' >

    <!ENTITY ft_method_regression '
	     &ft_method_regression_opts;
	     <oneOf label="Collocation Control">
	       <keyword  id="collocation_points" name="collocation_points" code="{N_mdm(sizet,collocationPoints)}" label="Number collocation points to estimate coeffs" >
		 <param type="INTEGER" />
	       </keyword>
	       <keyword  id="collocation_ratio" name="collocation_ratio" code="{N_mdm(Realp,collocationRatio)}" label="Collocation point oversampling ratio to estimate coeffs" >
		 <param type="REAL" />
	       </keyword>
	     </oneOf>
	     ' >

    <!ENTITY ft_method_order_scalars '
		  <keyword  id="adapt_order" name="adapt_order" code="{N_mdm(true,adaptOrder)}" label="Adapt polynomial basis order using cross validation" help="" minOccurs="0" default="false" />
		  <keyword  id="kick_order" name="kick_order" code="{N_mdm(ushint,kickOrder)}" label="Increment when adapting polynomial basis order" help="" minOccurs="0" default="1">
		    <param type="INTEGER" constraint="> 0" />
		  </keyword>
		  <keyword  id="max_order" name="max_order" code="{N_mdm(ushint,maxOrder)}" label="Maximum order of polynomials" help="" minOccurs="0" default="unsigned short max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="max_cv_order_candidates" name="max_cv_order_candidates" code="{N_mdm(ushint,maxCVOrderCandidates)}" label="Maximum number of cross-validation candidates for adapting basis order" help="" minOccurs="0" default="ushort max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
	     ' >

    <!ENTITY ft_method_order '
		  <keyword  id="start_order" name="start_order" code="{N_mdm(ushint,startOrder)}" label="Starting polynomial order of univariate polynomials" help="" minOccurs="0" default="2">
		    <alias name="order"/>
		    <param type="INTEGER" constraint=">= 0" />
		    &expansion_dim_pref;
		  </keyword>
		  &ft_method_order_scalars;
	     ' >

    <!ENTITY mlft_method_order_sequence '
		  <keyword  id="start_order_sequence" name="start_order_sequence" code="{N_mdm(usharray,startOrderSeq)}" label="Starting univariate polynomial order for approximation sequence" help="" minOccurs="0" default="2">
		    <alias name="order_sequence"/>
		    <param type="INTEGERLIST" />
		    &expansion_dim_pref;
		  </keyword>
		  &ft_method_order_scalars;
	     ' >

    <!ENTITY ft_method_rank_scalars '
		  <keyword  id="adapt_rank" name="adapt_rank" code="{N_mdm(true,adaptRank)}" label="Flag for whether or not to adapt the rank" help="" minOccurs="0" default="false" />
		  <keyword  id="kick_rank" name="kick_rank" code="{N_mdm(sizet,kickRank)}" label="Rank increment for adaptive schemes" help="" minOccurs="0" default="1">
		    <param type="INTEGER" constraint="> 0" />
		  </keyword>
		  <keyword  id="max_rank" name="max_rank" code="{N_mdm(sizet,maxRank)}" label="Maximum rank of the function train" help="" minOccurs="0" default="size_t max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="max_cv_rank_candidates" name="max_cv_rank_candidates" code="{N_mdm(sizet,maxCVRankCandidates)}" label="Maximum number of cross-validation candidates for adapting rank" help="" minOccurs="0" default="size_t max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
	     ' >

    <!ENTITY ft_method_rank '
		  <keyword  id="start_rank" name="start_rank" code="{N_mdm(sizet,startRank)}" label="Starting rank for approximation" help="" minOccurs="0" default="2">
		    <alias name="rank"/>
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  &ft_method_rank_scalars;
	     ' >

    <!ENTITY mlft_method_rank_sequence '
		  <keyword  id="start_rank_sequence" name="start_rank_sequence" code="{N_mdm(szarray,startRankSeq)}" label="Starting rank for approximation sequence" help="" minOccurs="0" default="2">
		    <alias name="rank_sequence"/>
		    <param type="INTEGERLIST" />
		  </keyword>
		  &ft_method_rank_scalars;
	     ' >

    <!ENTITY ft_method_tols '
		  <keyword  id="rounding_tolerance" name="rounding_tolerance" code="{N_mdm(Real,solverRoundingTol)}" label="Rounding Tolerance" help="" minOccurs="0" default="1.e-10" >
		    <param type="REAL" />
		  </keyword>
		  <keyword  id="arithmetic_tolerance" name="arithmetic_tolerance" code="{N_mdm(Real,statsRoundingTol)}" label="Arithmetic Tolerance" help="" minOccurs="0" default="1.e-10" >
		    <param type="REAL" />
		  </keyword>
	     ' >

    <!--
    <!ENTITY ft_model_refinement '
             <keyword  id="p_refinement" name="p_refinement" code="{N_mom(type,refinementType_P_REFINEMENT)}" label="Automated polynomial order refinement"  minOccurs="0" default="no refinement" >
	       <keyword  id="uniform4" name="uniform" code="{N_mom(type,refinementControl_UNIFORM_CONTROL)}" label="uniform" >
		 <oneOf label="Uniform Refinement Approach">
		   <keyword  id="increment_start_rank" name="increment_start_rank" code="{N_mom(type,c3AdvanceType_START_RANK_ADVANCEMENT)}" label="refinement by increment in start rank" />
		   <keyword  id="increment_start_order" name="increment_start_order" code="{N_mom(type,c3AdvanceType_START_ORDER_ADVANCEMENT)}" label="refinement by increment in start order" />
		   <keyword  id="increment_max_rank" name="increment_max_rank" code="{N_mom(type,c3AdvanceType_MAX_RANK_ADVANCEMENT)}" label="refinement by increment in max rank" />
		   <keyword  id="increment_max_order" name="increment_max_order" code="{N_mom(type,c3AdvanceType_MAX_ORDER_ADVANCEMENT)}" label="refinement by increment in max order" />
		   <keyword  id="increment_max_rank_order" name="increment_max_rank_order" code="{N_mom(type,c3AdvanceType_MAX_RANK_ORDER_ADVANCEMENT)}" label="refinement by increment in max rank and max order" />
		 </oneOf>
	       </keyword>
	     </keyword>
	     &model_max_refinement_iterations;
	     &model_exp_convergence_tolerance;
	     ' >
    -->

    <!ENTITY ft_model_regression_opts '
	     <keyword id="regression_type" name="regression_type" code="{0}" label="Objective formulation for FT regression" minOccurs="0" default="">
	       <oneOf label="Regression Type">
	         <keyword id="ls" name="ls" code="{N_mom(type,regressionType_FT_LS)}" label="ls" />
	         <keyword id="rls2" name="rls2" code="{N_mom(type,regressionType_FT_RLS2)}" label="rls2" >
	           <keyword  id="l2_penalty" name="l2_penalty" code="{N_mom(Real,regressionL2Penalty)}" label="l2_penalty"  >
	             <param type="REAL" />
	           </keyword>
	         </keyword>
	         <!-- <keyword id="rlsd2" name="rlsd2" code="{N_mom(type,regressionType_FT_RLSD2)}" label="rlsd2" />         EXPERIMENTAL -->
                 <!-- <keyword id="rlsrkhs" name="rlsrkhs" code="{N_mom(type,regressionType_FT_RLSRKHS)}" label="rlsrkhs" /> EXPERIMENTAL -->
                 <!-- <keyword id="rls1" name="rls1" code="{N_mom(type,regressionType_FT_RLS1)}" label="rls1" />             EXPERIMENTAL -->
	       </oneOf>
	     </keyword>
	     <keyword  id="max_solver_iterations" name="max_solver_iterations" code="{N_mom(sizet,maxSolverIterations)}" label="Maximum solver iterations"  minOccurs="0" default="100" >
	       <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     <keyword  id="max_cross_iterations" name="max_cross_iterations" code="{N_mom(int,maxCrossIterations)}" label="Maximum number of cross approximation iterations" help="" minOccurs="0" default="1">
	       <param type="INTEGER" constraint=">= 0" />
	     </keyword>
	     <keyword  id="solver_tolerance" name="solver_tolerance" code="{N_mom(Real,solverTol)}" label="Solver Tolerance" help="" minOccurs="0" default="1.0e-10" >
	       <param type="REAL" />
	     </keyword>
	     <keyword  id="response_scaling" name="response_scaling" code="{N_mom(true,respScalingFlag)}" label="Scale response data prior to build" minOccurs="0" default="use original data"/>
	     <!-- <keyword  id="use_derivatives1" name="use_derivatives" code="{N_mom(true,methodUseDerivsFlag)}" label="use_derivatives"  minOccurs="0" default="use function values only"/> -->
	     <keyword  id="tensor_grid" name="tensor_grid" code="{N_mom(true,tensorGridFlag)}" label="tensor_grid"  minOccurs="0" default="regression with random sample set" />
	     ' >

    <!ENTITY ft_model_regression '
	     &ft_model_regression_opts;
	     <oneOf label="Collocation Control">
	       <keyword  id="collocation_points" name="collocation_points" code="{N_mom(sizet,collocationPoints)}" label="Number collocation points to estimate coeffs" >
		 <param type="INTEGER" />
	       </keyword>
	       <keyword  id="collocation_ratio" name="collocation_ratio" code="{N_mom(Real,collocationRatio)}" label="Collocation point oversampling ratio to estimate coeffs" >
		 <param type="REAL" />
	       </keyword>
	     </oneOf>
	     ' >

    <!ENTITY ft_model_tols '
	     <keyword  id="rounding_tolerance" name="rounding_tolerance" code="{N_mom(Real,solverRoundingTol)}" label="Rounding Tolerance" help="" minOccurs="0" default="1.e-10" >
	       <param type="REAL" />
	     </keyword>
	     <keyword  id="arithmetic_tolerance" name="arithmetic_tolerance" code="{N_mom(Real,statsRoundingTol)}" label="Arithmetic Tolerance" help="" minOccurs="0" default="1.e-10" >
	       <param type="REAL" />
	     </keyword>
	     ' >

    <!ENTITY ft_model_order '
		  <keyword  id="start_order" name="start_order" code="{N_mom(ushint,startOrder)}" label="Starting polynomial order of univariate polynomials" help="" minOccurs="0" default="2">
		    <alias name="order"/>
		    <param type="INTEGER" constraint=">= 0" />
		    &expansion_dim_pref;
		  </keyword>
		  <keyword  id="adapt_order" name="adapt_order" code="{N_mom(true,adaptOrder)}" label="Adapt polynomial basis order using cross validation" help="" minOccurs="0" default="false" />
		  <keyword  id="kick_order" name="kick_order" code="{N_mom(ushint,kickOrder)}" label="Increment when adapting polynomial basis order" help="" minOccurs="0" default="1">
		    <param type="INTEGER" constraint="> 0" />
		  </keyword>
		  <keyword  id="max_order" name="max_order" code="{N_mom(ushint,maxOrder)}" label="Maximum order of polynomials" help="" minOccurs="0" default="4">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="max_cv_order_candidates" name="max_cv_order_candidates" code="{N_mom(ushint,maxCVOrderCandidates)}" label="Maximum number of cross-validation candidates for adapting basis order" help="" minOccurs="0" default="ushort max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
	     ' >

    <!ENTITY ft_model_rank '
		  <keyword  id="start_rank" name="start_rank" code="{N_mom(sizet,startRank)}" label="Starting rank for approximation" help="" minOccurs="0" default="2">
		    <alias name="rank"/>
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="adapt_rank" name="adapt_rank" code="{N_mom(true,adaptRank)}" label="Flag for whether or not to adapt the rank" help="" minOccurs="0" default="false"/>
		  <keyword  id="kick_rank" name="kick_rank" code="{N_mom(sizet,kickRank)}" label="Rank increment for adaptive schemes" help="" minOccurs="0" default="2">
		    <param type="INTEGER" constraint="> 0" />
		  </keyword>
		  <keyword  id="max_rank" name="max_rank" code="{N_mom(sizet,maxRank)}" label="Maximum rank of the function train" help="" minOccurs="0" default="3">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="max_cv_rank_candidates" name="max_cv_rank_candidates" code="{N_mom(sizet,maxCVRankCandidates)}" label="Maximum number of cross-validation candidates for adapting rank" help="" minOccurs="0" default="size_t max">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
	     ' >

    <!ENTITY bayes_seed_rng '
	     <keyword  id="seed1" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	       <param type="INTEGER" constraint="> 0" />
	     </keyword>
             &rng_options;
	     ' >

    <!ENTITY bayes_expansion_options '
	     <optional>
	       <oneOf label="Covariance Type">
		 <keyword  id="diagonal_covariance" name="diagonal_covariance" code="{N_mdm(type,covarianceControl_DIAGONAL_COVARIANCE)}" label="diagonal_covariance"   default="diagonal_covariance for response vector > 10; else full_covariance" />
		 <keyword  id="full_covariance" name="full_covariance" code="{N_mdm(type,covarianceControl_FULL_COVARIANCE)}" label="full_covariance"   />
	       </oneOf>
	     </optional>
	     ' >

    <!ENTITY bayes_pce_expansion_order '
	     <keyword  id="expansion_order" name="expansion_order" code="{N_mdm(ushint,expansionOrder)}" label="Expansion order"  >
	       <param type="INTEGER" />
	       &core_pce_expansion_order;
	       <keyword  id="posterior_adaptive1" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/>
	     </keyword>
	     ' >

    <!ENTITY bayes_pce_orthog_least_interp '
      	     <keyword  id="orthogonal_least_interpolation" name="orthogonal_least_interpolation" code="{N_mdm(type,regressionType_ORTHOG_LEAST_INTERPOLATION)}" label="Orthogonal Least Interpolation (OLI)"  >
	       <alias name="least_interpolation"/>
	       <alias name="oli"/>
	       &core_pce_orthog_least_interp;
	       <keyword  id="posterior_adaptive2" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/>
	     </keyword>
	     ' >

    <!ENTITY bayes_pce '
	     <keyword  id="pce" name="pce" code="{N_mdm(type,emulatorType_PCE_EMULATOR)}" label="pce"  >
	       &pce_refinement;
	       <oneOf>
		 &expansion_quadrature;
		 &pce_sparse_grid;
		 &pce_cubature;
		 &bayes_pce_expansion_order;
		 &bayes_pce_orthog_least_interp;
                 &pce_expansion_import;
               </oneOf>
	       &pce_options;
	       &bayes_expansion_options;
	     </keyword>
	     ' >

    <!ENTITY bayes_ml_pce '
      	     <keyword  id="ml_pce" name="ml_pce" code="{N_mdm(type,emulatorType_ML_PCE_EMULATOR)}" label="ml_pce"  >
	       &mlpce_alloc_control;
	       &discrep_emulation;
	       <oneOf>
		 &pce_expansion_order_sequence;
		 &pce_orthog_least_interp_sequence;
	       </oneOf>
	       &pce_options;
	       &bayes_expansion_options;
	       <!-- <keyword  id="posterior_adaptive1" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/> -->
	     </keyword>
	     ' >

    <!ENTITY bayes_mf_pce '
      	     <keyword  id="mf_pce" name="mf_pce" code="{N_mdm(type,emulatorType_MF_PCE_EMULATOR)}" label="mf_pce"  >
	       &pce_refinement;
	       &mf_alloc_control;
	       &discrep_emulation;
	       <oneOf>
		 &expansion_quadrature_sequence;
		 &pce_sparse_grid_sequence;
		 <!-- <required> -->
		 &pce_expansion_order_sequence;
		 <!-- <keyword  id="posterior_adaptive1" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/> -->
		 <!-- </required> -->
		 <!-- <required> -->
		 &pce_orthog_least_interp_sequence;
		 <!-- <keyword  id="posterior_adaptive2" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/> -->
		 <!-- </required> -->
	       </oneOf>
	       &pce_options;
	       &bayes_expansion_options;
	     </keyword>
	     ' >

    <!ENTITY bayes_sc '
     	     <keyword  id="sc" name="sc" code="{N_mdm(type,emulatorType_SC_EMULATOR)}" label="sc"  >
	       &sc_refinement;
	       <oneOf label="Interpolation Grid Type">
		 &expansion_quadrature;
		 &sc_sparse_grid;
	       </oneOf>
	       &sc_options;
	       &bayes_expansion_options;
	     </keyword>
	     ' >

    <!ENTITY bayes_mf_sc '
      	     <keyword  id="mf_sc" name="mf_sc" code="{N_mdm(type,emulatorType_MF_SC_EMULATOR)}" label="mf_sc"  >
	       &sc_refinement;
	       &mf_alloc_control;
	       &discrep_emulation;
	       <oneOf label="Interpolation Grid Type">
		 &expansion_quadrature_sequence;
		 &sc_sparse_grid_sequence;
	       </oneOf>
	       &sc_options;
	       &bayes_expansion_options;
	     </keyword>
	     ' >

    <!ENTITY bayes_emulator '
      	     <keyword  id="emulator" name="emulator" code="{0}" label="emulator"  minOccurs="0" >
	       <oneOf label="Emulator Type" >
		 <keyword  id="gaussian_process3" name="gaussian_process" code="{0}" label="gaussian_process"  default="Surfpack Gaussian process" >
		   <alias name="kriging"/>
		   <oneOf label="GP Implementation">
		     <keyword  id="surfpack3" name="surfpack" code="{N_mdm(type,emulatorType_KRIGING_EMULATOR)}" label="surfpack"   />
		     <keyword  id="dakota3" name="dakota" code="{N_mdm(type,emulatorType_GP_EMULATOR)}" label="dakota"   />
		   </oneOf>
		   <keyword  id="build_samples3" name="build_samples" code="{N_mdm(int,buildSamples)}" label="Samples to build emulator"  minOccurs="0" >
		     <param type="INTEGER" />
		   </keyword>
		   <keyword  id="posterior_adaptive" name="posterior_adaptive" code="{N_mdm(true,adaptPosteriorRefine)}" label="posterior_adaptive"  minOccurs="0"/>
		   &import_build;
		 </keyword>
		 &bayes_pce;
		 &bayes_ml_pce;
		 &bayes_mf_pce;
		 &bayes_sc;
		 &bayes_mf_sc;
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY bayes_proposal_covariance '
	     <keyword id="proposal_covariance" name="proposal_covariance" code="{N_mdm(lit,proposalCovType_user)}" label="Proposal covariance type"  minOccurs="0" >
	       <oneOf label="Proposal Covariance Source">
		 <keyword id="prior" name="prior" code="{N_mdm(lit,proposalCovType_prior)}" label="Prior-based proposal covariance">
		   <keyword  id="multiplier" name="multiplier" code="{N_mdm(Real,priorPropCovMult)}" label="Proposal Covariance Multiplier"  minOccurs="0" default="1.0" >
		     <param type="REAL" constraint="> 0.0" />
		   </keyword>
		 </keyword>
		 <keyword id="derivatives" name="derivatives" code="{N_mdm(lit,proposalCovType_derivatives)}" label="Derivative-based proposal covariance"  >
		   <keyword id="update_period" name="update_period" code="{N_mdm(int,proposalCovUpdatePeriod)}" label="Samples between proposal updates"  minOccurs="0" >
		     <param type="INTEGER" />
		   </keyword>
		 </keyword>
		 <keyword id="values" name="values" code="{N_mdm(RealDL,proposalCovData)}" label="User-provided proposal covariance data values"  >
		   <param type="REALLIST"/>
		   <oneOf label="Values For">
		     <keyword id="diagonal" name="diagonal" code="{N_mdm(lit,proposalCovInputType_diagonal)}" label="Diagonal covariance input"   />
		     <keyword id="matrix" name="matrix" code="{N_mdm(lit,proposalCovInputType_matrix)}" label="Matrix covariance input"   />
		   </oneOf>
		 </keyword>
		 <keyword id="filename" name="filename" code="{N_mdm(str,proposalCovFile)}" label="User-provided proposal covariance filename"  >
		   <param type="INPUT_FILE"/>
		   <oneOf label="Values For">
		     <keyword id="diagonal" name="diagonal" code="{N_mdm(lit,proposalCovInputType_diagonal)}" label="Diagonal covarianceinput "   />
		     <keyword id="matrix" name="matrix" code="{N_mdm(lit,proposalCovInputType_matrix)}" label="Matrix covariance input"   />
		   </oneOf>
		 </keyword>
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY method_conmin_common_opts '
	     &method_max_iterations;
             &method_convergence_tolerance;
             &default_constraint_tolerance;
             &default_speculative;
             &method_max_function_evaluations;
             &default_scaling;
	     &method_optional_model_pointer;
	     ' >

    <!ENTITY method_dot_common_opts '
	     &method_max_iterations;
             &method_convergence_tolerance;
             &default_constraint_tolerance;
             &default_speculative;
             &method_max_function_evaluations;
             &default_scaling;
	     &method_optional_model_pointer;
	     ' >

    <!ENTITY method_npsol_common_opts '
             <keyword  id="verify_level" name="verify_level" code="{N_mdm(int,verifyLevel)}" label="verify_level"  minOccurs="0" default="-1 (no gradient verification)" >
               <param type="INTEGER" />
             </keyword>
             <keyword  id="function_precision" name="function_precision" code="{N_mdm(Real,functionPrecision)}" label="function_precision"  minOccurs="0" default="1.0e-10" >
               <param type="REAL" />
             </keyword>
             <keyword  id="linesearch_tolerance" name="linesearch_tolerance" code="{N_mdm(Real,lineSearchTolerance)}" label="linesearch_tolerance"  minOccurs="0" default="0.9 (inaccurate line search)" >
               <param type="REAL" />
             </keyword>
             &method_convergence_tolerance;
	     &method_max_iterations;
             &default_constraint_tolerance;
             &default_speculative;
             &method_max_function_evaluations;
             &default_scaling;
	     &method_optional_model_pointer;
	     ' >

    <!ENTITY method_optpp_newton_opts '
             <keyword  id="search_method" name="search_method" code="{0}" label="search_method"  minOccurs="0" >
               <oneOf label="Line Search Method">
                 <keyword  id="value_based_line_search" name="value_based_line_search" code="{N_mdm(lit,searchMethod_value_based_line_search)}" label="value_based_line_search"   default="trust_region (unconstrained), value_based_line_search (bound/general constraints)" />
                 <keyword  id="gradient_based_line_search" name="gradient_based_line_search" code="{N_mdm(lit,searchMethod_gradient_based_line_search)}" label="gradient_based_line_search"   />
                 <keyword  id="trust_region1" name="trust_region" code="{N_mdm(lit,searchMethod_trust_region)}" label="trust_region"   />
                 <keyword  id="tr_pds" name="tr_pds" code="{N_mdm(lit,searchMethod_tr_pds)}" label="tr_pds"   />
               </oneOf>
             </keyword>
             <keyword  id="merit_function1" name="merit_function" code="{0}" label="merit_function"  minOccurs="0" default="argaez_tapia" >
               <oneOf label="Merit Function">
                 <keyword  id="el_bakry" name="el_bakry" code="{N_mdm(type,meritFn_NormFmu)}" label="el_bakry"   />
                 <keyword  id="argaez_tapia" name="argaez_tapia" code="{N_mdm(type,meritFn_ArgaezTapia)}" label="argaez_tapia"   />
                 <keyword  id="van_shanno" name="van_shanno" code="{N_mdm(type,meritFn_VanShanno)}" label="van_shanno"   />
               </oneOf>
             </keyword>
             <keyword  id="steplength_to_boundary" name="steplength_to_boundary" code="{N_mdm(Real,stepLenToBoundary)}" label="steplength_to_boundary"  minOccurs="0" default="Merit function dependent: 0.8 (el_bakry), 0.99995 (argaez_tapia), 0.95 (van_shanno)" >
               <param type="REAL" />
             </keyword>
             <keyword  id="centering_parameter" name="centering_parameter" code="{N_mdm(Real,centeringParam)}" label="centering_parameter"  minOccurs="0" default="Merit function dependent: 0.2 (el_bakry), 0.2 (argaez_tapia), 0.1 (van_shanno)" >
               <param type="REAL" />
             </keyword>
	     ' >

    <!ENTITY method_optpp_grad_based_opts '
             <keyword  id="max_step" name="max_step" code="{N_mdm(Real,maxStep)}" label="max_step"  minOccurs="0" default="1000." >
               <param type="REAL" />
             </keyword>
             <keyword  id="gradient_tolerance" name="gradient_tolerance" code="{N_mdm(Real,gradientTolerance)}" label="gradient_tolerance"  minOccurs="0" default="1.e-4" >
               <param type="REAL" />
             </keyword>
             &method_max_iterations;
             &method_convergence_tolerance;
             &default_speculative;
             &method_max_function_evaluations;
             &default_scaling;
	     &method_optional_model_pointer;
	     ' >

    <!ENTITY method_ga_mutation_scale '
             <keyword  id="mutation_scale" name="mutation_scale" code="{N_mdm(Real01,mutationScale)}" label="mutation_scale"  minOccurs="0" default="0.15" >
               <param type="REAL" />
             </keyword>
	     ' >

    <!ENTITY method_jega_common_opts '
             <keyword  id="population_size" name="population_size" code="{N_mdm(int,populationSize)}" label="population_size"  minOccurs="0" default="50" >
               <param type="INTEGER" constraint=">= 0" />
             </keyword>
             <keyword  id="log_file" name="log_file" code="{N_mdm(str,logFile)}" label="log_file"  minOccurs="0" default="JEGAGlobal.log" >
               <param type="OUTPUT_FILE" />
             </keyword>
             <keyword  id="print_each_pop" name="print_each_pop" code="{N_mdm(true,printPopFlag)}" label="print_each_pop"  minOccurs="0" default="No printing" />
             <keyword  id="initialization_type" name="initialization_type" code="{0}" label="initialization_type"  minOccurs="0" default="unique_random" >
               <oneOf label="Initialization Type">
		 <keyword  id="simple_random" name="simple_random" code="{N_mdm(lit,initializationType_random)}" label="simple_random"   />
		 <keyword  id="unique_random" name="unique_random" code="{N_mdm(lit,initializationType_unique_random)}" label="unique_random"   />
		 <keyword  id="flat_file" name="flat_file" code="{N_mdm(slit2,TYPE_DATA_initializationType_flat_file)}" label="flat_file"   >
                   <!-- store init type AND incoming STRING -->
                   <param type="STRING" />
		 </keyword>
               </oneOf>
             </keyword>
             <keyword  id="crossover_type" name="crossover_type" code="{0}" label="crossover_type"  minOccurs="0" default="shuffle_random">
               <oneOf label="Crossover Type">
		 <keyword  id="multi_point_binary" name="multi_point_binary" code="{N_mdm(ilit2p,TYPE_DATA_crossoverType_multi_point_binary)}" label="multi_point_binary"   >
                   <param type="INTEGER" />
		 </keyword>
		 <keyword  id="multi_point_parameterized_binary" name="multi_point_parameterized_binary" code="{N_mdm(ilit2p,TYPE_DATA_crossoverType_multi_point_parameterized_binary)}" label="multi_point_parameterized_binary"   >
                   <param type="INTEGER" />
		 </keyword>
		 <keyword  id="multi_point_real" name="multi_point_real" code="{N_mdm(ilit2p,TYPE_DATA_crossoverType_multi_point_real)}" label="multi_point_real"   >
                   <param type="INTEGER" />
		 </keyword>
		 <keyword  id="shuffle_random" name="shuffle_random" code="{N_mdm(litc,TYPE_DATA_crossoverType_shuffle_random)}" label="shuffle_random"  >
                   <keyword  id="num_parents" name="num_parents" code="{N_mdm(sizet,numParents)}" label="num_parents"  minOccurs="0" default="2" >
                     <!-- should the min be 2? -->
                     <param type="INTEGER" constraint="> 0" />
                   </keyword>
                   <keyword  id="num_offspring" name="num_offspring" code="{N_mdm(sizet,numOffspring)}" label="num_offspring"  minOccurs="0" default="2" >
                     <param type="INTEGER" constraint="> 0" />
                   </keyword>
		 </keyword>
               </oneOf>
               <keyword  id="crossover_rate" name="crossover_rate" code="{N_mdm(litz,TYPE_DATA_crossoverType_null_crossover)}" label="crossover_rate"  minOccurs="0" default="0.8" >
		 <param type="REAL" />
               </keyword>
             </keyword>
             <keyword  id="mutation_type" name="mutation_type" code="{0}" label="mutation_type"  minOccurs="0" default="replace_uniform" >
               <oneOf label="Mutation Type">
		 <keyword  id="bit_random" name="bit_random" code="{N_mdm(lit,mutationType_bit_random)}" label="bit_random"   />
		 <keyword  id="replace_uniform" name="replace_uniform" code="{N_mdm(lit,mutationType_replace_uniform)}" label="replace_uniform"   />
                 <keyword  id="offset_normal" name="offset_normal" code="{N_mdm(litc,TYPE_DATA_mutationType_offset_normal)}" label="offset_normal"   >
		   &method_ga_mutation_scale;
		 </keyword>
                 <keyword  id="offset_cauchy" name="offset_cauchy" code="{N_mdm(litc,TYPE_DATA_mutationType_offset_cauchy)}" label="offset_cauchy"   >
		   &method_ga_mutation_scale;
		 </keyword>
                 <keyword  id="offset_uniform" name="offset_uniform" code="{N_mdm(litc,TYPE_DATA_mutationType_offset_uniform)}" label="offset_uniform"   >
		   &method_ga_mutation_scale;
		 </keyword>
               </oneOf>
               <keyword  id="mutation_rate" name="mutation_rate" code="{N_mdm(litz,TYPE_DATA_mutationType_null_mutation)}" label="mutation_rate"  minOccurs="0" default="0.08" >
		 <param type="REAL" />
               </keyword>
             </keyword>
             <keyword  id="seed3" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
               <param type="INTEGER" constraint="> 0" />
             </keyword>
             &method_convergence_tolerance;
	     &method_optional_model_pointer;
	     ' >

    <!ENTITY coliny_mutation_scale_range '
             <keyword  id="mutation_scale1" name="mutation_scale" code="{N_mdm(Real,mutationScale)}" label="mutation_scale"  minOccurs="0" default="0.1" >
               <param type="REAL" />
             </keyword>
             <keyword  id="mutation_range" name="mutation_range" code="{N_mdm(int,mutationRange)}" label="mutation_range"  minOccurs="0" default="1" >
               <param type="INTEGER" />
             </keyword>
	     ' >

    <!-- Options shared by all coliny solvers (depends on previous ENTITYs) -->
    <!ENTITY coliny_common_opts '
	     <keyword  id="solution_target1" name="solution_target" code="{N_mdm(Real,solnTarget)}" label="solution_target"  minOccurs="0" default="-DBL_MAX">
               <alias name="solution_accuracy"/>
               <param type="REAL" />
	     </keyword>
	     <keyword  id="seed4" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
               <param type="INTEGER" constraint="> 0" />
	     </keyword>
	     <keyword  id="show_misc_options" name="show_misc_options" code="{N_mdm(true,showMiscOptions)}" label="show_misc_options"  minOccurs="0" default="no dump of specification options"  complexity="1"/>
	     <keyword  id="misc_options" name="misc_options" code="{N_mdm(strL,miscOptions)}" label="misc_options"  minOccurs="0" default="no misc options" complexity="1" >
               <param type="STRINGLIST" />
	     </keyword>
	     &method_max_iterations;
	     &method_convergence_tolerance;
	     &method_max_function_evaluations;
	     &default_scaling;
	     ' >

    <!ENTITY method_synchronization '
             <keyword  id="synchronization" name="synchronization" code="{0}" label="Evaluation synchronization"  minOccurs="0" default="method specific" >
               <oneOf label="Synchronization">
                 <keyword  id="blocking" name="blocking" code="{N_mdm(type,evalSynchronize_BLOCKING_SYNCHRONIZATION)}" label="blocking"   />
                 <keyword  id="nonblocking" name="nonblocking" code="{N_mdm(type,evalSynchronize_NONBLOCKING_SYNCHRONIZATION)}" label="nonblocking"   />
               </oneOf>
             </keyword>
	     ' >

    <!ENTITY method_gp_alternatives_no_export '
	     <keyword  id="gaussian_process2" name="gaussian_process" code="{0}" label="gaussian_process"  minOccurs="0" default="Surfpack Gaussian process" >
	       <alias name="kriging"/>
	       <oneOf label="GP Implementation">
		 <keyword  id="surfpack2" name="surfpack" code="{N_mdm(type,emulatorType_KRIGING_EMULATOR)}" label="surfpack"   >
                 </keyword>
		 <keyword  id="dakota2" name="dakota" code="{N_mdm(type,emulatorType_GP_EMULATOR)}" label="dakota"   />
		 <keyword  id="experimental2" name="experimental" code="{N_mdm(type,emulatorType_EXPGP_EMULATOR)}" label="surrogates"   >
		   <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		     <param type="INPUT_FILE" />
		   </keyword>
                 </keyword>
	       </oneOf>
	     </keyword>
             ' >

    <!ENTITY method_gp_alternatives_with_export '
	     <keyword  id="gaussian_process2" name="gaussian_process" code="{0}" label="gaussian_process"  minOccurs="0" default="Surfpack Gaussian process" >
	       <alias name="kriging"/>
	       <oneOf label="GP Implementation">
		 <keyword  id="surfpack2" name="surfpack" code="{N_mdm(type,emulatorType_KRIGING_EMULATOR)}" label="surfpack"   >
                 &method_export_model;
                 </keyword>
		 <keyword  id="dakota2" name="dakota" code="{N_mdm(type,emulatorType_GP_EMULATOR)}" label="dakota"   />
		 <keyword  id="experimental2" name="experimental" code="{N_mdm(type,emulatorType_EXPGP_EMULATOR)}" label="surrogates"   >
                 &method_export_model;
		   <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		     <param type="INPUT_FILE" />
		   </keyword>
                 </keyword>
	       </oneOf>
	     </keyword>
             ' >

    <!ENTITY distribution_cumul_compl '
	     <keyword  id="distribution" name="distribution" code="{0}" label="distribution"  minOccurs="0" default="cumulative (CDF)" >
	       <oneOf label="Distribution Type (CDF/CCDF)">
		 <keyword  id="cumulative" name="cumulative" code="{N_mdm(type,distributionType_CUMULATIVE)}" label="cumulative"   />
		 <keyword  id="complementary" name="complementary" code="{N_mdm(type,distributionType_COMPLEMENTARY)}" label="complementary"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY probability_levels '
	     <keyword  id="probability_levels" name="probability_levels" code="{N_mdm(resplevs01,probabilityLevels)}" label="probability_levels"  minOccurs="0" default="No CDF/CCDF response levels to compute" >
	       <param type="REALLIST" />
	       <keyword  id="num_probability_levels" name="num_probability_levels" code="{N_mdm(num_resplevs,probabilityLevels)}" label="num_probability_levels"  minOccurs="0" default="probability_levels evenly distributed among response functions" >
		 <param type="INTEGERLIST" />
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY gen_reliability_levels '
	     <keyword  id="gen_reliability_levels" name="gen_reliability_levels" code="{N_mdm(resplevs,genReliabilityLevels)}" label="gen_reliability_levels"  minOccurs="0" default="No CDF/CCDF response levels to compute" >
	       <param type="REALLIST" />
	       <keyword  id="num_gen_reliability_levels" name="num_gen_reliability_levels" code="{N_mdm(num_resplevs,genReliabilityLevels)}" label="num_gen_reliability_levels"  minOccurs="0" default="gen_reliability_levels evenly distributed among response functions" >
		 <param type="INTEGERLIST" />
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY reliability_levels '
	     <keyword  id="reliability_levels" name="reliability_levels" code="{N_mdm(resplevs,reliabilityLevels)}" label="reliability_levels"  minOccurs="0" default="No CDF/CCDF response levels to compute" >
	       <param type="REALLIST" />
	       <keyword  id="num_reliability_levels" name="num_reliability_levels" code="{N_mdm(num_resplevs,reliabilityLevels)}" label="num_reliability_levels"  minOccurs="0" default="reliability_levels evenly distributed among response functions" >
		 <param type="INTEGERLIST" />
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY method_system_reliability '
	     <keyword  id="system" name="system" code="{0}" label="system"  minOccurs="0" >
	       <oneOf label="System Reliability Mode">
		 <keyword  id="series" name="series" code="{N_mdm(type,responseLevelTargetReduce_SYSTEM_SERIES)}" label="series"   />
		 <keyword  id="parallel" name="parallel" code="{N_mdm(type,responseLevelTargetReduce_SYSTEM_PARALLEL)}" label="parallel"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY response_levels_compute_prob_rel_gen '
	     <keyword  id="response_levels" name="response_levels" code="{N_mdm(resplevs,responseLevels)}" label="response_levels"  minOccurs="0" default="No CDF/CCDF probabilities/reliabilities to compute" >
	       <param type="REALLIST" />
	       <keyword  id="num_response_levels" name="num_response_levels" code="{N_mdm(num_resplevs,responseLevels)}" label="num_response_levels"  minOccurs="0" default="response_levels evenly distributed among response functions" >
		 <param type="INTEGERLIST" />
	       </keyword>
	       <keyword  id="compute" name="compute" code="{0}" label="compute"  minOccurs="0" default="probabilities" >
		 <oneOf label="Statistics to Compute">
		   <keyword  id="probabilities" name="probabilities" code="{N_mdm(type,responseLevelTarget_PROBABILITIES)}" label="probabilities"   />
		   <keyword  id="reliabilities" name="reliabilities" code="{N_mdm(type,responseLevelTarget_RELIABILITIES)}" label="reliabilities"   />
		   <keyword  id="gen_reliabilities" name="gen_reliabilities" code="{N_mdm(type,responseLevelTarget_GEN_RELIABILITIES)}" label="gen_reliabilities"   />
		 </oneOf>
		 &method_system_reliability;
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY response_levels_compute_prob_gen '
	     <keyword  id="response_levels" name="response_levels" code="{N_mdm(resplevs,responseLevels)}" label="response_levels"  minOccurs="0" default="No CDF/CCDF probabilities/reliabilities to compute" >
	       <param type="REALLIST" />
	       <keyword  id="num_response_levels" name="num_response_levels" code="{N_mdm(num_resplevs,responseLevels)}" label="num_response_levels"  minOccurs="0" default="response_levels evenly distributed among response functions" >
		 <param type="INTEGERLIST" />
	       </keyword>
	       <keyword  id="compute" name="compute" code="{0}" label="compute"  minOccurs="0" default="probabilities" >
		 <oneOf label="Statistics to Compute">
		   <keyword  id="probabilities" name="probabilities" code="{N_mdm(type,responseLevelTarget_PROBABILITIES)}" label="probabilities"   />
		   <keyword  id="gen_reliabilities" name="gen_reliabilities" code="{N_mdm(type,responseLevelTarget_GEN_RELIABILITIES)}" label="gen_reliabilities"   />
		 </oneOf>
		 &method_system_reliability;
	       </keyword>
	     </keyword>
	     ' >

    <!ENTITY level_mappings '
	     &response_levels_compute_prob_rel_gen;
	     &probability_levels;
	     &reliability_levels;
	     &gen_reliability_levels;
	     &distribution_cumul_compl;
	     ' >

    <!ENTITY level_mappings_no_rel '
	     &response_levels_compute_prob_gen;
	     &probability_levels;
	     &gen_reliability_levels;
	     &distribution_cumul_compl;
	     ' >

    <!ENTITY rng_options '
	     <keyword  id="rng" name="rng" code="{0}" label="rng"  minOccurs="0" default="Mersenne twister ( mt19937 )" >
	       <oneOf label="RNG Algorithm">
		 <keyword  id="mt19937" name="mt19937" code="{N_mdm(lit,rngName_mt19937)}" label="mt19937"   />
		 <keyword  id="rnum2" name="rnum2" code="{N_mdm(lit,rngName_rnum2)}" label="rnum2"   />
	       </oneOf>
	     </keyword>
	     ' >

    <!ENTITY method_iterator_server_scheduling '
	     <keyword  id="iterator_servers" name="iterator_servers" code="{N_mdm(int,iteratorServers)}" label="iterator_servers"  minOccurs="0" >
               <param type="INTEGER" constraint="> 0" />
	     </keyword>
	     <keyword  id="iterator_scheduling" name="iterator_scheduling" code="{0}" label="iterator_scheduling"  minOccurs="0" >
               <oneOf label="Scheduling Mode">
		 <keyword  id="master" name="master" code="{N_mdm(type,iteratorScheduling_MASTER_SCHEDULING)}" label="master"   />
		 <keyword  id="peer" name="peer" code="{N_mdm(type,iteratorScheduling_PEER_SCHEDULING)}" label="peer"   />
		 <!-- #	    | ( peer {0}
		      #	      	dynamic  {N_mdm(type,iteratorScheduling_PEER_DYNAMIC_SCHEDULING)}
		      #	      	| static {N_mdm(type,iteratorScheduling_PEER_STATIC_SCHEDULING)} )
		   -->
               </oneOf>
	     </keyword>
	     <keyword  id="processors_per_iterator" name="processors_per_iterator" code="{N_mdm(int,procsPerIterator)}" label="processors_per_iterator"  minOccurs="0" >
               <param type="INTEGER" constraint="> 0" />
	     </keyword>
	     ' >

    <!ENTITY method_optional_model_pointer '
	     <keyword  id="model_pointer" name="model_pointer" code="{N_mdm(str,modelPointer)}" label="Identification of model by pointer"  minOccurs="0"
		       default="method use of last model parsed (or use of default model if none parsed)" >
	       <param type="STRING" in_taglist="model" />
	     </keyword>
	     ' >

    <!ENTITY numerical_gradient_options '
	     <!-- # formerly required for dakota | vendor -->
	     <keyword  id="method_source" name="method_source" code="{0}" label="method_source"  minOccurs="0" default="dakota" />
	     <optional>
               <oneOf label="Gradient Source">
		 <keyword  id="dakota7" name="dakota" code="{N_rem(lit,methodSource_dakota)}" label="dakota"  default="relative" >
		   <keyword  id="ignore_bounds" name="ignore_bounds" code="{N_rem(true,ignoreBounds)}" label="ignore_bounds"  minOccurs="0" default="bounds respected" />
		   <optional>
		     <oneOf label="Step Scaling" >
                       <keyword  id="relative" name="relative" code="{N_rem(lit,fdGradStepType_relative)}" label="relative"   />
                       <keyword  id="absolute" name="absolute" code="{N_rem(lit,fdGradStepType_absolute)}" label="absolute"   default="relative" />
                       <keyword  id="bounds" name="bounds" code="{N_rem(lit,fdGradStepType_bounds)}" label="bounds"   />
		     </oneOf>
		   </optional>
		 </keyword>
		 <keyword  id="vendor" name="vendor" code="{N_rem(lit,methodSource_vendor)}" label="vendor"   />
               </oneOf>
	     </optional>
	     <!-- # formerly required for forward or central -->
	     <keyword  id="interval_type" name="interval_type" code="{0}" label="interval_type"  minOccurs="0" default="forward" />
	     <optional>
               <oneOf label="Finite Difference Type">
		 <keyword  id="forward" name="forward" code="{N_rem(lit,intervalType_forward)}" label="forward"   default="forward" />
		 <keyword  id="central" name="central" code="{N_rem(lit,intervalType_central)}" label="central"   />
               </oneOf>
	     </optional>
	     <keyword  id="fd_step_size" name="fd_step_size" code="{N_rem(RealL,fdGradStepSize)}" label="fd_step_size"  minOccurs="0" default="0.001" >
               <alias name="fd_gradient_step_size"/>
               <param type="REALLIST" />
	     </keyword>
	     ' >
    <!ENTITY response_gradients '
	     <oneOf label="Gradient Type">
               <keyword  id="no_gradients" name="no_gradients" code="{N_rem(lit,gradientType_none)}" label="no_gradients"   />
               <keyword  id="analytic_gradients" name="analytic_gradients" code="{N_rem(lit,gradientType_analytic)}" label="analytic_gradients"   />
               <keyword  id="mixed_gradients" name="mixed_gradients" code="{N_rem(lit,gradientType_mixed)}" label="Mixed gradients"  >
		 <keyword  id="id_numerical_gradients" name="id_numerical_gradients" code="{N_rem(intset,idNumericalGrads)}" label="Numerical derivatives function list"   >
		   <param type="INTEGERLIST" />
		 </keyword>
		 <keyword  id="id_analytic_gradients" name="id_analytic_gradients" code="{N_rem(intset,idAnalyticGrads)}" label="Analytic derivatives function list"   >
		   <param type="INTEGERLIST" />
		 </keyword>
		 &numerical_gradient_options;
               </keyword>
               <keyword  id="numerical_gradients" name="numerical_gradients" code="{N_rem(lit,gradientType_numerical)}" label="Numerical gradients" >
		 &numerical_gradient_options;
	       </keyword>
	     </oneOf>
	     ' >
    <!ENTITY response_hessians '
	     <oneOf label="Hessian Type">
               <keyword  id="no_hessians" name="no_hessians" code="{N_rem(lit,hessianType_none)}" label="no_hessians"   />
               <keyword  id="numerical_hessians" name="numerical_hessians" code="{N_rem(lit,hessianType_numerical)}" label="Numerical Hessians"  >
		 <keyword  id="fd_step_size1" name="fd_step_size" code="{N_rem(RealL,fdHessStepSize)}" label="Finite difference step size"  minOccurs="0" default="0.001 (forward), 0.002 (central)" >
		   <alias name="fd_hessian_step_size"/>
		   <param type="REALLIST" />
		 </keyword>
		 <optional>
		   <oneOf label="Step Scaling" >
		     <keyword  id="relative1" name="relative" code="{N_rem(lit,fdHessStepType_relative)}" label="relative"   />
		     <keyword  id="absolute1" name="absolute" code="{N_rem(lit,fdHessStepType_absolute)}" label="absolute"   default="relative" />
		     <keyword  id="bounds1" name="bounds" code="{N_rem(lit,fdHessStepType_bounds)}" label="bounds"   />
		   </oneOf>
		 </optional>
		 <optional>
		   <oneOf label="Finite Difference Type">
		     <keyword  id="forward1" name="forward" code="{N_rem(false,centralHess)}" label="forward"   default="forward" />
		     <keyword  id="central1" name="central" code="{N_rem(true,centralHess)}" label="central"   />
		   </oneOf>
		 </optional>
               </keyword>
               <keyword  id="quasi_hessians" name="quasi_hessians" code="{N_rem(lit,hessianType_quasi)}" label="Quasi Hessians"  >
		 <oneOf label="Quasi-Hessian Approximation">
		   <keyword  id="bfgs1" name="bfgs" code="{N_rem(lit,quasiHessianType_bfgs)}" label="bfgs"  >
		     <keyword  id="damped" name="damped" code="{N_rem(lit,quasiHessianType_damped_bfgs)}" label="Numerical safeguarding of BFGS update"  minOccurs="0" default="undamped BFGS" />
		   </keyword>
		   <keyword  id="sr1" name="sr1" code="{N_rem(lit,quasiHessianType_sr1)}" label="sr1"   />
		 </oneOf>
               </keyword>
               <keyword  id="analytic_hessians" name="analytic_hessians" code="{N_rem(lit,hessianType_analytic)}" label="analytic_hessians"   />
               <keyword  id="mixed_hessians" name="mixed_hessians" code="{N_rem(lit,hessianType_mixed)}" label="Mixed Hessians"  >
		 <keyword  id="id_numerical_hessians" name="id_numerical_hessians" code="{N_rem(intset,idNumericalHessians)}" label="Numerical Hessians function list"  minOccurs="0" >
		   <param type="INTEGERLIST" />
		   <keyword  id="fd_step_size2" name="fd_step_size" code="{N_rem(RealL,fdHessStepSize)}" label="Finite difference step size"  minOccurs="0" default="0.001 (forward), 0.002 (central)" >
		     <alias name="fd_hessian_step_size"/>
		     <param type="REALLIST" />
		   </keyword>
		 </keyword>
		 <optional>
		   <oneOf label="Step Scaling">
		     <keyword  id="relative2" name="relative" code="{N_rem(lit,fdHessStepType_relative)}" label="relative"   />
		     <keyword  id="absolute2" name="absolute" code="{N_rem(lit,fdHessStepType_absolute)}" label="absolute"   default="relative" />
		     <keyword  id="bounds2" name="bounds" code="{N_rem(lit,fdHessStepType_bounds)}" label="bounds"   />
		   </oneOf>
		 </optional>
		 <optional>
		   <oneOf label="Finite Difference Type">
		     <keyword  id="forward2" name="forward" code="{N_rem(false,centralHess)}" label="forward"   default="forward" />
		     <keyword  id="central2" name="central" code="{N_rem(true,centralHess)}" label="central"   />
		   </oneOf>
		 </optional>
		 <keyword  id="id_quasi_hessians" name="id_quasi_hessians" code="{N_rem(intset,idQuasiHessians)}" label="Quasi Hessians function list"  minOccurs="0" >
		   <param type="INTEGERLIST" />
		   <oneOf label="Quasi-Hessian Approximation">
		     <keyword  id="bfgs2" name="bfgs" code="{N_rem(lit,quasiHessianType_bfgs)}" label="bfgs"  >
                       <keyword  id="damped1" name="damped" code="{N_rem(lit,quasiHessianType_damped_bfgs)}" label="Numerical safeguarding of BFGS update"  minOccurs="0" default="undamped BFGS" />
		     </keyword>
		     <keyword  id="sr11" name="sr1" code="{N_rem(lit,quasiHessianType_sr1)}" label="sr1"   />
		   </oneOf>
		 </keyword>
		 <keyword  id="id_analytic_hessians" name="id_analytic_hessians" code="{N_rem(intset,idAnalyticHessians)}" label="Analytic Hessians function list"  minOccurs="0" >
		   <param type="INTEGERLIST" />
		 </keyword>
               </keyword>
	     </oneOf>
	     ' >

    ]>

<document xmlns='http://www.sandia.gov/dakota/1.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
                  xsi:schemaLocation='http://www.sandia.gov/dakota/1.0 dakota.xsd'>
  <input>
    <!-- **** TOPLEVEL *** -->
    <keyword id="environment" name="environment" minOccurs="0" maxOccurs="1" code="{NIDRProblemDescDB::env_start}" label="Environment"  default="no environment" >
      <group label="Input/Output">
        <keyword  id="tabular_data" name="tabular_data" code="{N_stm(true,tabularDataFlag)}" label="Enable Tabular Data"  minOccurs="0" default="no tabular data output" complexity="0">
          <alias name="tabular_graphics_data"/>
          <keyword  id="tabular_data_file" name="tabular_data_file" code="{N_stm(str,tabularDataFile)}" label="Tabular Data File"  minOccurs="0" default="dakota_tabular.dat">
            <alias name="tabular_graphics_file"/>
            <param type="OUTPUT_FILE" />
          </keyword>
          <optional>
            <oneOf label="Tabular Data Format">
              <keyword id="custom_annotated" name="custom_annotated" code="{N_stm(utype,tabularFormat_TABULAR_NONE)}" label="Custom Annotated"  default="annotated format" >
		<keyword id="header" name="header" code="{N_stm(augment_utype,tabularFormat_TABULAR_HEADER)}" label="Header Row"  minOccurs="0" default="no header" />
		<keyword id="eval_id" name="eval_id" code="{N_stm(augment_utype,tabularFormat_TABULAR_EVAL_ID)}" label="Eval ID Column"  minOccurs="0" default="no eval_id column" />
		<keyword id="interface_id" name="interface_id" code="{N_stm(augment_utype,tabularFormat_TABULAR_IFACE_ID)}" label="Interface ID Column"  minOccurs="0" default="no interface_id column" />
	      </keyword>
              <keyword  id="annotated" name="annotated" code="{N_stm(utype,tabularFormat_TABULAR_ANNOTATED)}" label="Annotated"  default="annotated format" />
              <keyword id="freeform" name="freeform" code="{N_stm(utype,tabularFormat_TABULAR_NONE)}" label="Freeform"   default="annotated format" />
            </oneOf>
          </optional>
        </keyword>
      <keyword  id="output_file" name="output_file" code="{N_stm(str,outputFile)}" label="Output File"  minOccurs="0" default="output to console, not file" complexity="0">
        <param type="OUTPUT_FILE" />
      </keyword>
      <keyword  id="error_file" name="error_file" code="{N_stm(str,errorFile)}" label="Error File"  minOccurs="0" default="errors to console, not file" complexity="0">
        <param type="OUTPUT_FILE" />
      </keyword>
      <keyword  id="read_restart" name="read_restart" code="{N_stm(str,readRestart)}" label="Read Restart File"  minOccurs="0" default="no restart read" complexity="0">
        <param type="STRING" />
        <keyword  id="stop_restart" name="stop_restart" code="{N_stm(int,stopRestart)}" label="Restart Stop Value"  minOccurs="0" default="read all records" >
          <param type="INTEGER" constraint=">= 0" />
        </keyword>
      </keyword>
        <keyword  id="write_restart" name="write_restart" code="{N_stm(str,writeRestart)}" label="Write Restart File"  minOccurs="0" default="dakota.rst" complexity="1">
        <param type="STRING" />
      </keyword>
        <keyword  id="output_precision" name="output_precision" code="{N_stm(int,outputPrecision)}" label="Numeric Output Precision Value"  minOccurs="0" default="10" complexity="1">
          <param type="INTEGER" constraint=">= 0" />
        </keyword>
        <keyword  id="results_output" name="results_output" code="{N_stm(true,resultsOutputFlag)}" label="Enable Results Output"  minOccurs="0" default="no results output" complexity="1">
          <keyword  id="results_output_file" name="results_output_file" code="{N_stm(str,resultsOutputFile)}" label="Results Output File"  minOccurs="0" default="dakota_results" >
            <param type="OUTPUT_FILE" />
          </keyword>
          <keyword  id="text" name="text" code="{N_stm(augment_utype,resultsOutputFormat_RESULTS_OUTPUT_TEXT)}" label="text"  minOccurs="0" default="text output" />
	  <keyword  id="hdf5" name="hdf5" code="{N_stm(augment_utype,resultsOutputFormat_RESULTS_OUTPUT_HDF5)}" label="hdf5"  minOccurs="0" default="no HDF5 output">

               <keyword id="model_selection" name="model_selection" code="{0}" label="Model Selection" minOccurs="0" maxOccurs="1" group="Model Evaluation Storage Selection" complexity="1">
               <oneOf label="Model Evaluation Storage Selection" >
		       <keyword  id="top_method" name="top_method" code="{N_stm(utype,modelEvalsSelection_MODEL_EVAL_STORE_TOP_METHOD)}" label="top_method"  default="top_method" />
		       <keyword  id="none" name="none" code="{N_stm(utype,modelEvalsSelection_MODEL_EVAL_STORE_NONE)}" label="none"  default="top_method" />
       		       <keyword  id="all_methods" name="all_methods" code="{N_stm(utype,modelEvalsSelection_MODEL_EVAL_STORE_ALL_METHODS)}" label="all_methods"  default="top_method" />
       		       <keyword  id="all" name="all" code="{N_stm(utype,modelEvalsSelection_MODEL_EVAL_STORE_ALL)}" label="all"  default="top_method" />
	       </oneOf>
               </keyword>

               <keyword id="interface_selection" name="interface_selection" code="{0}" label="Interface Selection" minOccurs="0" maxOccurs="1" group="Interface Evaluation Storage Selection" complexity="1">
               <oneOf label="Interface Evaluation Storage Selection" >
		       <keyword  id="none" name="none" code="{N_stm(utype,interfEvalsSelection_INTERF_EVAL_STORE_NONE)}" label="none"  default="simulation" />
		       <keyword  id="simulation" name="simulation" code="{N_stm(utype,interfEvalsSelection_INTERF_EVAL_STORE_SIMULATION)}" label="simulation"  default="simulation" />
		       <keyword  id="all" name="all" code="{N_stm(utype,interfEvalsSelection_INTERF_EVAL_STORE_ALL)}" label="all"  default="top_simulation" />
	       </oneOf>
	       </keyword>

          </keyword>
        </keyword>
        <keyword  id="graphics" name="graphics" code="{N_stm(true,graphicsFlag)}" label="Enable Graphics Window"  minOccurs="0" default="graphics off" complexity="1"/>
      </group>
      <group label="Run Modes">
        <keyword  id="check" name="check" code="{N_stm(true,checkFlag)}" label="Enable Check Mode"  minOccurs="0" default="no check; proceed to run" complexity="0"/>
        <keyword  id="pre_run" name="pre_run" code="{N_stm(true,preRunFlag)}" label="Enable Pre-Run Mode"  minOccurs="0" default="pre-run, run, post-run all executed" complexity="0">
        <keyword  id="input" name="input" code="{N_stm(str,preRunInput)}" label="Input File"  minOccurs="0" default="no pre-run specific input read">
          <param type="STRING" />
        </keyword>
        <keyword  id="output" name="output" code="{N_stm(str,preRunOutput)}" label="Output File"  minOccurs="0" default="no pre-run specific output written" >
          <param type="STRING" />
          <optional>
            <oneOf label="Tabular Format">
	      <keyword id="custom_annotated" name="custom_annotated" code="{N_stm(utype,preRunOutputFormat_TABULAR_NONE)}" label="Custom Annotated"  default="annotated format" >
		<keyword  id="header" name="header" code="{N_stm(augment_utype,preRunOutputFormat_TABULAR_HEADER)}" label="Header Row"  minOccurs="0" default="no header" />
		<keyword  id="eval_id" name="eval_id" code="{N_stm(augment_utype,preRunOutputFormat_TABULAR_EVAL_ID)}" label="Eval ID Column"  minOccurs="0" default="no eval_id column" />
		<keyword  id="interface_id" name="interface_id" code="{N_stm(augment_utype,preRunOutputFormat_TABULAR_IFACE_ID)}" label="Interface ID Column"  minOccurs="0" default="no interface_id column" />
	      </keyword>
              <keyword  id="annotated" name="annotated" code="{N_stm(utype,preRunOutputFormat_TABULAR_ANNOTATED)}" label="Annotated"  default="annotated format" />
              <keyword  id="freeform" name="freeform" code="{N_stm(utype,preRunOutputFormat_TABULAR_NONE)}" label="Freeform"  default="annotated format" />
            </oneOf>
          </optional>
        </keyword>
      </keyword>
        <keyword  id="run" name="run" code="{N_stm(true,runFlag)}" label="Enable Run Mode"  minOccurs="0" default="pre-run, run, post-run all executed" complexity="0">
        <keyword  id="input1" name="input" code="{N_stm(str,runInput)}" label="Input File"  minOccurs="0" default="no run specific input read" >
          <param type="STRING" />
        </keyword>
        <keyword  id="output1" name="output" code="{N_stm(str,runOutput)}" label="Output File"  minOccurs="0" default="no run specific output written" >
          <param type="STRING" />
        </keyword>
      </keyword>
        <keyword  id="post_run" name="post_run" code="{N_stm(true,postRunFlag)}" label="Enable Post-Run Mode"  minOccurs="0" default="pre-run, run, post-run all executed" complexity="0">
        <keyword  id="input2" name="input" code="{N_stm(str,postRunInput)}" label="Input File"  minOccurs="0" default="no post-run specific input read" >
          <param type="STRING" />
          <optional>
            <oneOf label="Tabular Format">
	      <keyword  id="custom_annotated" name="custom_annotated" code="{N_stm(utype,postRunInputFormat_TABULAR_NONE)}" label="Custom Annotated"  default="annotated format" >
		<keyword  id="header" name="header" code="{N_stm(augment_utype,postRunInputFormat_TABULAR_HEADER)}" label="Header Row"  minOccurs="0" default="no header" />
		<keyword  id="eval_id" name="eval_id" code="{N_stm(augment_utype,postRunInputFormat_TABULAR_EVAL_ID)}" label="Eval ID Column"  minOccurs="0" default="no eval_id column" />
		<keyword  id="interface_id" name="interface_id" code="{N_stm(augment_utype,postRunInputFormat_TABULAR_IFACE_ID)}" label="Interface ID Column"  minOccurs="0" default="no interface_id column" />
	      </keyword>
              <keyword  id="annotated" name="annotated" code="{N_stm(utype,postRunInputFormat_TABULAR_ANNOTATED)}" label="Annotated"  default="annotated format" />
              <keyword  id="freeform" name="freeform" code="{N_stm(utype,postRunInputFormat_TABULAR_NONE)}" label="Freeform"  default="annotated format" />
            </oneOf>
          </optional>
        </keyword>
        <keyword  id="output2" name="output" code="{N_stm(str,postRunOutput)}" label="Output File"  minOccurs="0" default="no post-run specific output written" >
          <param type="STRING" />
        </keyword>
      </keyword>
      </group>
      <keyword  id="top_method_pointer" name="top_method_pointer" code="{N_stm(str,topMethodPointer)}" label="Method Pointer"  minOccurs="0" default="see discussion" complexity="0">
        <alias name="method_pointer"/>
        <param type="STRING" in_taglist="method" />
      </keyword>
    </keyword>

    <!-- **** TOPLEVEL *** -->
    <keyword id="method" name="method" maxOccurs="unbounded" code="{N_mdm3(start,0,stop)}" label="Method" >
      <keyword  id="id_method" name="id_method" code="{N_mdm(str,idMethod)}" label="Method set identifier"  minOccurs="0" default="strategy use of last method parsed" >
        <param type="STRING" taglist="method" />
      </keyword>
      <keyword  id="output3" name="output" code="{0}" label="Output verbosity"  minOccurs="0" default="normal" >
        <oneOf label="Output Level">
          <keyword  id="debug" name="debug" code="{N_mdm(type,methodOutput_DEBUG_OUTPUT)}" label="debug"   />
          <keyword  id="verbose" name="verbose" code="{N_mdm(type,methodOutput_VERBOSE_OUTPUT)}" label="verbose"   />
          <keyword  id="normal" name="normal" code="{N_mdm(type,methodOutput_NORMAL_OUTPUT)}" label="normal"   />
          <keyword  id="quiet" name="quiet" code="{N_mdm(type,methodOutput_QUIET_OUTPUT)}" label="quiet"   />
          <keyword  id="silent" name="silent" code="{N_mdm(type,methodOutput_SILENT_OUTPUT)}" label="silent"   />
        </oneOf>
      </keyword>
      <keyword  id="final_solutions" name="final_solutions" code="{N_mdm(sizet,numFinalSolutions)}" label="Final solutions"  minOccurs="0" default="1" >
        <param type="INTEGER" constraint=">= 0" />
      </keyword>

      <!-- Primary method selection alternation -->
      <oneOf label="Method (Iterative Algorithm)">

        <!-- Begin group for concurrent iterator spec: -->
        <keyword  id="hybrid" name="hybrid" code="{N_mdm(utype,methodName_HYBRID)}" label="Hybrid meta-iterator"  group="Optimization: Other" >
          <oneOf label="Hybrid Method Type">

            <keyword  id="sequential" name="sequential" code="{N_mdm(utype,subMethod_SUBMETHOD_SEQUENTIAL)}" label="Sequential hybrid"  >
              <alias name="uncoupled"/>
              <!-- #	      [ adaptive {N_mdm(lit,seqHybridType_adaptive)}
                   #	      	progress_threshold REAL {N_mdm(Real,hybridProgThresh)} ]
                -->
              <oneOf label="Sub-method Selection">
                <keyword  id="method_name_list" name="method_name_list" code="{N_mdm(strL,hybridMethodNames)}" label="List of method names"  >
                  <param type="STRINGLIST" />
                  <keyword  id="model_pointer_list" name="model_pointer_list" code="{N_mdm(strL,hybridModelPointers)}" label="List of model pointers"  minOccurs="0" >
                    <param type="STRINGLIST" />
                  </keyword>
                </keyword>
                <keyword  id="method_pointer_list" name="method_pointer_list" code="{N_mdm(strL,hybridMethodPointers)}" label="List of method pointers"   >
                  <param type="STRINGLIST" />
                </keyword>
              </oneOf>
	      &method_iterator_server_scheduling;
            </keyword>

            <keyword  id="embedded" name="embedded" code="{N_mdm(utype,subMethod_SUBMETHOD_EMBEDDED)}" label="Embedded hybrid"  >
              <alias name="coupled"/>
              <oneOf label="Global Sub-method Selection">
                <keyword  id="global_method_name" name="global_method_name" code="{N_mdm(str,hybridGlobalMethodName)}" label="Name of the global method"  >
                  <param type="STRING" />
                  <keyword  id="global_model_pointer" name="global_model_pointer" code="{N_mdm(str,hybridGlobalModelPointer)}" label="Pointer to the global model specification"  minOccurs="0" >
                    <param type="STRING" in_taglist="model" />
                  </keyword>
                </keyword>
                <keyword  id="global_method_pointer" name="global_method_pointer" code="{N_mdm(str,hybridGlobalMethodPointer)}" label="Pointer to the global method specification"   >
                  <param type="STRING" in_taglist="method" />
                </keyword>
              </oneOf>
              <oneOf label="Local Sub-method Selection">
                <keyword  id="local_method_name" name="local_method_name" code="{N_mdm(str,hybridLocalMethodName)}" label="Name of the local method"  >
                  <param type="STRING" />
                  <keyword  id="local_model_pointer" name="local_model_pointer" code="{N_mdm(str,hybridLocalModelPointer)}" label="Pointer to the local model specification"  minOccurs="0" >
                    <param type="STRING" in_taglist="model" />
                  </keyword>
                </keyword>
                <keyword  id="local_method_pointer" name="local_method_pointer" code="{N_mdm(str,hybridLocalMethodPointer)}" label="Pointer to the local method specification"   >
                  <param type="STRING" in_taglist="method" />
                </keyword>
              </oneOf>
              <keyword  id="local_search_probability" name="local_search_probability" code="{N_mdm(Real,hybridLSProb)}" label="Probability of executing local searches"  minOccurs="0" >
                <param type="REAL" />
              </keyword>
	      &method_iterator_server_scheduling;
            </keyword>

            <keyword  id="collaborative" name="collaborative" code="{N_mdm(utype,subMethod_SUBMETHOD_COLLABORATIVE)}" label="Collaborative hybrid"  >
              <!-- #	      abo {N_mdm(lit,hybridCollabType_abo)}
                   #	      | hops {N_mdm(lit,hybridCollabType_hops)}
                -->
              <oneOf label="Sub-method Selection">
                <keyword  id="method_name_list1" name="method_name_list" code="{N_mdm(strL,hybridMethodNames)}" label="List of method names"  >
                  <param type="STRINGLIST" />
                  <keyword  id="model_pointer_list1" name="model_pointer_list" code="{N_mdm(strL,hybridModelPointers)}" label="List of model pointers"  minOccurs="0" >
                    <param type="STRINGLIST" />
                  </keyword>
                </keyword>
                <keyword  id="method_pointer_list1" name="method_pointer_list" code="{N_mdm(strL,hybridMethodPointers)}" label="List of method pointers"   >
                  <param type="STRINGLIST" />
                </keyword>
              </oneOf>
	      &method_iterator_server_scheduling;
            </keyword>

          </oneOf>
        </keyword>

        <keyword  id="multi_start" name="multi_start" code="{N_mdm(utype,methodName_MULTI_START)}" label="Multi-start meta-iterator"  group="Optimization: Other" >
          <oneOf label="Sub-method Selection">
            <keyword  id="method_name" name="method_name" code="{N_mdm(str,subMethodName)}" label="Identification of a sub-method by name (no separate specification block)"  >
              <param type="STRING" />
              <keyword  id="model_pointer" name="model_pointer" code="{N_mdm(str,subModelPointer)}" label="Model pointer"  minOccurs="0" default="method use of last model parsed (or use of default model if none parsed)" >
                <param type="STRING" in_taglist="model" />
              </keyword>
            </keyword>
            <keyword  id="method_pointer" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="Identification of a sub-method by pointer to a separate specification block"   >
              <param type="STRING" in_taglist="method" />
            </keyword>
          </oneOf>
          <keyword  id="random_starts" name="random_starts" code="{N_mdm(int,concurrentRandomJobs)}" label="Number of random starting points"  minOccurs="0" >
            <param type="INTEGER" />
            <keyword  id="seed" name="seed" code="{N_mdm(int,randomSeed)}" label="Seed for random starting points"  minOccurs="0" default="system-generated (non-repeatable)" >
              <param type="INTEGER" />
            </keyword>
          </keyword>
          <keyword  id="starting_points" name="starting_points" code="{N_mdm(RealDL,concurrentParameterSets)}" label="List of user-specified starting points"  minOccurs="0" >
            <param type="REALLIST" />
          </keyword>
	  &method_iterator_server_scheduling;
        </keyword>

        <keyword  id="pareto_set" name="pareto_set" code="{N_mdm(utype,methodName_PARETO_SET)}" label="Pareto set minimization"  group="Optimization: Other" >
          <oneOf label="Sub-method Selection">
            <keyword  id="method_name1" name="method_name" code="{N_mdm(str,subMethodName)}" label="Identification of sub-iterator by name"  >
              <alias name="opt_method_name"/>
              <param type="STRING" />
              <keyword  id="model_pointer1" name="model_pointer" code="{N_mdm(str,subModelPointer)}" label="Identification of model by pointer"  minOccurs="0" default="method use of last model parsed (or use of default model if none parsed)" >
                <alias name="opt_model_pointer"/>
                <param type="STRING" in_taglist="model" />
              </keyword>
            </keyword>
            <keyword  id="method_pointer1" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="Identification of sub-iterator by pointer"   >
              <alias name="opt_method_pointer"/>
              <param type="STRING" in_taglist="method" />
            </keyword>
          </oneOf>
          <keyword  id="random_weight_sets" name="random_weight_sets" code="{N_mdm(int,concurrentRandomJobs)}" label="Number of random weighting sets"  minOccurs="0" >
            <param type="INTEGER" />
            <keyword  id="seed1" name="seed" code="{N_mdm(int,randomSeed)}" label="Seed for random weighting sets"  minOccurs="0" default="system-generated (non-repeatable)" >
              <param type="INTEGER" />
            </keyword>
          </keyword>
          <keyword  id="weight_sets" name="weight_sets" code="{N_mdm(RealDL,concurrentParameterSets)}" label="List of user-specified weighting sets"  minOccurs="0" >
            <alias name="multi_objective_weight_sets"/>
            <param type="REALLIST" />
          </keyword>
	  &method_iterator_server_scheduling;
        </keyword>

	<!--
	    # Note: branch_and_bound and surrogate_based_{local,global} are not meta-iterators and use a Model-based
	    # ctor chain. Therefore, they differ in their model_pointer spec from hybrid & concurrent meta-iterators
	    # (they require their own Model, not just a sub-model for the sub-method).
	-->
	<keyword  id="branch_and_bound" name="branch_and_bound" code="{N_mdm(utype,methodName_BRANCH_AND_BOUND)}" label="branch_and_bound"  group="Optimization: Other" >
          <oneOf label="Local Optimizer Selection">
            <keyword  id="method_pointer2" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="Identification of minimizer by pointer"  >
	      <param type="STRING" in_taglist="method" />
            </keyword>
            <keyword  id="method_name2" name="method_name" code="{N_mdm(str,subMethodName)}" label="Identification of minimizer by name"  >
              <param type="STRING" />
	      &method_optional_model_pointer;
            </keyword>
          </oneOf>
          &default_scaling;
        </keyword>
	<!--
            #	  [ num_samples_at_node INTEGER {N_mdm(int,branchBndNumSamplesNode)} ]
            #	  [ num_samples_at_root INTEGER {N_mdm(int,branchBndNumSamplesRoot)} ]
            #	)
	-->

	<!--
        <keyword  id="multilevel_multifidelity_opt" name="multilevel_multifidelity_opt" code="{N_mdm(utype,methodName_HIERARCH_SURROGATE_BASED_LOCAL)}" label="multilevel_multifidelity_opt" >
          <oneOf>
            <keyword  id="method_pointer2" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="Identification of minimizer by pointer"   >
              <alias name="approx_method_pointer"/>
              <param type="STRING" in_taglist="method" />
            </keyword>
            <keyword  id="method_name2" name="method_name" code="{N_mdm(str,subMethodName)}" label="Identification of minimizer by name"   >
              <alias name="approx_method_name"/>
              <param type="STRING" />
            </keyword>
          </oneOf>
          <keyword  id="model_pointer2" name="model_pointer" code="{N_mdm(str,modelPointer)}" label="Identification of model by pointer"   default="method use of last model parsed (or use of default model if none parsed)" >
            <alias name="approx_model_pointer"/>
            <param type="STRING" in_taglist="model" />
          </keyword>
          &method_max_iterations;
          &method_convergence_tolerance;
          &default_constraint_tolerance;
        </keyword>
	-->

	<!--
        <keyword  id="surrogate_based_local" name="surrogate_based_local" code="{N_mdm(utype,methodName_DATA_FIT_SURROGATE_BASED_LOCAL)}" label="surrogate_based_local"  group="Surrogate-based Methods" >
        </keyword>
	-->

        <keyword  id="surrogate_based_local" name="surrogate_based_local" code="{N_mdm(utype,methodName_SURROGATE_BASED_LOCAL)}" label="surrogate_based_local"  group="Surrogate-based Methods" >
          <oneOf label="Subproblem Optimizer Selection">
            <keyword  id="method_pointer3" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="Identification of minimizer by pointer"   >
              <alias name="approx_method_pointer"/>
              <param type="STRING" in_taglist="method" />
            </keyword>
            <keyword  id="method_name3" name="method_name" code="{N_mdm(str,subMethodName)}" label="Identification of minimizer by name"   >
              <alias name="approx_method_name"/>
              <param type="STRING" />
            </keyword>
          </oneOf>
          <keyword  id="model_pointer3" name="model_pointer" code="{N_mdm(str,modelPointer)}" label="Identification of model by pointer"   default="method use of last model parsed (or use of default model if none parsed)" >
            <alias name="approx_model_pointer"/>
            <param type="STRING" in_taglist="model" />
          </keyword>
          <keyword  id="soft_convergence_limit" name="soft_convergence_limit" code="{N_mdm(ushint,softConvLimit)}" label="Soft convergence limit for SBL iterations"  minOccurs="0" default="5" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="truth_surrogate_bypass" name="truth_surrogate_bypass" code="{N_mdm(true,surrBasedLocalLayerBypass)}" label="Flag for bypassing lower level surrogates in truth verifications"  minOccurs="0" default="no bypass" />
          <keyword  id="approx_subproblem" name="approx_subproblem" code="{0}" label="Approximate subproblem formulation"  minOccurs="0" default="original_primary original_constraints" >
            <oneOf label="Objective Formulation">
              <keyword  id="original_primary" name="original_primary" code="{N_mdm(type,surrBasedLocalSubProbObj_ORIGINAL_PRIMARY)}" label="original_primary"   />
              <keyword  id="single_objective" name="single_objective" code="{N_mdm(type,surrBasedLocalSubProbObj_SINGLE_OBJECTIVE)}" label="single_objective"   />
              <keyword  id="augmented_lagrangian_objective" name="augmented_lagrangian_objective" code="{N_mdm(type,surrBasedLocalSubProbObj_AUGMENTED_LAGRANGIAN_OBJECTIVE)}" label="augmented_lagrangian_objective"   />
              <keyword  id="lagrangian_objective" name="lagrangian_objective" code="{N_mdm(type,surrBasedLocalSubProbObj_LAGRANGIAN_OBJECTIVE)}" label="lagrangian_objective"   />
            </oneOf>
            <oneOf label="Constraint Formulation">
              <keyword  id="original_constraints" name="original_constraints" code="{N_mdm(type,surrBasedLocalSubProbCon_ORIGINAL_CONSTRAINTS)}" label="original_constraints"   />
              <keyword  id="linearized_constraints" name="linearized_constraints" code="{N_mdm(type,surrBasedLocalSubProbCon_LINEARIZED_CONSTRAINTS)}" label="linearized_constraints"   />
              <keyword  id="no_constraints" name="no_constraints" code="{N_mdm(type,surrBasedLocalSubProbCon_NO_CONSTRAINTS)}" label="no_constraints"   />
            </oneOf>
          </keyword>
          <keyword  id="merit_function" name="merit_function" code="{0}" label="SBL merit function"  minOccurs="0" default="augmented_lagrangian_merit" >
            <oneOf label="Merit Function">
              <keyword  id="penalty_merit" name="penalty_merit" code="{N_mdm(type,surrBasedLocalMeritFn_PENALTY_MERIT)}" label="penalty_merit"   />
              <keyword  id="adaptive_penalty_merit" name="adaptive_penalty_merit" code="{N_mdm(type,surrBasedLocalMeritFn_ADAPTIVE_PENALTY_MERIT)}" label="adaptive_penalty_merit"   />
              <keyword  id="lagrangian_merit" name="lagrangian_merit" code="{N_mdm(type,surrBasedLocalMeritFn_LAGRANGIAN_MERIT)}" label="lagrangian_merit"   />
              <keyword  id="augmented_lagrangian_merit" name="augmented_lagrangian_merit" code="{N_mdm(type,surrBasedLocalMeritFn_AUGMENTED_LAGRANGIAN_MERIT)}" label="augmented_lagrangian_merit"   />
            </oneOf>
          </keyword>
          <keyword  id="acceptance_logic" name="acceptance_logic" code="{0}" label="SBL iterate acceptance logic"  minOccurs="0" default="filter" >
            <oneOf label="Acceptance Logic">
              <keyword  id="tr_ratio" name="tr_ratio" code="{N_mdm(type,surrBasedLocalAcceptLogic_TR_RATIO)}" label="tr_ratio"   />
              <keyword  id="filter" name="filter" code="{N_mdm(type,surrBasedLocalAcceptLogic_FILTER)}" label="filter"   />
            </oneOf>
          </keyword>
          <keyword  id="constraint_relax" name="constraint_relax" code="{0}" label="SBL constraint relaxation method for infeasible iterates"  minOccurs="0" default="no relaxation" >
            <keyword  id="homotopy" name="homotopy" code="{N_mdm(type,surrBasedLocalConstrRelax_HOMOTOPY)}" label="homotopy"   />
          </keyword>
	  &default_trust_region;
          &method_max_iterations;
          &method_convergence_tolerance;
          &default_constraint_tolerance;
        </keyword>

        <keyword  id="surrogate_based_global" name="surrogate_based_global" code="{N_mdm(utype,methodName_SURROGATE_BASED_GLOBAL)}" label="surrogate_based_global"  group="Surrogate-based Methods" >
          <oneOf label="Sub-method Selection">
            <keyword  id="method_pointer4" name="method_pointer" code="{N_mdm(str,subMethodPointer)}" label="method_pointer"   >
              <alias name="approx_method_pointer"/>
              <param type="STRING" in_taglist="method" />
            </keyword>
            <keyword  id="method_name4" name="method_name" code="{N_mdm(str,subMethodName)}" label="method_name"   >
              <alias name="approx_method_name"/>
              <param type="STRING" />
            </keyword>
          </oneOf>
          <keyword  id="model_pointer4" name="model_pointer" code="{N_mdm(str,modelPointer)}" label="model_pointer"   default="method use of last model parsed (or use of default model if none parsed)" >
            <alias name="approx_model_pointer"/>
            <param type="STRING" in_taglist="model" />
          </keyword>
          <keyword  id="replace_points" name="replace_points" code="{N_mdm(true,surrBasedGlobalReplacePts)}" label="Replace points used in surrogate construction with best points from previous iteration"  minOccurs="0" default="Points appended, not replaced" />
          &method_max_iterations;
        </keyword>


	<!-- Optimizers -->

        <keyword  id="dot_frcg" name="dot_frcg" code="{N_mdm(utype,methodName_DOT_FRCG)}" label="dot_frcg"   group="Optimization: Local, Derivative-based" >
	  &method_dot_common_opts;
	</keyword>
        <keyword  id="dot_mmfd" name="dot_mmfd" code="{N_mdm(utype,methodName_DOT_MMFD)}" label="dot_mmfd"   group="Optimization: Local, Derivative-based" >
	  &method_dot_common_opts;
	</keyword>
        <keyword  id="dot_bfgs" name="dot_bfgs" code="{N_mdm(utype,methodName_DOT_BFGS)}" label="dot_bfgs"   group="Optimization: Local, Derivative-based" >
	  &method_dot_common_opts;
	</keyword>
        <keyword  id="dot_slp" name="dot_slp" code="{N_mdm(utype,methodName_DOT_SLP)}" label="dot_slp"   group="Optimization: Local, Derivative-based" >
	  &method_dot_common_opts;
	</keyword>
        <keyword  id="dot_sqp" name="dot_sqp" code="{N_mdm(utype,methodName_DOT_SQP)}" label="dot_sqp"   group="Optimization: Local, Derivative-based" >
	  &method_dot_common_opts;
	</keyword>

        <keyword  id="conmin_frcg" name="conmin_frcg" code="{N_mdm(utype,methodName_CONMIN_FRCG)}" label="conmin_frcg"   group="Optimization: Local, Derivative-based" >
	  &method_conmin_common_opts;
	</keyword>
        <keyword  id="conmin_mfd" name="conmin_mfd" code="{N_mdm(utype,methodName_CONMIN_MFD)}" label="conmin_mfd"   group="Optimization: Local, Derivative-based" >
	  &method_conmin_common_opts;
	</keyword>

        <keyword  id="dl_solver" name="dl_solver" code="{N_mdm(utype_lit,TYPE_DATA_methodName_DL_SOLVER)}" label="dl_solver"   group="Optimization: Other" >
          <!-- store method name AND incoming STRING -->
          <param type="STRING" />
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="npsol_sqp" name="npsol_sqp" code="{N_mdm(utype,methodName_NPSOL_SQP)}" label="npsol_sqp"   group="Optimization: Local, Derivative-based" >
	  &method_npsol_common_opts;
	</keyword>
        <keyword  id="nlssol_sqp" name="nlssol_sqp" code="{N_mdm(utype,methodName_NLSSOL_SQP)}" label="nlssol_sqp"   group="Calibration" >
	  &method_npsol_common_opts;
	</keyword>

        <keyword  id="nlpql_sqp" name="nlpql_sqp" code="{N_mdm(utype,methodName_NLPQL_SQP)}" label="nlpql_sqp"   group="Optimization: Local, Derivative-based" >
          &method_max_iterations;
          &method_convergence_tolerance;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="optpp_cg" name="optpp_cg" code="{N_mdm(utype,methodName_OPTPP_CG)}" label="optpp_cg"   group="Optimization: Local, Derivative-based" >
	  &method_optpp_grad_based_opts;
	</keyword>
        <keyword  id="optpp_q_newton" name="optpp_q_newton" code="{N_mdm(utype,methodName_OPTPP_Q_NEWTON)}" label="optpp_q_newton"   group="Optimization: Local, Derivative-based" >
	  &method_optpp_newton_opts;
	  &method_optpp_grad_based_opts;
	</keyword>
        <keyword  id="optpp_fd_newton" name="optpp_fd_newton" code="{N_mdm(utype,methodName_OPTPP_FD_NEWTON)}" label="optpp_fd_newton"   group="Optimization: Local, Derivative-based" >
	  &method_optpp_newton_opts;
	  &method_optpp_grad_based_opts;
	</keyword>
        <keyword  id="optpp_g_newton" name="optpp_g_newton" code="{N_mdm(utype,methodName_OPTPP_G_NEWTON)}" label="optpp_g_newton"   group="Calibration" >
	  &method_optpp_newton_opts;
	  &method_optpp_grad_based_opts;
	</keyword>
        <keyword  id="optpp_newton" name="optpp_newton" code="{N_mdm(utype,methodName_OPTPP_NEWTON)}" label="optpp_newton"   group="Optimization: Local, Derivative-based" >
	  &method_optpp_newton_opts;
	  &method_optpp_grad_based_opts;
	</keyword>
        <keyword  id="optpp_pds" name="optpp_pds" code="{N_mdm(utype,methodName_OPTPP_PDS)}" label="optpp_pds"  group="Optimization: Local, Derivative-free" >
          <keyword  id="search_scheme_size" name="search_scheme_size" code="{N_mdm(int,searchSchemeSize)}" label="search_scheme_size"  minOccurs="0" default="32" >
            <param type="INTEGER" />
          </keyword>
          &method_max_iterations;
          &method_convergence_tolerance;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>


        <keyword  id="demo_tpl" name="demo_tpl" code="{N_mdm(utype,methodName_DEMO_TPL)}" label="demo_tpl" help="" group="Optimization: Local" >
          &method_max_function_evaluations;
	  &method_max_iterations;
          &method_convergence_tolerance;
          <keyword  id="variable_tolerance" name="variable_tolerance" code="{N_mdm(Real,threshStepLength)}" label="Threshold for offset values"  minOccurs="0" default="0.01" >
            <param type="REAL" />
          </keyword>
          <keyword  id="solution_target" name="solution_target" code="{N_mdm(Real,solnTarget)}" label="Solution target"  minOccurs="0" default="no target" >
            <alias name="solution_accuracy"/>
            <param type="REAL" />
          </keyword>
	  <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
	    <param type="INPUT_FILE" />
	  </keyword>
        </keyword>


        <keyword  id="rol" name="rol" code="{N_mdm(utype,methodName_ROL)}" label="rol" help="" group="Optimization: Local, Derivative-based" >
	  &method_max_iterations;
          <keyword  id="variable_tolerance" name="variable_tolerance" code="{N_mdm(Real,threshStepLength)}" label="Threshold for offset values"  minOccurs="0" default="0.01" >
            <param type="REAL" />
          </keyword>
          <keyword  id="gradient_tolerance" name="gradient_tolerance" code="{N_mdm(Real,gradientTolerance)}" label="gradient_tolerance"  minOccurs="0" default="1.e-4" >
            <param type="REAL" />
          </keyword>
	  &default_constraint_tolerance;
	  <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
	    <param type="INPUT_FILE" />
	  </keyword>
	  &default_scaling;
          &method_optional_model_pointer;
        </keyword>


        <keyword  id="asynch_pattern_search" name="asynch_pattern_search" code="{N_mdm(utype,methodName_ASYNCH_PATTERN_SEARCH)}" label="asynch_pattern_search"  group="Optimization: Local, Derivative-free" >
          <alias name="coliny_apps"/>
          <keyword  id="initial_delta" name="initial_delta" code="{N_mdm(Real,initStepLength)}" label="Initial offset value"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="contraction_factor1" name="contraction_factor" code="{N_mdm(Real,contractStepLength)}" label="Pattern contraction factor"  minOccurs="0" default="0.5" >
            <param type="REAL" />
          </keyword>
          <keyword  id="variable_tolerance" name="variable_tolerance" code="{N_mdm(Real,threshStepLength)}" label="Threshold for offset values"  minOccurs="0" default="0.01" >
            <param type="REAL" />
          </keyword>
          <keyword  id="solution_target" name="solution_target" code="{N_mdm(Real,solnTarget)}" label="Solution target"  minOccurs="0" default="no target" >
            <alias name="solution_accuracy"/>
            <param type="REAL" />
          </keyword>
	  &method_synchronization;
          <keyword  id="merit_function2" name="merit_function" code="{0}" label="Merit function"  minOccurs="0" default="merit2_squared" >
            <oneOf label="Merit Function">
              <keyword  id="merit_max" name="merit_max" code="{N_mdm(lit,meritFunction_merit_max)}" label="merit_max"   />
              <keyword  id="merit_max_smooth" name="merit_max_smooth" code="{N_mdm(lit,meritFunction_merit_max_smooth)}" label="merit_max_smooth"   />
              <keyword  id="merit1" name="merit1" code="{N_mdm(lit,meritFunction_merit1)}" label="merit1"   />
              <keyword  id="merit1_smooth" name="merit1_smooth" code="{N_mdm(lit,meritFunction_merit1_smooth)}" label="merit1_smooth"   />
              <keyword  id="merit2" name="merit2" code="{N_mdm(lit,meritFunction_merit2)}" label="merit2"   />
              <keyword  id="merit2_smooth" name="merit2_smooth" code="{N_mdm(lit,meritFunction_merit2_smooth)}" label="merit2_smooth"   />
              <keyword  id="merit2_squared" name="merit2_squared" code="{N_mdm(lit,meritFunction_merit2_squared)}" label="merit2_squared"   />
            </oneOf>
          </keyword>
          <keyword  id="constraint_penalty" name="constraint_penalty" code="{N_mdm(Real,constrPenalty)}" label="Constraint penalty"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="smoothing_factor" name="smoothing_factor" code="{N_mdm(Real,smoothFactor)}" label="Smoothing factor"  minOccurs="0" default="0.0" >
            <param type="REAL" />
          </keyword>
          &default_constraint_tolerance;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="mesh_adaptive_search" name="mesh_adaptive_search" code="{N_mdm(utype,methodName_MESH_ADAPTIVE_SEARCH)}" label="mesh_adaptive_search"  >
          <keyword  id="initial_delta2" name="initial_delta" code="{N_mdm(Real,initMeshSize)}" label="Initial mesh size"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="variable_tolerance2" name="variable_tolerance" code="{N_mdm(Real,minMeshSize)}" label="Minimum mesh size"  minOccurs="0" default="1.0e-6" >
            <param type="REAL" />
          </keyword>
          <keyword  id="function_precision1" name="function_precision" code="{N_mdm(Real,functionPrecision)}" label="Function Evaluation Precision"  minOccurs="0" default="1.0e-10" >
            <param type="REAL" />
          </keyword>
          <keyword  id="seed2" name="seed" code="{N_mdm(int,randomSeed)}" label="Random Seed"  minOccurs="0" default="system-generated (non-repeatable)" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          <keyword  id="history_file" name="history_file" code="{N_mdm(str,historyFile)}" label="NOMAD History File"  minOccurs="0" default="mads_history" >
            <param type="OUTPUT_FILE" />
          </keyword>
          <keyword  id="display_format" name="display_format" code="{N_mdm(str,displayFormat)}" label="display_format"  minOccurs="0" >
            <param type="STRING" />
          </keyword>
          <keyword  id="variable_neighborhood_search" name="variable_neighborhood_search" code="{N_mdm(Real,vns)}" label="variable_neighborhood_search"  minOccurs="0" default="0.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="neighbor_order" name="neighbor_order" code="{N_mdm(int,neighborOrder)}" label="Neighbor Order"  minOccurs="0" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          <keyword  id="display_all_evaluations" name="display_all_evaluations" code="{N_mdm(true,showAllEval)}" label="Display NOMAD evaluations"  minOccurs="0" default="false" />
          <keyword  id="use_surrogate" name="use_surrogate" code="{0}" label="use_surrogate"  minOccurs="0" default="optimize">
            <oneOf label="Surrogate Purpose">
              <keyword  id="inform_search" name="inform_search" code="{N_mdm(lit,useSurrogate_inform_search)}" label="inform_search"   >
              </keyword>
              <keyword  id="optimize" name="optimize" code="{N_mdm(lit,useSurrogate_optimize)}" label="optimize"   >
              </keyword>
            </oneOf>
          </keyword>
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="nowpac" name="nowpac" code="{N_mdm(utype,methodName_MIT_NOWPAC)}" label="nowpac"  >
          &default_trust_region;
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="snowpac" name="snowpac" code="{N_mdm(utype,methodName_MIT_SNOWPAC)}" label="snowpac"  >
	  <keyword  id="seed6" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
          &default_trust_region;
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

	<!-- BEGIN JEGA -->
        <keyword  id="moga" name="moga" code="{N_mdm(utype,methodName_MOGA)}" label="moga"  group="Optimization: Global" >
          <keyword  id="fitness_type" name="fitness_type" code="{0}" label="Fitness type"  minOccurs="0" default="domination_count" >
            <oneOf label="Fitness Type">
              <keyword  id="layer_rank" name="layer_rank" code="{N_mdm(lit,fitnessType_layer_rank)}" label="layer_rank"   />
              <keyword  id="domination_count" name="domination_count" code="{N_mdm(lit,fitnessType_domination_count)}" label="domination_count"   />
            </oneOf>
          </keyword>
          <keyword  id="replacement_type" name="replacement_type" code="{0}" label="Replacement type"  minOccurs="0" default="below_limit" >
            <oneOf label="Replacement Type">
              <keyword  id="elitist" name="elitist" code="{N_mdm(lit,replacementType_elitist)}" label="elitist"   />
              <keyword  id="roulette_wheel" name="roulette_wheel" code="{N_mdm(lit,replacementType_roulette_wheel)}" label="roulette_wheel"   />
              <keyword  id="unique_roulette_wheel" name="unique_roulette_wheel" code="{N_mdm(lit,replacementType_unique_roulette_wheel)}" label="unique_roulette_wheel"   />
              <keyword  id="below_limit" name="below_limit" code="{N_mdm(litp,TYPE_DATA_replacementType_below_limit)}" label="Below limit selection"  default="6" >
                <param type="REAL" />
                <keyword  id="shrinkage_fraction" name="shrinkage_fraction" code="{N_mdm(Real01,shrinkagePercent)}" label="shrinkage_fraction"  minOccurs="0" default="0.9" >
                  <alias name="shrinkage_percentage"/>
                  <param type="REAL" />
                </keyword>
              </keyword>
            </oneOf>
          </keyword>
          <keyword  id="niching_type" name="niching_type" code="{0}" label="Niche pressure type"  minOccurs="0" default="No niche pressure" >
            <oneOf label="Niching Type">
              <keyword  id="radial" name="radial" code="{N_mdm(RealLlit,TYPE_DATA_nichingType_radial)}" label="radial"   default="0.01 for all objectives" >
                <param type="REALLIST" />
              </keyword>
              <keyword  id="distance" name="distance" code="{N_mdm(RealLlit,TYPE_DATA_nichingType_distance)}" label="distance"   >
                <param type="REALLIST" />
              </keyword>
              <keyword  id="max_designs" name="max_designs" code="{N_mdm(RealLlit,TYPE_DATA_nichingType_max_designs)}" label="max_designs"  >
                <param type="REALLIST" />
                <keyword  id="num_designs" name="num_designs" code="{N_mdm(sizet,numDesigns)}" label="Number designs to keep for max_designs nicher"  minOccurs="0" default="100" >
                  <param type="INTEGER" constraint=">= 2" />
                </keyword>
              </keyword>
            </oneOf>
          </keyword>
          <keyword  id="convergence_type" name="convergence_type" code="{0}" label="convergence_type"  minOccurs="0" default="average_fitness_tracker" >
            <keyword  id="metric_tracker" name="metric_tracker" code="{N_mdm(lit,convergenceType_metric_tracker)}" label="Convergence type"   default="metric_tracker" />
            <keyword  id="percent_change" name="percent_change" code="{N_mdm(Realz,convergenceTolerance)}" label="Percent change limit for metric_tracker converger"  minOccurs="0" default="0.1" >
              <param type="REAL" />
            </keyword>
            <keyword  id="num_generations" name="num_generations" code="{N_mdm(sizet,numGenerations)}" label="Number generations for metric_tracker converger"  minOccurs="0" default="10" >
              <param type="INTEGER" constraint=">= 0" />
            </keyword>
          </keyword>
          <keyword  id="postprocessor_type" name="postprocessor_type" code="{0}" label="Post_processor type"  minOccurs="0" default="No post-processing of solutions" >
            <keyword  id="orthogonal_distance" name="orthogonal_distance" code="{N_mdm(RealLlit,TYPE_DATA_postProcessorType_distance_postprocessor)}" label="Post_processor distance"   default="0.01 for all objectives" >
              <param type="REALLIST" />
            </keyword>
          </keyword>
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_jega_common_opts;
        </keyword>
        <keyword  id="soga" name="soga" code="{N_mdm(utype,methodName_SOGA)}" label="soga"  group="Optimization: Global" >
          <keyword  id="fitness_type1" name="fitness_type" code="{0}" label="Fitness type"  minOccurs="0" default="merit_function">
            <keyword  id="merit_function3" name="merit_function" code="{N_mdm(lit,fitnessType_merit_function)}" label="merit_function"   />
            <keyword  id="constraint_penalty1" name="constraint_penalty" code="{N_mdm(Realp,constraintTolerance)}" label="Constraint penalty in merit function"  minOccurs="0" default="1.0" >
              <param type="REAL" />
            </keyword>
          </keyword>
          <keyword  id="replacement_type1" name="replacement_type" code="{0}" label="Replacement type"  minOccurs="0" default="elitist" >
            <oneOf label="Replacement Type">
              <keyword  id="elitist1" name="elitist" code="{N_mdm(lit,replacementType_elitist)}" label="elitist"   />
              <keyword  id="favor_feasible" name="favor_feasible" code="{N_mdm(lit,replacementType_favor_feasible)}" label="favor_feasible"   />
              <keyword  id="roulette_wheel1" name="roulette_wheel" code="{N_mdm(lit,replacementType_roulette_wheel)}" label="roulette_wheel"   />
              <keyword  id="unique_roulette_wheel1" name="unique_roulette_wheel" code="{N_mdm(lit,replacementType_unique_roulette_wheel)}" label="unique_roulette_wheel"   />
            </oneOf>
          </keyword>
          <keyword  id="convergence_type1" name="convergence_type" code="{0}" label="Convergence type"  minOccurs="0" default="average_fitness_tracker" >
            <oneOf label="Convergence Type">
              <keyword  id="best_fitness_tracker" name="best_fitness_tracker" code="{N_mdm(lit,convergenceType_best_fitness_tracker)}" label="best_fitness_tracker"  >
                <keyword  id="percent_change1" name="percent_change" code="{N_mdm(Realz,convergenceTolerance)}" label="Percent change in fitness"  minOccurs="0" default="0.1" >
                  <param type="REAL" />
                </keyword>
                <keyword  id="num_generations1" name="num_generations" code="{N_mdm(sizet,numGenerations)}" label="Number of generations (for convergence test) "  minOccurs="0" default="10" >
                  <param type="INTEGER" constraint=">= 0" />
                </keyword>
              </keyword>
              <keyword  id="average_fitness_tracker" name="average_fitness_tracker" code="{N_mdm(lit,convergenceType_average_fitness_tracker)}" label="average_fitness_tracker"  >
                <keyword  id="percent_change2" name="percent_change" code="{N_mdm(Realz,convergenceTolerance)}" label="percent_change"  minOccurs="0" default="0.1" >
                  <param type="REAL" />
                </keyword>
                <keyword  id="num_generations2" name="num_generations" code="{N_mdm(sizet,numGenerations)}" label="num_generations"  minOccurs="0" default="10" >
                  <param type="INTEGER" constraint=">= 0" />
                </keyword>
              </keyword>
            </oneOf>
          </keyword>
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_jega_common_opts;
        </keyword>
	<!-- END JEGA -->

	<!-- BEGIN coliny methods -->
        <keyword  id="coliny_pattern_search" name="coliny_pattern_search" code="{N_mdm(utype,methodName_COLINY_PATTERN_SEARCH)}" label="coliny_pattern_search"  group="Optimization: Local, Derivative-free" >
          <keyword  id="constant_penalty" name="constant_penalty" code="{N_mdm(true,constantPenalty)}" label="Control of dynamic penalty"  minOccurs="0" default="algorithm dynamically adapts the constraint penalty" />
          <keyword  id="no_expansion" name="no_expansion" code="{N_mdm(false,expansionFlag)}" label="No expansion flag"  minOccurs="0" default="algorithm may expand pattern size" />
          <keyword  id="expand_after_success" name="expand_after_success" code="{N_mdm(int,expandAfterSuccess)}" label="Number of consecutive improvements before expansion"  minOccurs="0" default="5" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="pattern_basis" name="pattern_basis" code="{0}" label="Pattern basis selection"  minOccurs="0" default="coordinate" >
            <oneOf label="Pattern Basis Type">
              <keyword  id="coordinate" name="coordinate" code="{N_mdm(lit,patternBasis_coordinate)}" label="coordinate"   />
              <keyword  id="simplex" name="simplex" code="{N_mdm(lit,patternBasis_simplex)}" label="simplex"   />
            </oneOf>
          </keyword>
          <keyword  id="stochastic" name="stochastic" code="{N_mdm(true,randomizeOrderFlag)}" label="Stochastic pattern search"  minOccurs="0" />
          <keyword  id="total_pattern_size" name="total_pattern_size" code="{N_mdm(int,totalPatternSize)}" label="Total number of points in pattern"  minOccurs="0" default="no augmentation of basic pattern" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="exploratory_moves" name="exploratory_moves" code="{0}" label="Exploratory moves selection"  minOccurs="0" default="basic_pattern" >
            <oneOf label="Exploration Mode">
              <keyword  id="multi_step" name="multi_step" code="{N_mdm(lit,exploratoryMoves_multi_step)}" label="multi_step"   />
              <keyword  id="adaptive_pattern" name="adaptive_pattern" code="{N_mdm(lit,exploratoryMoves_adaptive)}" label="adaptive_pattern"   />
              <keyword  id="basic_pattern" name="basic_pattern" code="{N_mdm(lit,exploratoryMoves_simple)}" label="basic_pattern"   />
            </oneOf>
          </keyword>
          &method_synchronization;
          <keyword  id="contraction_factor2" name="contraction_factor" code="{N_mdm(Real,contractFactor)}" label="contraction_factor"  minOccurs="0" default="0.5" >
            <param type="REAL" />
          </keyword>
          <keyword  id="constraint_penalty2" name="constraint_penalty" code="{N_mdm(Real,constraintPenalty)}" label="constraint_penalty"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>

          <keyword  id="initial_delta1" name="initial_delta" code="{N_mdm(Real,initDelta)}" label="initial_delta"  minOccurs="0" default="1.0 (COBYLA), 0.1*range (PS, SW)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="variable_tolerance1" name="variable_tolerance" code="{N_mdm(Real,threshDelta)}" label="variable_tolerance"  minOccurs="0" default="1.0e-4 (COBYLA), 1.0e-5 (PS), 1.0e-6 (SW)">
            <param type="REAL" />
          </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="coliny_solis_wets" name="coliny_solis_wets" code="{N_mdm(utype,methodName_COLINY_SOLIS_WETS)}" label="coliny_solis_wets"  group="Optimization: Local, Derivative-free" >
          <keyword  id="contract_after_failure" name="contract_after_failure" code="{N_mdm(int,contractAfterFail)}" label="Number of consecutive failures before contraction"  minOccurs="0" default="4*number of variables" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="no_expansion1" name="no_expansion" code="{N_mdm(false,expansionFlag)}" label="No expansion flag"  minOccurs="0" default="algorithm may expand pattern size" />
          <keyword  id="expand_after_success1" name="expand_after_success" code="{N_mdm(int,expandAfterSuccess)}" label="Number of consecutive improvements before expansion"  minOccurs="0" default="5" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="constant_penalty1" name="constant_penalty" code="{N_mdm(true,constantPenalty)}" label="Control of dynamic penalty"  minOccurs="0" default="algorithm dynamically adapts the constraint penalty" />
          <keyword  id="contraction_factor2" name="contraction_factor" code="{N_mdm(Real,contractFactor)}" label="contraction_factor"  minOccurs="0" default="0.5" >
            <param type="REAL" />
          </keyword>
          <keyword  id="constraint_penalty2" name="constraint_penalty" code="{N_mdm(Real,constraintPenalty)}" label="constraint_penalty"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>

          <keyword  id="initial_delta1" name="initial_delta" code="{N_mdm(Real,initDelta)}" label="initial_delta"  minOccurs="0" default="1.0 (COBYLA), 0.1*range (PS, SW)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="variable_tolerance1" name="variable_tolerance" code="{N_mdm(Real,threshDelta)}" label="variable_tolerance"  minOccurs="0" default="1.0e-4 (COBYLA), 1.0e-5 (PS), 1.0e-6 (SW)">
            <param type="REAL" />
	  </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="coliny_cobyla" name="coliny_cobyla" code="{N_mdm(utype,methodName_COLINY_COBYLA)}" label="coliny_cobyla"   group="Optimization: Local, Derivative-free">
          <keyword  id="initial_delta1" name="initial_delta" code="{N_mdm(Real,initDelta)}" label="initial_delta"  minOccurs="0" default="1.0 (COBYLA), 0.1*range (PS, SW)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="variable_tolerance1" name="variable_tolerance" code="{N_mdm(Real,threshDelta)}" label="variable_tolerance"  minOccurs="0" default="1.0e-4 (COBYLA), 1.0e-5 (PS), 1.0e-6 (SW)">
            <param type="REAL" />
          </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="coliny_direct" name="coliny_direct" code="{N_mdm(utype,methodName_COLINY_DIRECT)}" label="coliny_direct"  group="Optimization: Global" >
          <keyword  id="division" name="division" code="{0}" label="Box subdivision approach"  minOccurs="0" default="major_dimension" >
            <oneOf label="Divide Along">
              <keyword  id="major_dimension" name="major_dimension" code="{N_mdm(lit,boxDivision_major_dimension)}" label="major_dimension"   />
              <keyword  id="all_dimensions" name="all_dimensions" code="{N_mdm(lit,boxDivision_all_dimensions)}" label="all_dimensions"   />
            </oneOf>
          </keyword>
          <keyword  id="global_balance_parameter" name="global_balance_parameter" code="{N_mdm(Real,globalBalanceParam)}" label="Global search balancing parameter"  minOccurs="0" default="0.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="local_balance_parameter" name="local_balance_parameter" code="{N_mdm(Real,localBalanceParam)}" label="Local search balancing parameter"  minOccurs="0" default="1.e-8" >
            <param type="REAL" />
          </keyword>
          <keyword  id="max_boxsize_limit" name="max_boxsize_limit" code="{N_mdm(Real,maxBoxSize)}" label="Maximum boxsize limit"  minOccurs="0" default="0.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="min_boxsize_limit" name="min_boxsize_limit" code="{N_mdm(Real,minBoxSize)}" label="Minimum boxsize limit"  minOccurs="0" default="1.0e-4" >
            <param type="REAL" />
          </keyword>
          <keyword  id="constraint_penalty3" name="constraint_penalty" code="{N_mdm(Real,constraintPenalty)}" label="Constraint penalty"  minOccurs="0" default="1000.0" >
            <param type="REAL" />
          </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>
        <keyword  id="coliny_ea" name="coliny_ea" code="{N_mdm(utype,methodName_COLINY_EA)}" label="coliny_ea"  group="Optimization: Global" >
          <keyword  id="population_size1" name="population_size" code="{N_mdm(int,populationSize)}" label="Number of population members"  minOccurs="0" default="50" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          <keyword  id="initialization_type1" name="initialization_type" code="{0}" label="Initialization type"  minOccurs="0" default="unique_random" >
            <oneOf label="Initialization Type">
              <keyword  id="simple_random1" name="simple_random" code="{N_mdm(lit,initializationType_random)}" label="simple_random"   />
              <keyword  id="unique_random1" name="unique_random" code="{N_mdm(lit,initializationType_unique_random)}" label="unique_random"   />
              <keyword  id="flat_file1" name="flat_file" code="{N_mdm(slit2,TYPE_DATA_initializationType_flat_file)}" label="flat_file"   >
                <!-- store init type AND incoming STRING -->
                <param type="STRING" />
              </keyword>
            </oneOf>
          </keyword>
          <keyword  id="fitness_type2" name="fitness_type" code="{0}" label="Fitness type"  minOccurs="0" default="linear_rank" >
            <oneOf label="Fitness Type">
              <keyword  id="linear_rank" name="linear_rank" code="{N_mdm(lit,fitnessType_linear_rank)}" label="linear_rank"   />
              <keyword  id="merit_function4" name="merit_function" code="{N_mdm(lit,fitnessType_proportional)}" label="merit_function"   />
            </oneOf>
          </keyword>
          <keyword  id="replacement_type2" name="replacement_type" code="{0}" label="Replacement type"  minOccurs="0" default="elitist=1" >
            <oneOf label="Replacement Type">
              <keyword  id="random" name="random" code="{N_mdm(ilit2,TYPE_DATA_replacementType_random)}" label="Random replacement type"   >
                <param type="INTEGER" />
              </keyword>
              <keyword  id="chc" name="chc" code="{N_mdm(ilit2,TYPE_DATA_replacementType_chc)}" label="CHC replacement type"   >
                <param type="INTEGER" />
              </keyword>
              <keyword  id="elitist2" name="elitist" code="{N_mdm(ilit2,TYPE_DATA_replacementType_elitist)}" label="Elitist replacement type"   >
                <param type="INTEGER" />
              </keyword>
            </oneOf>
            <keyword  id="new_solutions_generated" name="new_solutions_generated" code="{N_mdm(int,newSolnsGenerated)}" label="New solutions generated"  minOccurs="0" default="population_size - replacement_size" >
              <param type="INTEGER" />
            </keyword>
          </keyword>
          <keyword  id="crossover_rate1" name="crossover_rate" code="{N_mdm(Real,crossoverRate)}" label="Crossover rate"  minOccurs="0" default="0.8" >
            <param type="REAL" />
          </keyword>
          <keyword  id="crossover_type1" name="crossover_type" code="{0}" label="Crossover type"  minOccurs="0" default="two_point">
            <oneOf label="Crossover Type">
              <keyword  id="two_point" name="two_point" code="{N_mdm(lit,crossoverType_two_point)}" label="two_point"   />
              <keyword  id="blend" name="blend" code="{N_mdm(lit,crossoverType_blend)}" label="blend"   />
              <keyword  id="uniform" name="uniform" code="{N_mdm(lit,crossoverType_uniform)}" label="uniform"   />
            </oneOf>
          </keyword>
          <keyword  id="mutation_rate1" name="mutation_rate" code="{N_mdm(Real,mutationRate)}" label="Mutation rate"  minOccurs="0" default="1.0" >
            <param type="REAL" />
          </keyword>
          <keyword  id="mutation_type1" name="mutation_type" code="{0}" label="Mutation type"  minOccurs="0" default="offset_normal" >
            <oneOf label="Mutation Type">
              <keyword  id="replace_uniform1" name="replace_uniform" code="{N_mdm(lit,mutationType_replace_uniform)}" label="replace_uniform"   />
              <keyword  id="offset_normal1" name="offset_normal" code="{N_mdm(lit,mutationType_offset_normal)}" label="offset_normal"  >
		&coliny_mutation_scale_range;
	      </keyword>
              <keyword  id="offset_cauchy1" name="offset_cauchy" code="{N_mdm(lit,mutationType_offset_cauchy)}" label="offset_cauchy"  >
		&coliny_mutation_scale_range;
	      </keyword>
              <keyword  id="offset_uniform1" name="offset_uniform" code="{N_mdm(lit,mutationType_offset_uniform)}" label="offset_uniform"  >
		&coliny_mutation_scale_range;
	      </keyword>
            </oneOf>
            <keyword  id="non_adaptive" name="non_adaptive" code="{N_mdm(false,mutationAdaptive)}" label="Non-adaptive mutation flag"  minOccurs="0" default="Adaptive mutation" />
          </keyword>
          <keyword  id="constraint_penalty4" name="constraint_penalty" code="{N_mdm(Real,constraintPenalty)}" label="constraint_penalty"  minOccurs="0" >
            <param type="REAL" />
          </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>
        <keyword  id="coliny_beta" name="coliny_beta" code="{N_mdm(utype,methodName_COLINY_BETA)}" label="coliny_beta"  group="Optimization: Other" >
          <keyword  id="beta_solver_name" name="beta_solver_name" code="{N_mdm(str,betaSolverName)}" label="beta_solver_name"   >
            <param type="STRING" />
          </keyword>
	  &coliny_common_opts;
	  &method_optional_model_pointer;
        </keyword>
	<!-- END coliny methods -->

        <keyword  id="nl2sol" name="nl2sol" code="{N_mdm(utype,methodName_NL2SOL)}" label="nl2sol"  group="Calibration" >
          <keyword  id="function_precision2" name="function_precision" code="{N_mdm(Real,functionPrecision)}" label="Relative precision in least squares terms"  minOccurs="0" default="1.0e-10" >
            <param type="REAL" />
          </keyword>
          <keyword  id="absolute_conv_tol" name="absolute_conv_tol" code="{N_mdm(Real,absConvTol)}" label="Absolute function convergence tolerance"  minOccurs="0" default="-1. (use NL2SOL internal default)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="x_conv_tol" name="x_conv_tol" code="{N_mdm(Real,xConvTol)}" label="Convergence tolerance for change in parameter vector"  minOccurs="0" default="-1. (use NL2SOL internal default)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="singular_conv_tol" name="singular_conv_tol" code="{N_mdm(Real,singConvTol)}" label="Singular convergence tolerance"  minOccurs="0" default="-1. (use NL2SOL internal default)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="singular_radius" name="singular_radius" code="{N_mdm(Real,singRadius)}" label="Step limit for sctol"  minOccurs="0" default="-1. (use NL2SOL internal default of 1)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="false_conv_tol" name="false_conv_tol" code="{N_mdm(Real,falseConvTol)}" label="False convergence tolerance"  minOccurs="0" default="-1. (use NL2SOL internal default)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="initial_trust_radius" name="initial_trust_radius" code="{N_mdm(Real,initTRRadius)}" label="Initial trust region radius"  minOccurs="0" default="-1. (use NL2SOL internal default of 1)" >
            <param type="REAL" />
          </keyword>
          <keyword  id="covariance" name="covariance" code="{N_mdm(int,covarianceType)}" label="Covariance post-processing"  minOccurs="0" default="0 (no covariance)" >
            <param type="INTEGER" />
          </keyword>
          <keyword  id="regression_diagnostics" name="regression_diagnostics" code="{N_mdm(true,regressDiag)}" label="Regression diagnostics post-processing"  minOccurs="0" default="no regression diagnostics" />
          &method_convergence_tolerance;
          &method_max_iterations;
          &default_speculative;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="nonlinear_cg" name="nonlinear_cg" code="{N_mdm(utype,methodName_NONLINEAR_CG)}" label="nonlinear_cg"  group="Optimization: Local, Derivative-based" >
          <keyword  id="misc_options1" name="misc_options" code="{N_mdm(strL,miscOptions)}" label="misc_options"  minOccurs="0" default="no misc options" >
            <param type="STRINGLIST" />
          </keyword>
          &method_convergence_tolerance;
          &method_max_iterations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="ncsu_direct" name="ncsu_direct" code="{N_mdm(utype,methodName_NCSU_DIRECT)}" label="ncsu_direct"  group="Optimization: Global" >
          <keyword  id="solution_target2" name="solution_target" code="{N_mdm(Real,solnTarget)}" label="Solution Target "  minOccurs="0" default="0" >
            <alias name="solution_accuracy"/>
            <param type="REAL" />
          </keyword>
          <keyword  id="min_boxsize_limit1" name="min_boxsize_limit" code="{N_mdm(Real,minBoxSize)}" label="Min boxsize limit"  minOccurs="0" default="1.0e-4" >
            <param type="REAL" />
          </keyword>
          <keyword  id="volume_boxsize_limit" name="volume_boxsize_limit" code="{N_mdm(Real,volBoxSize)}" label="Volume boxsize limit"  minOccurs="0" default="1.0e-6" >
            <param type="REAL" />
          </keyword>
          &method_convergence_tolerance;
          &method_max_iterations;
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="genie_opt_darts" name="genie_opt_darts" code="{N_mdm(utype,methodName_GENIE_OPT_DARTS)}" label="genie_opt_darts"   group="Optimization: Global">
          <keyword  id="seed5" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
	</keyword>

        <keyword  id="genie_direct" name="genie_direct" code="{N_mdm(utype,methodName_GENIE_DIRECT)}" label="genie_direct"   group="Optimization: Global">
	  <keyword  id="seed5" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          &method_max_function_evaluations;
          &default_scaling;
	  &method_optional_model_pointer;
	</keyword>

        <keyword  id="efficient_global" name="efficient_global" code="{N_mdm(utype,methodName_EFFICIENT_GLOBAL)}" label="efficient_global"  group="Surrogate-based Methods" >
	  <keyword  id="initial_samples" name="initial_samples" code="{N_mdm(int,numSamples)}" label="initial samples"  minOccurs="0" default="(d+1)(d+2)/2">
	    <param type="INTEGER" />
	  </keyword>
          <keyword  id="seed6" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
          <keyword  id="batch_size" name="batch_size" code="{N_mdm(int,batchSize)}" label="Number of concurrent refinement candidates to compute for parallel execution"  minOccurs="0" >
            <param type="INTEGER" constraint=">= 1" />
            <keyword  id="exploration" name="exploration" code="{N_mdm(int,batchSizeExplore)}" label="Portion of specified batch size that performs exploration rather than selected acquisition"  minOccurs="0" >
  	      <param type="INTEGER" constraint=">= 0" />
    	    </keyword>
            &method_synchronization;
    	  </keyword>
          &method_max_iterations;
	  <keyword  id="convergence_tolerance" name="convergence_tolerance" code="{N_mdm(Real,convergenceTolerance)}" label="Convergence tolerance"  minOccurs="0" default="1.e-12" >
            <param type="REAL" />
          </keyword>
          <keyword  id="x_conv_tol" name="x_conv_tol" code="{N_mdm(Real,xConvTol)}" label="Convergence tolerance for change in parameter vector"  minOccurs="0" default="1.0e-8" >
            <param type="REAL" />
          </keyword>
	  &method_gp_alternatives_with_export;
          <keyword  id="use_derivatives" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="Derivative usage"  minOccurs="0" default="use function values only"/>
          <keyword  id="import_build_points_file" name="import_build_points_file" code="{N_mdm(str,importBuildPtsFile)}" label="File name for points to be imported as the basis for the initial GP"  minOccurs="0" default="no point import from a file" >
	    <alias name="import_points_file"/>
            <param type="INPUT_FILE" />
	    &method_import_build_format;
	    <keyword  id="active_only" name="active_only" code="{N_mdm(true,importBuildActive)}" label="Active variables only"  minOccurs="0" />
          </keyword>
          <keyword  id="export_approx_points_file" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="File name for exporting approximation-based samples from evaluating the GP"  minOccurs="0" default="no point export to a file" >
	    <alias name="export_points_file"/>
            <param type="OUTPUT_FILE" />
	    &method_export_approx_format;
          </keyword>
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="surrogate_based_uq" name="surrogate_based_uq" code="{N_mdm(utype,methodName_SURROGATE_BASED_UQ)}" label="surrogate_based_uq" help="" group="Uncertainty Quantification" >
          <!-- Current target is Model-based PCE,SC,FT expansions: support expansion_options. -->
	  &expansion_options; <!-- level mappings et al. -->
          &method_seed;       <!-- for expansion sampler -->
          <!-- DFSModel spec defines approximation, DACE, data import, etc. -->
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="function_train" name="function_train" code="{N_mdm(utype,methodName_C3_FUNCTION_TRAIN)}" label="function_train" help="" group="Uncertainty Quantification" >
	  &ft_method_refinement;
	  &method_exp_convergence_tolerance;
	  <!-- &import_build; Rely on DFSModel data import -->
	  &ft_method_regression;
	  &ft_method_tols;
	  &ft_method_order;
	  &ft_method_rank;
	  &expansion_options;
          &method_seed;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="multifidelity_function_train" name="multifidelity_function_train" code="{N_mdm(utype,methodName_MULTIFIDELITY_FUNCTION_TRAIN)}" label="multifidelity_function_train" help="" group="Uncertainty Quantification" >
	  &ft_method_refinement;
	  &method_mf_exp_convergence_tolerance;
	  &mf_alloc_control;
	  &discrep_emulation;
	  &ft_method_tols;
	  &ft_method_regression_sequence;
	  &mlft_method_order_sequence;
	  &mlft_method_rank_sequence;
	  &expansion_options;
          &method_seed_sequence;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="multilevel_function_train" name="multilevel_function_train" code="{N_mdm(utype,methodName_MULTILEVEL_FUNCTION_TRAIN)}" label="multilevel_function_train" help="" group="Uncertainty Quantification" >
	  &method_max_iterations;
	  &mlft_alloc_control;
	  &method_exp_convergence_tolerance;
	  &discrep_emulation;
	  &ft_method_tols;
	  &ft_method_regression_sequence;
	  &mlft_method_order_sequence;
	  &mlft_method_rank_sequence;
	  &expansion_options;
          &method_seed_sequence;
	  &method_optional_model_pointer;
        </keyword>

	<keyword  id="polynomial_chaos" name="polynomial_chaos" code="{N_mdm(utype,methodName_POLYNOMIAL_CHAOS)}" label="polynomial_chaos" group="Uncertainty Quantification" >
	  <alias name="nond_polynomial_chaos"/>
	  &pce_refinement;
	  &method_exp_convergence_tolerance;
	  <oneOf label="Chaos coefficient estimation approach">
	    &expansion_quadrature;
	    &pce_sparse_grid;
	    &pce_cubature;
	    &pce_expansion_order;
	    &pce_orthog_least_interp;
	    &pce_expansion_import;
	  </oneOf>
	  &pce_options;
	  &expansion_options;
          &method_seed;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multifidelity_polynomial_chaos" name="multifidelity_polynomial_chaos" code="{N_mdm(utype,methodName_MULTIFIDELITY_POLYNOMIAL_CHAOS)}" label="multifidelity_polynomial_chaos" group="Uncertainty Quantification" >
	  &pce_refinement;
	  &method_mf_exp_convergence_tolerance;
	  &mf_alloc_control;
	  &discrep_emulation;
	  <oneOf label="Chaos Coefficient Estimation Approach">
	    &expansion_quadrature_sequence;
	    &pce_sparse_grid_sequence;
	    <!-- &pce_cubature; -->
	    &pce_expansion_order_sequence;
	    &pce_orthog_least_interp_sequence;
	    <!-- &pce_expansion_import -->
	  </oneOf>
	  &pce_options;
	  &expansion_options;
          &method_seed_sequence;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multilevel_polynomial_chaos" name="multilevel_polynomial_chaos" code="{N_mdm(utype,methodName_MULTILEVEL_POLYNOMIAL_CHAOS)}" label="multilevel_polynomial_chaos" group="Uncertainty Quantification" >
	  &method_max_iterations;
	  &mlpce_alloc_control;
	  &method_exp_convergence_tolerance;
	  &discrep_emulation;
	  <!-- Note: there are some complex dependences here (e.g. RIP_SAMPLING requires compressed sensing) and unsupported cases when reusing general entities: enforce these in the C++ rather than overly specializing the XML -->
	  <oneOf label="Coefficient Computation Approach">
	    &pce_expansion_order_sequence;
	    &pce_orthog_least_interp_sequence;
	    <!-- &pce_expansion_import -->
	  </oneOf>
	  &pce_options;
	  &expansion_options;
          &method_seed_sequence;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="stoch_collocation" name="stoch_collocation" code="{N_mdm(utype,methodName_STOCH_COLLOCATION)}" label="stoch_collocation"  group="Uncertainty Quantification" >
	  <alias name="nond_stoch_collocation"/>
	  &sc_refinement;
	  &method_exp_convergence_tolerance;
	  <oneOf label="Interpolation Grid Type">
	    &expansion_quadrature;
	    &sc_sparse_grid;
	  </oneOf>
	  &sc_options;
	  &expansion_options;
          &method_seed;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multifidelity_stoch_collocation" name="multifidelity_stoch_collocation" code="{N_mdm(utype,methodName_MULTIFIDELITY_STOCH_COLLOCATION)}" label="multifidelity_stoch_collocation"  group="Uncertainty Quantification" >
	  &sc_refinement;
	  &method_mf_exp_convergence_tolerance;
	  &mf_alloc_control;
	  &discrep_emulation;
	  <oneOf label="Interpolation Grid Type">
	    &expansion_quadrature_sequence;
	    &sc_sparse_grid_sequence;
	  </oneOf>
	  &sc_options;
	  &expansion_options;
          &method_seed_sequence;
	  <!-- &method_max_iterations; for future multilevel SC -->
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="sampling" name="sampling" code="{N_mdm(utype,methodName_RANDOM_SAMPLING)}" label="Nondeterministic sampling method"  group="Uncertainty Quantification" >
	  <alias name="nond_sampling"/>
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="(initial) samples"  minOccurs="0" default="0">
	    <alias name="initial_samples" />
	    <param type="INTEGER" />
	  </keyword>
	  &method_seed;
	  <!-- BMA: May want to restore these if it's a helper iterator, e.g., for subspace methods
	       &method_max_iterations;
	       &method_convergence_tolerance;
	    -->
	  &method_sample_type;
	  <keyword  id="refinement_samples" name="refinement_samples" code="{N_mdm(ivec,refineSamples)}" label="Refinement samples"  minOccurs="0" >
	    <param type="INTEGERLIST" />
	  </keyword>
	  <keyword  id="d_optimal" name="d_optimal" code="{N_mdm(true,dOptimal)}" label="D-Optimal Sample Design"  minOccurs="0" default="off">
	    <optional>
	      <oneOf label="Design Strategy">
		<keyword  id="candidate_designs" name="candidate_designs" code="{N_mdm(sizet,numCandidateDesigns)}" label="Number of Candidate Designs"  default="100" >
		  <param type="INTEGER" constraint="> 0" />
		</keyword>
		<keyword  id="leja_oversample_ratio" name="leja_oversample_ratio" code="{N_mdm(Real,collocationRatio)}" label="Leja oversampling ratio"  default="10.0" >
		  <param type="REAL" />
		</keyword>
	      </oneOf>
	    </optional>
	  </keyword>
	  <keyword  id="variance_based_decomp2" name="variance_based_decomp" code="{N_mdm(true,vbdFlag)}" label="variance_based_decomp"  minOccurs="0" default="no variance-based decomposition" >
	    <keyword  id="drop_tolerance2" name="drop_tolerance" code="{N_mdm(Real,vbdDropTolerance)}" label="drop_tolerance"  minOccurs="0" default="All VBD indices displayed" >
	      <param type="REAL" />
	    </keyword>
	  </keyword>
	  <keyword  id="backfill1" name="backfill" code="{N_mdm(true,backfillFlag)}" label="backfill"  minOccurs="0" >
	  </keyword>
	  <keyword  id="principal_comp" name="principal_components" code="{N_mdm(true,pcaFlag)}" label="principal_comp"  minOccurs="0" >
	    <keyword  id="perc_var_explained" name="percent_variance_explained" code="{N_mdm(Real,percentVarianceExplained)}" label="percent_variance_explained"  minOccurs="0" >
	      <param type="REAL" />
	    </keyword>
	  </keyword>
	  <keyword  id="wilks" name="wilks" code="{N_mdm(true,wilksFlag)}" label="wilks"  minOccurs="0" >
	    <keyword  id="order" name="order" code="{N_mdm(ushint,wilksOrder)}" label="order"  minOccurs="0" >
              <param type="INTEGER" />
	    </keyword>
	    <keyword  id="confidence_level" name="confidence_level" code="{N_mdm(Real,wilksConfidenceLevel)}" label="confidence_level"  minOccurs="0" >
	      <param type="REAL" />
	    </keyword>
            <keyword  id="one_sidedlower" name="one_sided_lower" code="{N_mdm(type,wilksSidedInterval_ONE_SIDED_LOWER)}" label="one_sided_lower"  minOccurs="0" />
            <keyword  id="one_sidedupper" name="one_sided_upper" code="{N_mdm(type,wilksSidedInterval_ONE_SIDED_UPPER)}" label="one_sided_upper"  minOccurs="0" />
            <keyword  id="two_sided" name="two_sided" code="{N_mdm(type,wilksSidedInterval_TWO_SIDED)}" label="two_sided"  minOccurs="0" />
	  </keyword>
	  <keyword  id="std_regression_coeffs" name="std_regression_coeffs" code="{N_mdm(true,stdRegressionCoeffs)}" label="std_regression_coeffs"  minOccurs="0" >
	  </keyword>
	  <keyword  id="tolerance_intervals" name="tolerance_intervals" code="{N_mdm(true,toleranceIntervalsFlag)}" label="Compute tolerance intervals"  minOccurs="0" >
	    <keyword  id="ti_coverage" name="coverage" code="{N_mdm(Real01,tiCoverage)}" label="Coverage for tolerance intervals"  minOccurs="0" maxOccurs="1" default="0.95" >
              <param type="REAL" />
	    </keyword>
	    <keyword  id="ti_confidence_level" name="confidence_level" code="{N_mdm(Real01,tiConfidenceLevel)}" label="Confidence level for tolerance intervals"  minOccurs="0" maxOccurs="1" default="0.90" >
	      <param type="REAL" />
	    </keyword>
	  </keyword>
	  &default_final_moments;
	  &level_mappings;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multilevel_sampling" name="multilevel_sampling" code="{N_mdm(utype,methodName_MULTILEVEL_SAMPLING)}" label="multilevel_sampling"  group="Uncertainty Quantification" >
	  <alias name="multilevel_mc"/>
	  <alias name="mlmc"/>
	  &method_seed_sequence;
	  &mc_pilot_samples;
	  &mc_solution_mode;
	  &method_sample_type_lhs_mc;
	  <keyword  id="export_sample_sequence" name="export_sample_sequence" code="{N_mdm(true,exportSampleSeqFlag)}" label="export_sample_sequence"  minOccurs="0" >
	    &method_export_samples_format;
	  </keyword>
	  <keyword  id="allocation_target" name="allocation_target" code="{0}" label="Target for controlling sample allocation"  minOccurs="0" default="mean" >
	    <oneOf label="Allocation target">
	      <keyword  id="mean" name="mean" code="{N_mdm(type,allocationTarget_TARGET_MEAN)}" label="mean"  />
	      <keyword  id="variance" name="variance" code="{N_mdm(type,allocationTarget_TARGET_VARIANCE)}" label="variance">
		<keyword  id="optimization" name="optimization" code="{N_mdm(true,useTargetVarianceOptimizationFlag)}" label="optimization"  minOccurs="0" />
	      </keyword>
	      <keyword  id="standard_deviation" name="standard_deviation" code="{N_mdm(type,allocationTarget_TARGET_SIGMA)}" label="standard_deviation">
		<keyword  id="optimization" name="optimization" code="{N_mdm(true,useTargetVarianceOptimizationFlag)}" label="optimization"  minOccurs="0" />
	      </keyword>
	      <keyword  id="scalarization" name="scalarization" code="{N_mdm(type,allocationTarget_TARGET_SCALARIZATION)}" label="scalarization">
		<keyword  id="scalarization_response_mapping" name="scalarization_response_mapping" code="{N_mdm(RealDL,scalarizationRespCoeffs)}" label="Scalarization Response Mappings"  minOccurs="0" default="default scalarized contribution to mlmc sample allocation (1 Mean, 3 Sigma)" >
		  <param type="REALLIST" />
		</keyword>
		<keyword  id="optimization" name="optimization" code="{N_mdm(true,useTargetVarianceOptimizationFlag)}" label="optimization"  minOccurs="0" />
	      </keyword>
	    </oneOf>
	  </keyword>
	  <keyword  id="qoi_aggregation" name="qoi_aggregation" code="{0}" label="Rule of aggregating the variance and computing the sample allocation over qoi"  minOccurs="0" default="sum" >
	    <oneOf label="Qoi Aggregation ">
	      <keyword  id="sum" name="sum" code="{N_mdm(type,qoiAggregation_QOI_AGGREGATION_SUM)}" label="sum"   />
	      <keyword  id="max" name="max" code="{N_mdm(type,qoiAggregation_QOI_AGGREGATION_MAX)}" label="max"   />
	    </oneOf>
	  </keyword>
	  &method_convergence_tolerance;
	  <keyword  id="convergence_tolerance_type" name="convergence_tolerance_type" code="{0}" label="Type of convergence tolerance"  minOccurs="0" default="relative" >
            <oneOf label="Convergence tolerance type">
	      <keyword  id="relative" name="relative" code="{N_mdm(type,convergenceToleranceType_CONVERGENCE_TOLERANCE_TYPE_RELATIVE)}" label="relative"   />
	      <keyword  id="absolute" name="absolute" code="{N_mdm(type,convergenceToleranceType_CONVERGENCE_TOLERANCE_TYPE_ABSOLUTE)}" label="absolute"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="convergence_tolerance_target" name="convergence_tolerance_target" code="{0}" label="Target of convergence tolerance"  minOccurs="0" default="variance_constraint" >
            <oneOf label="Convergence tolerance target">
	      <keyword  id="variance_constraint" name="variance_constraint" code="{N_mdm(type,convergenceToleranceTarget_CONVERGENCE_TOLERANCE_TARGET_VARIANCE_CONSTRAINT)}" label="variance_constraint"   />
	      <keyword  id="cost_constraint" name="cost_constraint" code="{N_mdm(type,convergenceToleranceTarget_CONVERGENCE_TOLERANCE_TARGET_COST_CONSTRAINT)}" label="cost_constraint"   />
	    </oneOf>
	  </keyword>
	  &method_max_iterations;
          &method_max_function_evaluations;
	  &final_stats_perf_res;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multifidelity_sampling" name="multifidelity_sampling" code="{N_mdm(utype,methodName_MULTIFIDELITY_SAMPLING)}" label="multifidelity_sampling"  group="Uncertainty Quantification" >
	  <alias name="multifidelity_mc"/>
	  <alias name="mfmc"/>
	  &method_seed_sequence;
	  &mc_pilot_samples;
	  &mc_solution_mode;
	  &mfmc_numerical_solve;
	  &method_sample_type_lhs_mc;
	  <keyword  id="export_sample_sequence" name="export_sample_sequence" code="{N_mdm(true,exportSampleSeqFlag)}" label="export_sample_sequence"  minOccurs="0" >
	    &method_export_samples_format;
	  </keyword>
	  &method_convergence_tolerance;
	  &method_max_iterations;
          &method_max_function_evaluations;
	  &final_stats_perf_res;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="multilevel_multifidelity_sampling" name="multilevel_multifidelity_sampling" code="{N_mdm(utype,methodName_MULTILEVEL_MULTIFIDELITY_SAMPLING)}" label="multilevel_multifidelity_sampling"  group="Uncertainty Quantification" >
	  <alias name="multilevel_multifidelity_mc"/>
	  <alias name="mlmfmc"/>
	  &method_seed_sequence;
	  &mc_pilot_samples;
	  &mc_solution_mode;
	  &method_sample_type_lhs_mc;
	  <keyword  id="export_sample_sequence" name="export_sample_sequence" code="{N_mdm(true,exportSampleSeqFlag)}" label="export_sample_sequence"  minOccurs="0" >
	    &method_export_samples_format;
	  </keyword>
	  &method_convergence_tolerance;
	  &method_max_iterations;
          &method_max_function_evaluations;
	  &final_stats_perf_res;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="approximate_control_variate" name="approximate_control_variate" code="{N_mdm(utype,methodName_APPROXIMATE_CONTROL_VARIATE)}" label="approximate_control_variate"  group="Uncertainty Quantification" >
	  <alias name="acv_sampling"/>
	  <oneOf label="Solution Approach">
	    <keyword  id="acv_independent_sampling" name="acv_independent_sampling" code="{N_mdm(utype,subMethod_SUBMETHOD_ACV_IS)}" label="acv_independent_sampling" >
	      <alias name="acv_is"/>
	    </keyword>
	    <keyword  id="acv_multifidelity" name="acv_multifidelity" code="{N_mdm(utype,subMethod_SUBMETHOD_ACV_MF)}" label="acv_multifidelity" >
	      <alias name="acv_mf"/>
	    </keyword>
	    <keyword  id="acv_recursive_diff" name="acv_recursive_diff" code="{N_mdm(utype,subMethod_SUBMETHOD_ACV_RD)}" label="acv_recursive_diff" >
	      <alias name="acv_rd"/>
	    </keyword>
	  </oneOf>
	  <keyword  id="search_model_graphs" name="search_model_graphs" code="{0}" label="search_model_graph" minOccurs="0" default="NO_GRAPH_RECURSION" >
	    <keyword  id="model_selection" name="model_selection" code="{N_mdm(type,modelSelectType_ALL_MODEL_COMBINATIONS)}" label="model_selection" minOccurs="0" />
	    <oneOf label="DAG Ensemble Generation Option">
	      <keyword  id="kl_recursion" name="kl_recursion" code="{N_mdm(type,dagRecursionType_KL_GRAPH_RECURSION)}" label="kl_recursion" />
	      <keyword  id="partial_recursion" name="partial_recursion" code="{N_mdm(type,dagRecursionType_PARTIAL_GRAPH_RECURSION)}" label="partial_recursion" >
		<keyword  id="depth_limit" name="depth_limit" code="{N_mdm(ushint,dagDepthLimit)}" label="depth_limit" >
		  <param type="INTEGER" />
		</keyword>
	      </keyword>
	      <keyword  id="full_recursion" name="full_recursion" code="{N_mdm(type,dagRecursionType_FULL_GRAPH_RECURSION)}" label="full_recursion" />
	    </oneOf>
	  </keyword>
	  &mc_pilot_samples;
	  &mc_solution_mode;
	  <!--
	  <keyword  id="constraints" name="constraints" code="{0}" label="constraints" >
	    <oneOf label="Additional ACV solver constraints">
	  -->
	      <keyword  id="truth_fixed_by_pilot" name="truth_fixed_by_pilot" code="{N_mdm(true,truthPilotConstraint)}" label="truth_fixed_by_pilot" minOccurs="0" />
	  <!--
	    </oneOf>
	  </keyword>
	  -->
	  &method_gradient_sub_problem_solver;
	  &method_seed_sequence;
	  &method_sample_type_lhs_mc;
	  <keyword  id="export_sample_sequence" name="export_sample_sequence" code="{N_mdm(true,exportSampleSeqFlag)}" label="export_sample_sequence"  minOccurs="0" >
	    &method_export_samples_format;
	  </keyword>
	  &method_convergence_tolerance;
	  &method_max_iterations;
          &method_max_function_evaluations;
	  &final_stats_perf_res;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="importance_sampling" name="importance_sampling" code="{N_mdm(utype,methodName_IMPORTANCE_SAMPLING)}" label="importance_sampling"  group="Uncertainty Quantification" >
	  <alias name="nond_importance_sampling"/>
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="(initial) samples"  minOccurs="0" default="0">
	    <alias name="initial_samples" />
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed6" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  <oneOf label="Importance Sampling Approach">
	    <keyword  id="import2" name="import" code="{N_mdm(utype,integrationRefine_IS)}" label="import"   />
	    <keyword  id="adapt_import2" name="adapt_import" code="{N_mdm(utype,integrationRefine_AIS)}" label="adapt_import"   />
	    <keyword  id="mm_adapt_import2" name="mm_adapt_import" code="{N_mdm(utype,integrationRefine_MMAIS)}" label="mm_adapt_import"   />
	  </oneOf>
	  <keyword  id="refinement_samples2" name="refinement_samples" code="{N_mdm(ivec,refineSamples)}" label="refinement_samples"  minOccurs="0" >
	    <param type="INTEGERLIST" />
	  </keyword>
	  &method_max_iterations;
	  &method_convergence_tolerance;
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="gpais" name="gpais" code="{N_mdm(utype,methodName_GPAIS)}" label="gpais"  group="Uncertainty Quantification" >
	  <alias name="gaussian_process_adaptive_importance_sampling"/>
	  <keyword  id="build_samples4" name="build_samples" code="{N_mdm(int,buildSamples)}" label="Samples to build emulator"  minOccurs="0" >
	    <alias name="samples" />
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  <keyword  id="samples_on_emulator3" name="samples_on_emulator" code="{N_mdm(int,samplesOnEmulator)}" label="Samples on emulator"  minOccurs="0" default="10000">
	    <param type="INTEGER" />
	  </keyword>
	  &import_build;
	  <keyword  id="export_approx_points_file3" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="File name for exporting approximation-based samples from evaluating the emulator"  minOccurs="0" default="no point export to a file" >
	    <alias name="export_points_file"/>
	    <param type="OUTPUT_FILE" />
	    &method_export_approx_format;
	  </keyword>
	  &method_max_iterations;
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="adaptive_sampling" name="adaptive_sampling" code="{N_mdm(utype,methodName_ADAPTIVE_SAMPLING)}" label="adaptive_sampling"  group="Uncertainty Quantification" >
	  <alias name="nond_adaptive_sampling"/>
	  <keyword  id="initial_samples" name="initial_samples" code="{N_mdm(int,numSamples)}" label="initial samples"  minOccurs="0" default="0">
	    <alias name="samples" />
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed6" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  <keyword  id="samples_on_emulator4" name="samples_on_emulator" code="{N_mdm(int,samplesOnEmulator)}" label="Number of samples on the emulator to generate a new true sample each iteration"  minOccurs="0" default="400" >
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="fitness_metric" name="fitness_metric" code="{0}" label="Fitness metric"  minOccurs="0" default="predicted_variance" >
	    <oneOf label="Fitness Metric">
	      <keyword  id="predicted_variance" name="predicted_variance" code="{N_mdm(lit,fitnessMetricType_predicted_variance)}" label="predicted_variance"   />
	      <keyword  id="distance1" name="distance" code="{N_mdm(lit,fitnessMetricType_distance)}" label="distance"   />
	      <keyword  id="gradient" name="gradient" code="{N_mdm(lit,fitnessMetricType_gradient)}" label="gradient"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="batch_selection" name="batch_selection" code="{0}" label="Batch selection strategy"  minOccurs="0" default="naive" >
	    <oneOf label="Batch Selection Criterion">
	      <keyword  id="naive" name="naive" code="{N_mdm(lit,batchSelectionType_naive)}" label="naive"   />
	      <keyword  id="distance_penalty" name="distance_penalty" code="{N_mdm(lit,batchSelectionType_distance)}" label="distance_penalty"   />
	      <keyword  id="topology" name="topology" code="{N_mdm(lit,batchSelectionType_topology)}" label="topology"   />
	      <keyword  id="constant_liar" name="constant_liar" code="{N_mdm(lit,batchSelectionType_cl)}" label="constant_liar"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="refinement_samples" name="refinement_samples" code="{N_mdm(ivec,refineSamples)}" label="Refinement samples per iteration"  minOccurs="0" >
	    <param type="INTEGERLIST" />
	  </keyword>
	  &import_build;
	  <keyword  id="export_approx_points_file4" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="File name for exporting approximation-based samples from evaluating the GP"  minOccurs="0" default="no point export to a file" >
	    <alias name="export_points_file"/>
	    <param type="OUTPUT_FILE" />
	    &method_export_approx_format;
	  </keyword>
	  <keyword  id="misc_options2" name="misc_options" code="{N_mdm(strL,miscOptions)}" label="misc_options"  minOccurs="0" default="no misc options" >
	    <param type="STRINGLIST" />
	  </keyword>
	  &method_max_iterations;
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="pof_darts" name="pof_darts" code="{N_mdm(utype,methodName_POF_DARTS)}" label="pof_darts"  group="Uncertainty Quantification" >
	  <alias name="nond_pof_darts"/>
	  <keyword  id="build_samples4" name="build_samples" code="{N_mdm(int,buildSamples)}" label="Samples to build emulator"   >
	    <alias name="samples" />
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  <keyword  id="lipschitz" name="lipschitz" code="{0}" label="Lipschitz"  minOccurs="0" >
	    <oneOf label="Local/Global Estimate">
	      <keyword  id="local_est" name="local" code="{N_mdm(lit,lipschitzType_local)}" label="local_est"   />
	      <keyword  id="global_est" name="global" code="{N_mdm(lit,lipschitzType_global)}" label="global_est"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="samples_on_emulator5" name="samples_on_emulator" code="{N_mdm(int,samplesOnEmulator)}" label="Samples on emulator"  minOccurs="0" >
	    <param type="INTEGER" />
	  </keyword>
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="rkd_darts" name="rkd_darts" code="{N_mdm(utype,methodName_RKD_DARTS)}" label="rkd_darts"   group="Uncertainty Quantification">
	  <alias name="nond_rkd_darts"/>
	  <keyword  id="build_samples4" name="build_samples" code="{N_mdm(int,buildSamples)}" label="Samples to build emulator"   >
	    <alias name="samples" />
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  <keyword  id="lipschitz" name="lipschitz" code="{0}" label="Lipschitz"  minOccurs="0" >
	    <oneOf label="Local/Global Estimate">
	      <keyword  id="local_est" name="local" code="{N_mdm(lit,lipschitzType_local)}" label="local_est"   />
	      <keyword  id="global_est" name="global" code="{N_mdm(lit,lipschitzType_global)}" label="global_est"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="samples_on_emulator6" name="samples_on_emulator" code="{N_mdm(int,samplesOnEmulator)}" label="Samples on emulator"  minOccurs="0" >
	    <param type="INTEGER" />
	  </keyword>
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<!-- BMA TODO: not clear what the right samples spec is for evidence -->
	<keyword  id="global_evidence" name="global_evidence" code="{N_mdm(utype,methodName_GLOBAL_EVIDENCE)}" label="global_evidence"  group="Uncertainty Quantification" >
	  <alias name="nond_global_evidence"/>
	  <keyword  id="samples4" name="samples" code="{N_mdm(int,numSamples)}" label="samples" minOccurs="0"   >
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  &method_global_sub_problem_solver;
	  &level_mappings_no_rel;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

        <keyword  id="global_interval_est" name="global_interval_est" code="{N_mdm(utype,methodName_GLOBAL_INTERVAL_EST)}" label="global_interval_est"  group="Uncertainty Quantification" >
	  <alias name="nond_global_interval_est"/>
	  <!-- BMA TODO: not clear what the right spec is for interval -->
	  <keyword  id="samples4" name="samples" code="{N_mdm(int,numSamples)}" label="samples"  minOccurs="0" >
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  &method_max_iterations;
	  &method_convergence_tolerance;
	  &method_max_function_evaluations;
	  &method_global_sub_problem_solver;
	  &rng_options;
	  &method_optional_model_pointer;
	</keyword>

	<!-- BEGIN Bayesian Calibration -->
	<keyword  id="bayes_calibration" name="bayes_calibration" code="{N_mdm(utype,methodName_BAYES_CALIBRATION)}" label="Bayesian calibration "  group="Calibration" >
	  <alias name="nond_bayes_calibration"/>
	  <oneOf label="Bayesian Calibration Method">
	    <keyword  id="queso" name="queso" code="{N_mdm(utype,subMethod_SUBMETHOD_QUESO)}" label="queso"  >
	      <keyword  id="chain_samples" name="chain_samples" code="{N_mdm(int,chainSamples)}" label="MCMC chain samples"  default="method-dependent">
		<alias name="samples" />
		<param type="INTEGER" />
	      </keyword>
	      &bayes_seed_rng;
	      &bayes_emulator;
	      <keyword  id="standardized_space" name="standardized_space" code="{N_mdm(true,standardizedSpace)}" label="standardized_space"  minOccurs="0" />
	      <keyword  id="logit_transform" name="logit_transform" code="{N_mdm(true,logitTransform)}" label="logit_transform"  minOccurs="0" />
	      <keyword  id="export_chain_points_file" name="export_chain_points_file" code="{N_mdm(str,exportMCMCPtsFile)}" label="File export of MCMC acceptance chain"  minOccurs="0" default="chain export to default filename" >
		<param type="OUTPUT_FILE" />
		&method_export_samples_format;
	      </keyword>
	      <optional>
		<oneOf label="MCMC Algorithm" >
		  <keyword  id="dram" name="dram" code="{N_mdm(lit,mcmcType_dram)}" label="dram"  default="dram" />
		  <keyword  id="delayed_rejection" name="delayed_rejection" code="{N_mdm(lit,mcmcType_delayed_rejection)}" label="delayed_rejection"  default="dram" />
		  <keyword  id="adaptive_metropolis" name="adaptive_metropolis" code="{N_mdm(lit,mcmcType_adaptive_metropolis)}" label="adaptive_metropolis"  default="dram" />
		  <keyword  id="metropolis_hastings" name="metropolis_hastings" code="{N_mdm(lit,mcmcType_metropolis_hastings)}" label="metropolis_hastings"  default="dram" />
		  <keyword  id="multilevel" name="multilevel" code="{N_mdm(lit,mcmcType_multilevel)}" label="multilevel"  default="dram" />
		</oneOf>
	      </optional>
	      <keyword  id="pre_solve" name="pre_solve" code="{0}" label="pre_solve"  minOccurs="0" default="nip pre-solve for emulators" >
		<oneOf label="Pre-solve Optimizer">
		  <keyword  id="sqp1" name="sqp" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_NPSOL)}" label="sqp"   />
		  <keyword  id="nip" name="nip" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_OPTPP)}" label="nip"   />
		  <keyword  id="none" name="none" code="{N_mdm(utype,optSubProbSolver_SUBMETHOD_NONE)}" label="none"   />
		</oneOf>
	      </keyword>
	      &bayes_proposal_covariance;
	      <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		<param type="INPUT_FILE" />
	      </keyword>
	    </keyword>
	    <keyword  id="gpmsa" name="gpmsa" code="{N_mdm(utype,subMethod_SUBMETHOD_GPMSA)}" label="gpmsa"  >
	      <keyword  id="chain_samples" name="chain_samples" code="{N_mdm(int,chainSamples)}" label="MCMC chain samples"  default="method-dependent">
		<alias name="samples" />
		<param type="INTEGER" />
	      </keyword>
	      &bayes_seed_rng;
	      <keyword  id="build_samples4" name="build_samples" code="{N_mdm(int,buildSamples)}" label="Samples to build emulator"   >
		<param type="INTEGER" />
	      </keyword>
	      <keyword  id="import_build_points_file9" name="import_build_points_file" code="{N_mdm(str,importBuildPtsFile)}" label="import_build_points_file"  minOccurs="0" default="no point import from a file" >
		<alias name="import_points_file"/>
		<param type="INPUT_FILE" />
		&method_import_build_format;
		<!-- Disable active_only, until we can set the config vars to their nominal value; for now import must include any active config vars as well...

		     <keyword  id="active_only11" name="active_only" code="{N_mdm(true,importBuildActive)}" label="Active variables only"  minOccurs="0" />
		     -->
	      </keyword>
	      <keyword  id="standardized_space" name="standardized_space" code="{N_mdm(true,standardizedSpace)}" label="standardized_space"  minOccurs="0" />
	      <keyword  id="logit_transform" name="logit_transform" code="{N_mdm(true,logitTransform)}" label="logit_transform"  minOccurs="0" />
	      <keyword  id="gpmsa_normalize" name="gpmsa_normalize" code="{N_mdm(true,gpmsaNormalize)}" label="Apply GPMSA normalization"  minOccurs="0" />
	      <keyword  id="export_chain_points_file" name="export_chain_points_file" code="{N_mdm(str,exportMCMCPtsFile)}" label="File export of MCMC acceptance chain"  minOccurs="0" default="chain export to default filename" >
		<param type="OUTPUT_FILE" />
		&method_export_samples_format;
	      </keyword>
	      <optional>
		<oneOf label="MCMC Algorithm" >
		  <keyword  id="dram" name="dram" code="{N_mdm(lit,mcmcType_dram)}" label="dram"  default="dram" />
		  <keyword  id="delayed_rejection" name="delayed_rejection" code="{N_mdm(lit,mcmcType_delayed_rejection)}" label="delayed_rejection"  default="dram" />
		  <keyword  id="adaptive_metropolis" name="adaptive_metropolis" code="{N_mdm(lit,mcmcType_adaptive_metropolis)}" label="adaptive_metropolis"  default="dram" />
		  <keyword  id="metropolis_hastings" name="metropolis_hastings" code="{N_mdm(lit,mcmcType_metropolis_hastings)}" label="metropolis_hastings"  default="dram" />
		  <!--
		      <keyword  id="multilevel" name="multilevel" code="{N_mdm(lit,mcmcType_multilevel)}" label="multilevel"  default="dram" />
		      -->
		</oneOf>
	      </optional>
	      &bayes_proposal_covariance;
	      <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		<param type="INPUT_FILE" />
	      </keyword>
	    </keyword>
	    <keyword  id="wasabi" name="wasabi" code="{N_mdm(utype,subMethod_SUBMETHOD_WASABI)}" label="wasabi"  >
	      <keyword  id="pushforward_samples" name="pushforward_samples" code="{N_mdm(int,numPushforwardSamples)}" label="Number of Samples from the Prior that are pushed forward through the model"  default="method-dependent">
		<param type="INTEGER" />
	      </keyword>
	      <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
		<param type="INTEGER" constraint="> 0" />
	      </keyword>
	      &bayes_emulator;
	      <keyword  id="standardized_space" name="standardized_space" code="{N_mdm(true,standardizedSpace)}" label="standardized_space"  minOccurs="0" />		  
	      <keyword  id="data_distribution" name="data_distribution" label="Data distribution type"  code="{0}">
		<oneOf label="Data Distribution">
		  <keyword  id="gaussian" name="gaussian" code="{0}" label="gaussian"  >
		    <keyword  id="means" name="means" code="{N_mdm(RealDL,dataDistMeans)}" label="User-provided proposal means of gaussian dist on data"  >
		      <param type="REALLIST"/>
		    </keyword>
		    <keyword  id="covariance" name="covariance" code="{N_mdm(RealDL,dataDistCovariance)}" label="User-provided proposal covariance of gaussian dist on data"  >
		      <param type="REALLIST"/>
		      <oneOf label="Values For">
			<keyword  id="diagonal" name="diagonal" code="{N_mdm(lit,dataDistCovInputType_diagonal)}" label="Diagonal data distribution covariance input"  />
			<keyword  id="matrix" name="matrix" code="{N_mdm(lit,dataDistCovInputType_matrix)}" label="Matrix data distribution covariance input"  />
		      </oneOf>
		    </keyword>
		  </keyword>
		  <keyword  id="obs_data_filename" name="obs_data_filename" code="{N_mdm(str,dataDistFile)}" label="User-provided data to build distribution on data"  >
		    <param type="INPUT_FILE"/>
		  </keyword>
		</oneOf>
	      </keyword>
	      <keyword id="posterior_samples_import_filename" name="posterior_samples_import_filename" code="{N_mdm(str,posteriorSamplesImportFilename)}" label="Filename containing samples at which to evaluate the posterior density"  minOccurs="0"> <param type="INPUT_FILE"/> </keyword>
	      <keyword id="generate_posterior_samples" name="generate_posterior_samples" code="{N_mdm(true,generatePosteriorSamples)}" label="Flag specifying whether to generate samples from the posterior"  minOccurs="0">
	      <keyword id="posterior_samples_export_filename" name="posterior_samples_export_filename" code="{N_mdm(str,posteriorSamplesExportFilename)}" label="Filename to which samples from posterior will be written"  minOccurs="0"> <param type="OUTPUT_FILE"/> </keyword>
	      </keyword>
	      <keyword id="evaluate_posterior_density" name="evaluate_posterior_density" code="{N_mdm(true,evaluatePosteriorDensity)}" label="Flag specifying whether to evaluate the posterior density at a set of samples"  minOccurs="0">
	      <keyword id="posterior_density_export_filename" name="posterior_density_export_filename" code="{N_mdm(str,posteriorDensityExportFilename)}" label="Filename to which posterior density evaluations will be written"  minOccurs="0"> <param type="OUTPUT_FILE"/> </keyword>
	      </keyword>
	    </keyword>
	    <keyword  id="dream" name="dream" code="{N_mdm(utype,subMethod_SUBMETHOD_DREAM)}" label="dream"  >
	      <keyword  id="chain_samples" name="chain_samples" code="{N_mdm(int,chainSamples)}" label="MCMC chain samples"  default="method-dependent">
		<alias name="samples" />
		<param type="INTEGER" />
	      </keyword>
	      <keyword  id="seed7" name="seed" code="{N_mdm(int,randomSeed)}" label="seed"  minOccurs="0" default="system-generated (non-repeatable)" >
		<param type="INTEGER" constraint="> 0" />
	      </keyword>
	      <keyword  id="chains" name="chains" code="{N_mdm(int,numChains)}" label="Number of chains"  minOccurs="0" default="3" >
		<param type="INTEGER" constraint=">= 3" />
	      </keyword>
	      <keyword  id="num_cr" name="num_cr" code="{N_mdm(int,numCR)}" label="Number of candidate points used in burn-in adaptation"  minOccurs="0" default="1" >
		<param type="INTEGER" constraint=">= 1" />
	      </keyword>
	      <keyword  id="crossover_chain_pairs" name="crossover_chain_pairs" code="{N_mdm(int,crossoverChainPairs)}" label="Number of chain pairs used in crossover "  minOccurs="0" default="3" >
		<param type="INTEGER" constraint=">= 0" />
	      </keyword>
	      <keyword  id="gr_threshold" name="gr_threshold" code="{N_mdm(Real,grThreshold)}" label="Gelman-Rubin Threshold for convergence"  minOccurs="0" default="1.2" >
		<param type="REAL" constraint="> 0.0" />
	      </keyword>
	      <keyword  id="jump_step" name="jump_step" code="{N_mdm(int,jumpStep)}" label="Jump-Step "  minOccurs="0" default="5" >
		<param type="INTEGER" constraint=">= 0" />
	      </keyword>
	      &bayes_emulator;
	      <keyword  id="standardized_space" name="standardized_space" code="{N_mdm(true,standardizedSpace)}" label="standardized_space"  minOccurs="0" />
	      <keyword  id="export_chain_points_file" name="export_chain_points_file" code="{N_mdm(str,exportMCMCPtsFile)}" label="File export of MCMC acceptance chain"  minOccurs="0" default="chain export to default filename" >
		<param type="OUTPUT_FILE" />
		&method_export_samples_format;
	      </keyword>
	    </keyword>
	    <keyword  id="muq" name="muq" code="{N_mdm(utype,subMethod_SUBMETHOD_MUQ)}" label="muq"  minOccurs="1" >
	      <keyword  id="chain_samples" name="chain_samples" code="{N_mdm(int,chainSamples)}" label="MCMC chain samples"  default="method-dependent">
		<alias name="samples" />
		<param type="INTEGER" />
	      </keyword>
	      &bayes_seed_rng;
	      <optional>
		<oneOf label="MCMC Algorithm" >
            <keyword  id="dram" name="dram" code="{N_mdm(lit,mcmcType_dram)}" label="dram"  default="dram" />
            <keyword  id="delayed_rejection" name="delayed_rejection" code="{N_mdm(lit,mcmcType_delayed_rejection)}" label="delayed_rejection"  default="dram" />
            <keyword  id="adaptive_metropolis" name="adaptive_metropolis" code="{N_mdm(lit,mcmcType_adaptive_metropolis)}" label="adaptive_metropolis"  default="dram" />
            <keyword  id="metropolis_hastings" name="metropolis_hastings" code="{N_mdm(lit,mcmcType_metropolis_hastings)}" label="metropolis_hastings"  default="dram" />
		</oneOf>
	      </optional>
          &bayes_proposal_covariance;
	    </keyword>
	  </oneOf>
	  <keyword  id="experimental_design" name="experimental_design" code="{N_mdm(true,adaptExpDesign)}" label="Bayesian Experiment Design"  minOccurs="0" >
	    <keyword  id="initial_samples" name="initial_samples" code="{N_mdm(int,numSamples)}" label="Initial Hi-fi Samples"  default="method-dependent">
	      <alias name="samples" />
	      <param type="INTEGER" />
	    </keyword>
	    <!--&method_max_function_evaluations;-->
            <keyword  id="num_candidates" name="num_candidates" code="{N_mdm(sizet,numCandidates)}" label="Number of Candidates"  default="1" >
              <param type="INTEGER" constraint="> 0" />
            </keyword>
            <keyword  id="max_hifi_evaluations" name="max_hifi_evaluations" code="{N_mdm(int,maxHifiEvals)}" label="Maximum Number of Hi-Fi Model Evaluations"  minOccurs="0">
              <param type="INTEGER" constraint=">= 0" />
            </keyword>
  	    <keyword  id="batch_size" name="batch_size" code="{N_mdm(int,batchSize)}" label="Number of optimal experimental designs selected per iteration"  minOccurs="0" >
	      <param type="INTEGER" constraint=">= 1" />
  	    </keyword>
            <keyword  id="import_candidate_points_file" name="import_candidate_points_file" code="{N_mdm(str,importCandPtsFile)}" label="Filename for Candidate Point Import"  minOccurs="0" default="no point import from a file" >
              <param type="INPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,importCandFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,importCandFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,importCandFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,importCandFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,importCandFormat_TABULAR_ANNOTATED)}" label="annotated"   default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,importCandFormat_TABULAR_NONE)}" label="freeform"   />
		</oneOf>
	      </optional>
            </keyword>
	    <keyword id="ksg2" name="ksg2" code="{N_mdm(true,mutualInfoKSG2)}" minOccurs="0" />
	  </keyword>
	  <keyword  id="calibrate_error_multipliers" name="calibrate_error_multipliers" code="{0}" label="calibrate_error_multipliers"  minOccurs="0" default="none" >
	    <oneOf label="Calibrate Error Multipliers">
	      <keyword  id="one" name="one" code="{N_mdm(utype,calibrateErrorMode_CALIBRATE_ONE)}" label="one multiplier"   />
	      <keyword  id="per_experiment" name="per_experiment" code="{N_mdm(utype,calibrateErrorMode_CALIBRATE_PER_EXPER)}" label="multiplier per experiment"   />
	      <keyword  id="per_response" name="per_response" code="{N_mdm(utype,calibrateErrorMode_CALIBRATE_PER_RESP)}" label="multiplier per response"   />
	      <keyword  id="both" name="both" code="{N_mdm(utype,calibrateErrorMode_CALIBRATE_BOTH)}" label="multiplier for each experiment, response"   />
	    </oneOf>
	    <optional>
	      <keyword  id="hyperprior_alphas" name="hyperprior_alphas" code="{N_mdm(RealDL,hyperPriorAlphas)}" label="Inverse-gamma hyper-prior alphas"  >
		<param type="REALLIST"/>
	      </keyword>
	      <keyword  id="hyperprior_betas" name="hyperprior_betas" code="{N_mdm(RealDL,hyperPriorBetas)}" label="Inverse-gamma hyper-prior betas"  >
		<param type="REALLIST"/>
	      </keyword>
	    </optional>
	  </keyword>

	  <keyword  id="burn_in_samples" name="burn_in_samples" code="{N_mdm(int,burnInSamples)}" label="Burn-in samples"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
	  <keyword id="posterior_stats" name="posterior_stats" code="{0}" minOccurs="0">
	    <keyword id="kl_divergence" name="kl_divergence" code="{N_mdm(true,posteriorStatsKL)}" minOccurs="0" />
	    <keyword id="mutual_info" name="mutual_info" code="{N_mdm(true,posteriorStatsMutual)}" minOccurs="0" >
	      <keyword id="ksg2" name="ksg2" code="{N_mdm(true,mutualInfoKSG2)}" minOccurs="0" />
	    </keyword>
	    <keyword id="kde" name="kde" code="{N_mdm(true,posteriorStatsKDE)}" minOccurs="0" />
	  </keyword>
	  <keyword id="chain_diagnostics" name="chain_diagnostics" code="{N_mdm(true,chainDiagnostics)}" minOccurs="0">
	    <keyword id="confidence_intervals" name="confidence_intervals" code="{N_mdm(true,chainDiagnosticsCI)}" minOccurs="0" />
          </keyword>
          <keyword id="model_evidence" name="model_evidence" code="{N_mdm(true,modelEvidence)}" minOccurs="0">
	    <keyword id="mc_approx" name="mc_approx" code="{N_mdm(true,modelEvidMC)}" minOccurs="0" />
              <keyword  id="evidence_samples" name="evidence_samples" code="{N_mdm(int,evidenceSamples)}" label="Evidence samples"  minOccurs="0" >
	        <param type="INTEGER" />
              </keyword>
	    <keyword id="laplace_approx" name="laplace_approx" code="{N_mdm(true,modelEvidLaplace)}" minOccurs="0" />
          </keyword>
	  <keyword id="model_discrepancy" name="model_discrepancy" code="{N_mdm(true,calModelDiscrepancy)}" minOccurs="0" >
	    <keyword  id="discrepancy_type" name="discrepancy_type" code="{0}" label="Model Discrepancy Type"  minOccurs="0" default="gaussian process" >
    	      <oneOf label="Discrepancy Model">
    	        <keyword  id="gaussian_process" name="gaussian_process" code="{N_mdm(lit,modelDiscrepancyType_global_kriging)}" label="Discrepancy Type Gaussian Process" >
                  <alias name="kriging"/>
                  <keyword  id="trend_order" name="trend_order" code="{N_mdm(shint,polynomialOrder)}" label="GP trend polynomial order" minOccurs="0" default="2" >
                    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		</keyword>
		<keyword  id="polynomial" name="polynomial" code="{N_mdm(lit,modelDiscrepancyType_global_polynomial)}" label="Discrepancy Type Polynomial" >
                  <keyword  id="basis_order" name="basis_order" code="{N_mdm(shint,polynomialOrder)}" label="Polynomial basis order" minOccurs="0" default="2" >
                    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <!--
                  <oneOf label="Basis Order">
                    <keyword  id="basis_order" name="basis_order" code="{N_mdm(shint,polynomialOrder)}" label="Polynomial basis order"  >
                      <param type="INTEGER" constraint=">= 0" />
		    </keyword>
		    <keyword  id="constant" name="constant" code="{N_mdm(order,polynomialOrder_0)}" label="Polynomial Order 0"  />
                    <keyword  id="linear" name="linear" code="{N_mdm(order,polynomialOrder_1)}" label="Linear Polynomial"   />
                    <keyword  id="quadratic" name="quadratic" code="{N_mdm(order,polynomialOrder_2)}" label="Quadratic Polynomial"   />
                  </oneOf>
		  -->
    	        </keyword>
    	      </oneOf>
    	    </keyword>
            <keyword  id="num_prediction_configs" name="num_prediction_configs" code="{N_mdm(sizet,numPredConfigs)}" label="Number of Prediction Configurations"  minOccurs="0" default="0" >
              <param type="INTEGER" constraint=">= 0" />
            </keyword>
            <keyword  id="prediction_configs" name="prediction_configs" code="{N_mdm(RealDL,predictionConfigList)}" label="List of Prediction Configurations"  minOccurs="0" >
              <param type="REALLIST" />
	    </keyword>
            <keyword  id="import_prediction_configs" name="import_prediction_configs" code="{N_mdm(str,importPredConfigs)}" label="Filename for Prediction Configs"  minOccurs="0" default="no point import from a file" >
              <param type="INPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,importPredConfigFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,importPredConfigFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,importPredConfigFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,importPredConfigFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,importPredConfigFormat_TABULAR_ANNOTATED)}" label="annotated"   default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,importPredConfigFormat_TABULAR_NONE)}" label="freeform"   />
		</oneOf>
	      </optional>
            </keyword>
	    <keyword  id="export_discrepancy_file" name="export_discrepancy_file" code="{N_mdm(str,exportDiscrepFile)}" label="File export of model discrepancy values"  minOccurs="0" default="discrepancy export to default filename" >
	      <param type="OUTPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,exportDiscrepFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,exportDiscrepFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,exportDiscrepFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,exportDiscrepFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,exportDiscrepFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,exportDiscrepFormat_TABULAR_NONE)}" label="freeform"  default="annotated" />
		</oneOf>
	      </optional>
	    </keyword>
	    <keyword  id="export_corrected_model_file" name="export_corrected_model_file" code="{N_mdm(str,exportCorrModelFile)}" label="File export of corrected model values"  minOccurs="0" default="corrected model export to default filename" >
	      <param type="OUTPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,exportCorrModelFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,exportCorrModelFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,exportCorrModelFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,exportCorrModelFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,exportCorrModelFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,exportCorrModelFormat_TABULAR_NONE)}" label="freeform"  default="annotated" />
		</oneOf>
	      </optional>
	    </keyword>
	    <keyword  id="export_corrected_variance_file" name="export_corrected_variance_file" code="{N_mdm(str,exportCorrVarFile)}" label="File export of variance values of corrected model"  minOccurs="0" default="corrected model variance export to default filename" >
	      <param type="OUTPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
 		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,exportCorrVarFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,exportCorrVarFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,exportCorrVarFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,exportCorrVarFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,exportCorrVarFormat_TABULAR_ANNOTATED)}" label="annotated"  default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,exportCorrVarFormat_TABULAR_NONE)}" label="freeform"  default="annotated" />
		</oneOf>
	      </optional>
	    </keyword>
	  </keyword>
	  <keyword  id="sub_sampling_period" name="sub_sampling_period" code="{N_mdm(int,subSamplingPeriod)}" label="Chain sampling period for statistics"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
	  &probability_levels;
	  &method_convergence_tolerance;
	  &method_max_iterations;
	  &method_optional_model_pointer;
	  &default_scaling;
	</keyword>
	<!-- END Bayesian Calibration-->

        <!-- DACE Methods -->
	<keyword  id="dace" name="dace" code="{N_mdm(utype,methodName_DACE)}" label="dace"  group="[CHOOSE method category]DACE" >
	  <oneOf label="DACE type">
	    <keyword  id="grid" name="grid" code="{N_mdm(utype,subMethod_SUBMETHOD_GRID)}" label="grid"   />
	    <keyword  id="random4" name="random" code="{N_mdm(utype,subMethod_SUBMETHOD_RANDOM)}" label="random"   />
	    <keyword  id="oas" name="oas" code="{N_mdm(utype,subMethod_SUBMETHOD_OAS)}" label="oas"   />
	    <keyword  id="lhs5" name="lhs" code="{N_mdm(utype,subMethod_SUBMETHOD_LHS)}" label="lhs"   />
	    <keyword  id="oa_lhs" name="oa_lhs" code="{N_mdm(utype,subMethod_SUBMETHOD_OA_LHS)}" label="oa_lhs"   />
	    <keyword  id="box_behnken" name="box_behnken" code="{N_mdm(utype,subMethod_SUBMETHOD_BOX_BEHNKEN)}" label="box_behnken"   />
	    <keyword  id="central_composite" name="central_composite" code="{N_mdm(utype,subMethod_SUBMETHOD_CENTRAL_COMPOSITE)}" label="central_composite"   />
	  </oneOf>
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="samples"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
	  &method_seed;
	  <keyword  id="main_effects" name="main_effects" code="{N_mdm(true,mainEffectsFlag)}" label="Main effects"  minOccurs="0" default="No main_effects" />
	  <keyword  id="quality_metrics" name="quality_metrics" code="{N_mdm(true,volQualityFlag)}" label="Quality metrics"  minOccurs="0" default="No quality_metrics" />
	  <keyword  id="variance_based_decomp3" name="variance_based_decomp" code="{N_mdm(true,vbdFlag)}" label="Variance based decomposition"  minOccurs="0" default="no variance-based decomposition" >
	    <keyword  id="drop_tolerance3" name="drop_tolerance" code="{N_mdm(Real,vbdDropTolerance)}" label="drop_tolerance"  minOccurs="0" default="All VBD indices displayed" >
	      <param type="REAL" />
	    </keyword>
	  </keyword>
	  <keyword  id="symbols" name="symbols" code="{N_mdm(int,numSymbols)}" label="Number of symbols"  minOccurs="0" default="default for sampling algorithm" >
	    <param type="INTEGER" />
	  </keyword>
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="fsu_cvt" name="fsu_cvt" code="{N_mdm(utype,methodName_FSU_CVT)}" label="fsu_cvt"  group="DACE" >
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="samples"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
	  &method_seed;
	  <keyword  id="latinize" name="latinize" code="{N_mdm(true,latinizeFlag)}" label="Latinization of samples"  minOccurs="0" default="No latinization" />
	  <keyword  id="quality_metrics1" name="quality_metrics" code="{N_mdm(true,volQualityFlag)}" label="Quality metrics"  minOccurs="0" default="No quality_metrics" />
	  <keyword  id="variance_based_decomp4" name="variance_based_decomp" code="{N_mdm(true,vbdFlag)}" label="Variance based decomposition"  minOccurs="0" default="no variance-based decomposition" >
	    <keyword  id="drop_tolerance4" name="drop_tolerance" code="{N_mdm(Real,vbdDropTolerance)}" label="drop_tolerance"  minOccurs="0" default="All VBD indices displayed" >
	      <param type="REAL" />
	    </keyword>
	  </keyword>
	  <keyword  id="trial_type" name="trial_type" code="{0}" label="Trial type"  minOccurs="0" default="random" >
	    <oneOf label="Trial Type">
	      <keyword  id="grid1" name="grid" code="{N_mdm(lit,trialType_grid)}" label="grid"   />
	      <keyword  id="halton" name="halton" code="{N_mdm(lit,trialType_halton)}" label="halton"   />
	      <keyword  id="random5" name="random" code="{N_mdm(lit,trialType_random)}" label="random"   />
	    </oneOf>
	  </keyword>
	  <keyword  id="num_trials" name="num_trials" code="{N_mdm(int,numTrials)}" label="Number of trials  "  minOccurs="0" default="10000" >
	    <param type="INTEGER" />
	  </keyword>
	  &method_max_iterations;
	  &method_optional_model_pointer;
	</keyword>

	<keyword  id="psuade_moat" name="psuade_moat" code="{N_mdm(utype,methodName_PSUADE_MOAT)}" label="PSUADE MOAT method"  group="DACE" >
	  <keyword  id="partitions" name="partitions" code="{N_mdm(usharray,varPartitions)}" label="Number of partitions"  minOccurs="0" default="3" >
	    <param type="INTEGERLIST" />
	  </keyword>
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="samples"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="seed6" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
	    <param type="INTEGER" constraint="> 0" />
	  </keyword>
	  &method_optional_model_pointer;
	</keyword>

        <keyword  id="local_evidence" name="local_evidence" code="{N_mdm(utype,methodName_LOCAL_EVIDENCE)}" label="local_evidence"  group="Uncertainty Quantification" >
          <alias name="nond_local_evidence"/>
          &method_gradient_sub_problem_solver;
	  &level_mappings_no_rel;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="local_interval_est" name="local_interval_est" code="{N_mdm(utype,methodName_LOCAL_INTERVAL_EST)}" label="local_interval_est"  group="Uncertainty Quantification" >
          <alias name="nond_local_interval_est"/>
          &method_gradient_sub_problem_solver;
          &method_convergence_tolerance;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="local_reliability" name="local_reliability" code="{N_mdm(utype,methodName_LOCAL_RELIABILITY)}" label="Reliability method"  group="Uncertainty Quantification" >
          <alias name="nond_local_reliability"/>
          <keyword  id="mpp_search" name="mpp_search" code="{0}" label="MPP search type"  minOccurs="0" default="No MPP search (MV method)" >
            <oneOf label="MPP Approximation">
              <keyword  id="x_taylor_mean" name="x_taylor_mean" code="{N_mdm(utype,subMethod_SUBMETHOD_AMV_X)}" label="x_taylor_mean"   />
              <keyword  id="u_taylor_mean" name="u_taylor_mean" code="{N_mdm(utype,subMethod_SUBMETHOD_AMV_U)}" label="u_taylor_mean"   />
              <keyword  id="x_taylor_mpp" name="x_taylor_mpp" code="{N_mdm(utype,subMethod_SUBMETHOD_AMV_PLUS_X)}" label="x_taylor_mpp"   >
              </keyword>
              <keyword  id="u_taylor_mpp" name="u_taylor_mpp" code="{N_mdm(utype,subMethod_SUBMETHOD_AMV_PLUS_U)}" label="u_taylor_mpp"   >
              </keyword>
              <keyword  id="x_two_point" name="x_two_point" code="{N_mdm(utype,subMethod_SUBMETHOD_TANA_X)}" label="x_two_point"   >
              </keyword>
              <keyword  id="u_two_point" name="u_two_point" code="{N_mdm(utype,subMethod_SUBMETHOD_TANA_U)}" label="u_two_point"   >
              </keyword>
              <keyword  id="x_multi_point" name="x_multi_point" code="{N_mdm(utype,subMethod_SUBMETHOD_QMEA_X)}" label="x_multi_point"   >
              </keyword>
              <keyword  id="u_multi_point" name="u_multi_point" code="{N_mdm(utype,subMethod_SUBMETHOD_QMEA_U)}" label="u_multi_point"   >
              </keyword>
              <keyword  id="no_approx" name="no_approx" code="{N_mdm(utype,subMethod_SUBMETHOD_NO_APPROX)}" label="no_approx"   />
            </oneOf>
            &method_gradient_sub_problem_solver;
            <keyword  id="integration" name="integration" code="{0}" label="Integration method"  minOccurs="0" default="First-order integration" >
              <oneOf label="Integration Order">
                <keyword  id="first_order" name="first_order" code="{N_mdm(lit,reliabilityIntegration_first_order)}" label="first_order"   />
                <keyword  id="second_order" name="second_order" code="{N_mdm(lit,reliabilityIntegration_second_order)}" label="second_order"   />
              </oneOf>
              <keyword  id="probability_refinement2" name="probability_refinement" code="{0}" label="probability_refinement"  minOccurs="0" >
		<!-- TODO: consider removing this alias -->
                <alias name="sample_refinement"/>
                <oneOf label="Importance Sampling Approach">
                  <keyword  id="import3" name="import" code="{N_mdm(utype,integrationRefine_IS)}" label="import"   />
                  <keyword  id="adapt_import3" name="adapt_import" code="{N_mdm(utype,integrationRefine_AIS)}" label="adapt_import"   />
                  <keyword  id="mm_adapt_import3" name="mm_adapt_import" code="{N_mdm(utype,integrationRefine_MMAIS)}" label="mm_adapt_import"   />
                </oneOf>
		<!-- Old reference default; samples = 0 -->
                <keyword  id="refinement_samples3" name="refinement_samples" code="{N_mdm(ivec,refineSamples)}" label="refinement_samples"  minOccurs="0" >
                  <param type="INTEGERLIST" />
                </keyword>
                <keyword  id="seed8" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed"  minOccurs="0" default="system-generated (non-repeatable)" >
                  <param type="INTEGER" constraint="> 0" />
                </keyword>
              </keyword>
            </keyword>
          </keyword>
	  &level_mappings;
          &method_max_iterations;
          &method_convergence_tolerance;
	  &default_final_moments;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="global_reliability" name="global_reliability" code="{N_mdm(utype,methodName_GLOBAL_RELIABILITY)}" label="global_reliability"  group="Uncertainty Quantification" >
          <alias name="nond_global_reliability"/>
	  <keyword  id="initial_samples" name="initial_samples" code="{N_mdm(int,numSamples)}" label="initial samples"  minOccurs="0" default="(d+1)(d+2)/2">
	    <param type="INTEGER" />
	  </keyword>
          <oneOf label="Approximation">
            <keyword  id="x_gaussian_process" name="x_gaussian_process" code="{N_mdm(utype,subMethod_SUBMETHOD_EGRA_X)}" label="x_gaussian_process"   >
              <alias name="x_kriging"/>
            </keyword>
            <keyword  id="u_gaussian_process" name="u_gaussian_process" code="{N_mdm(utype,subMethod_SUBMETHOD_EGRA_U)}" label="u_gaussian_process"   >
              <alias name="u_kriging"/>
            </keyword>
          </oneOf>
          <optional>
            <oneOf label="GP Implementation">
              <keyword  id="surfpack5" name="surfpack" code="{N_mdm(type,emulatorType_KRIGING_EMULATOR)}" label="surfpack">
		&method_export_model;
	      </keyword>
              <keyword  id="dakota5" name="dakota" code="{N_mdm(type,emulatorType_GP_EMULATOR)}" label="dakota"   />
              <keyword  id="experimental5" name="experimental" code="{N_mdm(type,emulatorType_EXPGP_EMULATOR)}" label="surrogates" >
		&method_export_model;
		   <keyword  id="options_file" name="options_file" code="{N_mdm(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		     <param type="INPUT_FILE" />
		   </keyword>
	      </keyword>
            </oneOf>
          </optional>
	  &import_build;
          <keyword  id="export_approx_points_file7" name="export_approx_points_file" code="{N_mdm(str,exportApproxPtsFile)}" label="File name for exporting approximation-based samples from evaluating the GP"  minOccurs="0" default="no point export to a file" >
            <alias name="export_points_file"/>
	    <param type="OUTPUT_FILE" />
	    &method_export_approx_format;
          </keyword>
          <keyword  id="use_derivatives7" name="use_derivatives" code="{N_mdm(true,methodUseDerivsFlag)}" label="Derivative usage"  minOccurs="0" default="use function values only" />
          <keyword  id="seed9" name="seed" code="{N_mdm(int,randomSeed)}" label="Random seed for initial GP construction"  minOccurs="0" default="system-generated (non-repeatable)" >
            <param type="INTEGER" constraint="> 0" />
          </keyword>
	  &rng_options;
	  &level_mappings_no_rel;
          &method_max_iterations;
          &method_convergence_tolerance;
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="fsu_quasi_mc" name="fsu_quasi_mc" code="{0}" label="fsu_quasi_mc"  group="DACE" >
          <oneOf label="Sequence Type">
            <keyword  id="halton1" name="halton" code="{N_mdm(utype,methodName_FSU_HALTON)}" label="halton"   />
            <keyword  id="hammersley" name="hammersley" code="{N_mdm(utype,methodName_FSU_HAMMERSLEY)}" label="hammersley"   />
          </oneOf>
          <keyword  id="latinize1" name="latinize" code="{N_mdm(true,latinizeFlag)}" label="Latinization of samples"  minOccurs="0" default="No latinization" />
          <keyword  id="quality_metrics2" name="quality_metrics" code="{N_mdm(true,volQualityFlag)}" label="Quality metrics"  minOccurs="0" default="No quality_metrics" />
          <keyword  id="variance_based_decomp5" name="variance_based_decomp" code="{N_mdm(true,vbdFlag)}" label="Variance based decomposition"  minOccurs="0" default="no variance-based decomposition" >
            <keyword  id="drop_tolerance5" name="drop_tolerance" code="{N_mdm(Real,vbdDropTolerance)}" label="drop_tolerance"  minOccurs="0" default="All VBD indices displayed" >
              <param type="REAL" />
            </keyword>
          </keyword>
	  <keyword  id="samples" name="samples" code="{N_mdm(int,numSamples)}" label="samples"  minOccurs="0" default="0">
	    <param type="INTEGER" />
	  </keyword>
          <keyword  id="fixed_sequence" name="fixed_sequence" code="{N_mdm(true,fixedSequenceFlag)}" label="Fixed sequence flag"  minOccurs="0" default="sequence not fixed: sampling patterns are variable among multiple QMC runs" />
          <keyword  id="sequence_start" name="sequence_start" code="{N_mdm(ivec,sequenceStart)}" label="Sequence starting indices"  minOccurs="0" default="Vector of zeroes" >
            <param type="INTEGERLIST" />
          </keyword>
          <keyword  id="sequence_leap" name="sequence_leap" code="{N_mdm(ivec,sequenceLeap)}" label="Sequence leaping indices"  minOccurs="0" default="Vector of ones" >
            <param type="INTEGERLIST" />
          </keyword>
          <keyword  id="prime_base" name="prime_base" code="{N_mdm(ivec,primeBase)}" label="Prime bases for sequences"  minOccurs="0" default="Vector of the first s primes for s-dimensions in Halton, First (s-1) primes for Hammersley" >
            <param type="INTEGERLIST" />
          </keyword>
          &method_max_iterations;
	  &method_optional_model_pointer;
        </keyword>

	<!-- Parameter Studies -->
        <keyword  id="vector_parameter_study" name="vector_parameter_study" code="{N_mdm(utype,methodName_VECTOR_PARAMETER_STUDY)}" label="Vector parameter study"  group="Parameter Studies" >
          <oneOf label="Step Control">
            <keyword  id="final_point" name="final_point" code="{N_mdm(RealDL,finalPoint)}" label="Termination point of vector"   >
              <param type="REALLIST" />
            </keyword>
            <keyword  id="step_vector" name="step_vector" code="{N_mdm(RealDL,stepVector)}" label="Step vector"   >
              <param type="REALLIST" />
            </keyword>
          </oneOf>
          <keyword  id="num_steps" name="num_steps" code="{N_mdm(int,numSteps)}" label="Number of steps along vector"   >
            <param type="INTEGER" />
          </keyword>
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="list_parameter_study" name="list_parameter_study" code="{N_mdm(utype,methodName_LIST_PARAMETER_STUDY)}" label="List parameter study"  group="Parameter Studies" >
          <oneOf label="Points Source">
            <keyword  id="list_of_points" name="list_of_points" code="{N_mdm(RealDL,listOfPoints)}" label="List of points to evaluate"   >
              <param type="REALLIST" />
            </keyword>
            <keyword  id="import_points_file10" name="import_points_file" code="{N_mdm(str,pstudyFilename)}" label="import_points_file"  default="no point import from a file" >
              <param type="INPUT_FILE" />
	      <optional>
		<oneOf label="Tabular Format" >
		  <keyword  id="custom_annotated" name="custom_annotated" code="{N_mdm(utype,pstudyFileFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    <keyword  id="header" name="header" code="{N_mdm(augment_utype,pstudyFileFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    <keyword  id="eval_id" name="eval_id" code="{N_mdm(augment_utype,pstudyFileFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    <keyword  id="interface_id" name="interface_id" code="{N_mdm(augment_utype,pstudyFileFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		  </keyword>
		  <keyword  id="annotated" name="annotated" code="{N_mdm(utype,pstudyFileFormat_TABULAR_ANNOTATED)}" label="annotated"   default="annotated" />
		  <keyword  id="freeform" name="freeform" code="{N_mdm(utype,pstudyFileFormat_TABULAR_NONE)}" label="freeform"   />
		</oneOf>
	      </optional>
	      <keyword  id="active_only19" name="active_only" code="{N_mdm(true,pstudyFileActive)}" label="Active variables only"  minOccurs="0" />
            </keyword>
          </oneOf>
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="centered_parameter_study" name="centered_parameter_study" code="{N_mdm(utype,methodName_CENTERED_PARAMETER_STUDY)}" label="Centered parameter study"  group="Parameter Studies" >
          <keyword  id="step_vector1" name="step_vector" code="{N_mdm(RealDL,stepVector)}" label="Step vector"   >
            <param type="REALLIST" />
          </keyword>
          <keyword  id="steps_per_variable" name="steps_per_variable" code="{N_mdm(ivec,stepsPerVariable)}" label="Number of steps per variable"   >
            <alias name="deltas_per_variable"/>
            <param type="INTEGERLIST" />
          </keyword>
	  &method_optional_model_pointer;
        </keyword>

        <keyword  id="multidim_parameter_study" name="multidim_parameter_study" code="{N_mdm(utype,methodName_MULTIDIM_PARAMETER_STUDY)}" label="Multidimensional parameter study"  group="Parameter Studies" >
          <keyword  id="partitions1" name="partitions" code="{N_mdm(usharray,varPartitions)}" label="Partitions per variable"   >
            <param type="INTEGERLIST" />
          </keyword>
	  &method_optional_model_pointer;
        </keyword>

	<!-- Verification -->
        <keyword  id="richardson_extrap" name="richardson_extrap" code="{N_mdm(utype,methodName_RICHARDSON_EXTRAP)}" label="Richardson extrapolation"  group="Verification Studies" >
          <oneOf label="Verification Mode">
            <keyword  id="estimate_order" name="estimate_order" code="{N_mdm(utype,subMethod_SUBMETHOD_ESTIMATE_ORDER)}" label="estimate_order"   />
            <keyword  id="converge_order" name="converge_order" code="{N_mdm(utype,subMethod_SUBMETHOD_CONVERGE_ORDER)}" label="converge_order"   />
            <keyword  id="converge_qoi" name="converge_qoi" code="{N_mdm(utype,subMethod_SUBMETHOD_CONVERGE_QOI)}" label="converge_qoi"   />
          </oneOf>
          <keyword  id="refinement_rate" name="refinement_rate" code="{N_mdm(Real,refinementRate)}" label="Refinement rate"  minOccurs="0" default="2." >
            <param type="REAL" />
          </keyword>
          &method_convergence_tolerance;
          &method_max_iterations;
	  &method_optional_model_pointer;
        </keyword>

      </oneOf>
    </keyword>

    <!-- **** TOPLEVEL *** -->
    <keyword id="model" name="model" minOccurs="0" maxOccurs="unbounded" code="{N_mom3(start,0,stop)}" label="Model" >
      <keyword  id="id_model" name="id_model" code="{N_mom(str,idModel)}" label="Model Identifier"  minOccurs="0" default="method use of last model parsed" complexity="0">
        <param type="STRING" taglist="model" />
      </keyword>
      <oneOf label="Model Type">
        <keyword  id="single" name="single" code="{N_mom(lit,modelType_simulation)}" label="Single"  default="N/A ( single if no model specification)" complexity="0">
          <alias name="simulation"/>
          <keyword  id="interface_pointer" name="interface_pointer" code="{N_mom(str,interfacePointer)}" label="Interface Set Pointer"  minOccurs="0" default="model use of last interface parsed" >
            <param type="STRING" in_taglist="interface" />
          </keyword>
	  <keyword  id="solution_level_control" name="solution_level_control" code="{N_mom(str,solutionLevelControl)}" label="Simulation Solution Level Control Variable"  minOccurs="0" default="use of single default solution level" >
            <param type="STRING" />
          </keyword>
          <optional>
	    <oneOf label="Cost model for 1 or more resolution levels">
              <keyword  id="solution_level_cost" name="solution_level_cost" code="{N_mom(RealDL,solutionLevelCost)}" label="Relative Simulation Cost Factors for Solution Levels" complexity="1" >
		<param type="REALLIST" />
              </keyword>
	      <keyword  id="cost_recovery_metadata" name="cost_recovery_metadata" code="{N_mom(str,costRecoveryMetadata)}" label="Metadata label for recovering cost data" >
		<param type="STRING" />
              </keyword>
	    </oneOf>
	  </optional>
        </keyword>
        <keyword  id="surrogate" name="surrogate" code="{N_mom(lit,modelType_surrogate)}" label="Surrogate"  complexity="0" >
          <keyword  id="id_surrogates" name="id_surrogates" code="{N_mom(id_to_index_set,surrogateFnIndices)}" label="Surrogate Response IDs"  minOccurs="0" default="All response functions are approximated" >
            <param type="INTEGERLIST" />
          </keyword>
          <oneOf label="Surrogate Category">
            <keyword  id="global" name="global" code="{0}" label="Global Approximation"  >
              <oneOf label="Global Surrogate Type">
		<keyword  id="experimental_gaussian_process" name="experimental_gaussian_process" code="{N_mom(lit,surrogateType_global_exp_gauss_proc)}" label="Experimental Gaussian Process" minOccurs="1" >
                  <keyword  id="trend1" name="trend" code="{0}" label="Specify Trend Function"  minOccurs="0" default="reduced_quadratic" >
                    <oneOf label="Trend Order">
                      <keyword  id="none" name="none" code="{N_mom(lit,trendOrder_none)}" label="None"   />
                      <keyword  id="constant1" name="constant" code="{N_mom(lit,trendOrder_constant)}" label="Constant"   />
                      <keyword  id="linear1" name="linear" code="{N_mom(lit,trendOrder_linear)}" label="Linear"   />
                      <keyword  id="reduced_quadratic1" name="reduced_quadratic" code="{N_mom(lit,trendOrder_reduced_quadratic)}" label="Reduced Quadratic"   />
                      <keyword  id="quadratic" name="quadratic" code="{N_mom(lit,trendOrder_quadratic)}" label="Quadratic"   />
                    </oneOf>
                  </keyword>
                  <keyword  id="num_restarts" name="num_restarts" code="{N_mom(int,numRestarts)}" label="Number of Optimization Runs"  minOccurs="0">
                    <param type="INTEGER" constraint="> 1" />
                  </keyword>
		  <!-- max_trials (max function evals) does not map to num restarts
                       <keyword  id="max_trials" name="max_trials" code="{N_mom(shint,krigingMaxTrials)}" label="Max Number of Likelihood Function Evaluations"  minOccurs="0" default="" complexity="1">
                       <param type="INTEGER" constraint="> 0" />
                       </keyword>
		  -->
                  <optional>
                    <oneOf label="Nugget">
                      <keyword  id="nugget" name="nugget" code="{N_mom(Real,krigingNugget)}" label="User-Specified Nugget "   default="None" >
                        <param type="REAL" constraint="> 0" />
                      </keyword>
                      <keyword  id="find_nugget" name="find_nugget" code="{N_mom(shint,krigingFindNugget)}" label="Surfpack-Computed Nugget "   default="None" >
                        <param type="INTEGER" />
                      </keyword>
                    </oneOf>
                  </optional>
		  <keyword  id="options_file" name="options_file" code="{N_mom(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		    <param type="INPUT_FILE" />
		  </keyword>
		  &model_variance_export;
		  &model_partial_surrogate_export_format;
		  &model_surrogate_import;
		</keyword>
                <keyword  id="gaussian_process5" name="gaussian_process" code="{0}" label="Gaussian Process"  >
                  <alias name="kriging"/>
                  <oneOf label="GP Implementation">
                    <keyword  id="dakota6" name="dakota" code="{N_mom(lit,surrogateType_global_gaussian)}" label="Dakota"  >
                      <keyword  id="point_selection" name="point_selection" code="{N_mom(true,pointSelection)}" label="Point Selection"  minOccurs="0" default="no point selection" />
                      <keyword  id="trend" name="trend" code="{0}" label="Specify Trend Function"  minOccurs="0" default="reduced_quadratic" >
                        <oneOf label="Trend Order">
                          <keyword  id="constant" name="constant" code="{N_mom(lit,trendOrder_constant)}" label="Constant"   />
                          <keyword  id="linear" name="linear" code="{N_mom(lit,trendOrder_linear)}" label="Linear"   />
                          <keyword  id="reduced_quadratic" name="reduced_quadratic" code="{N_mom(lit,trendOrder_reduced_quadratic)}" label="Reduced Quadratic"   />
                        </oneOf>
                      </keyword>
                    </keyword>
                    <keyword  id="surfpack6" name="surfpack" code="{N_mom(lit,surrogateType_global_kriging)}" label="Surfpack"  >
                      <keyword  id="trend1" name="trend" code="{0}" label="Specify Trend Function"  minOccurs="0" default="reduced_quadratic" >
                        <oneOf label="Trend Order">
                          <keyword  id="constant1" name="constant" code="{N_mom(lit,trendOrder_constant)}" label="Constant"   />
                          <keyword  id="linear1" name="linear" code="{N_mom(lit,trendOrder_linear)}" label="Linear"   />
                          <keyword  id="reduced_quadratic1" name="reduced_quadratic" code="{N_mom(lit,trendOrder_reduced_quadratic)}" label="Reduced Quadratic"   />
                          <keyword  id="quadratic" name="quadratic" code="{N_mom(lit,trendOrder_quadratic)}" label="Quadratic"   />
                        </oneOf>
                      </keyword>
                      <!-- # using generic STRING to avoid collision with local/global below -->
                      <keyword  id="optimization_method" name="optimization_method" code="{N_mom(str,krigingOptMethod)}" label="Optimization Method"  minOccurs="0" default="global" complexity="1">
                        <param type="STRING" />
                      </keyword>
                      <keyword  id="max_trials" name="max_trials" code="{N_mom(shint,krigingMaxTrials)}" label="Max Number of Likelihood Function Evaluations"  minOccurs="0" default="" complexity="1">
                        <param type="INTEGER" constraint="> 0" />
                      </keyword>
                      <optional>
                        <oneOf label="Nugget">
                          <keyword  id="nugget" name="nugget" code="{N_mom(Real,krigingNugget)}" label="User-Specified Nugget "   default="None" >
                            <param type="REAL" constraint="> 0" />
                          </keyword>
                          <keyword  id="find_nugget" name="find_nugget" code="{N_mom(shint,krigingFindNugget)}" label="Surfpack-Computed Nugget "   default="None" >
                            <param type="INTEGER" />
                          </keyword>
                        </oneOf>
                      </optional>
                      <keyword  id="correlation_lengths" name="correlation_lengths" code="{N_mom(RealDL,krigingCorrelations)}" label="Correlation Lengths"  minOccurs="0" default="internally computed correlation_lengths" complexity="1">
                        <param type="REALLIST" />
                      </keyword>
                      <!-- #	        [ min_correlations REALLIST {N_mom(RealDL,krigingMinCorrelations)} ]
                           #	        [ max_correlations REALLIST {N_mom(RealDL,krigingMaxCorrelations)} ]
                       -->
                    &model_full_surfpack_export_format;
		    &model_surrogate_import;
		    </keyword>
                  </oneOf>
		  &model_variance_export;
                </keyword>

                <keyword  id="mars" name="mars" code="{N_mom(lit,surrogateType_global_mars)}" label="Multivariate Adaptive Regression Spline (MARS)"  >
                  <keyword  id="max_bases" name="max_bases" code="{N_mom(shint,marsMaxBases)}" label="Maximum Number of Bases"  minOccurs="0" default="" >
                    <param type="INTEGER" />
                  </keyword>
                  <keyword  id="interpolation" name="interpolation" code="{0}" label="Interpolation Type"  minOccurs="0" default="" >
                    <oneOf label="Interpolation Order">
                      <keyword  id="linear2" name="linear" code="{N_mom(lit,marsInterpolation_linear)}" label="Linear"   />
                      <keyword  id="cubic" name="cubic" code="{N_mom(lit,marsInterpolation_cubic)}" label="Cubic"   />
                    </oneOf>
                  </keyword>
		  &model_partial_surrogate_export_format;
		  &model_surrogate_import;
	        </keyword>

                <keyword  id="moving_least_squares" name="moving_least_squares" code="{N_mom(lit,surrogateType_global_moving_least_squares)}" label="Moving Least Squares"  >
                  <keyword  id="basis_order" name="basis_order" code="{N_mom(shint,polynomialOrder)}" label="Polynomial Order for Bases"  minOccurs="0" default="" >
		    <alias name="poly_order"/>
                    <param type="INTEGER" constraint=">= 0" />
                  </keyword>
                  <keyword  id="weight_function" name="weight_function" code="{N_mom(shint,mlsWeightFunction)}" label="Weight Function"  minOccurs="0" default="" >
                    <param type="INTEGER" />
                  </keyword>
                  &model_partial_surrogate_export_format;
		  &model_surrogate_import;
                </keyword>
		<keyword  id="function_train" name="function_train" code="{N_mom(lit,surrogateType_global_function_train)}" label="Low rank approximation model" help="ModelCommands.html#ModelSurrG" group="Surrogate-based Methods">
		  <!-- &ft_model_refinement; -->
		  &ft_model_regression_opts; <!-- opts only: collocation points defined through dace_method_pointer -->
		  &ft_model_tols;
		  &ft_model_order;
		  &ft_model_rank;
		  <!-- num_param is identical to start_order in polynomial case, but could be useful generalization for future non-polynomial cases
		  <keyword  id="num_param" name="num_param" code="{N_mom(sizet,numParam)}" label="Number of parameters in univariate function" help="" minOccurs="0" default="">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword id="num_coeff_check" name="num_coeff_check" code="{N_mom(sizet,numCoeffCheck)}" label="Number of polynomial coefficients to check for convergence" help="" minOccurs="0" default="2">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword id="adapt_coeff_tolerance" name="adapt_coeff_tolerance" code="{N_mom(Real,adaptCoeffTolerance)}" label="Polynomial coefficient adaptation tolerance" help="" minOccurs="0" default="1.0e-10">
		    <param type="REAL" constraint=">= 0" />
		  </keyword>
		  <keyword  id="verbosity" name="verbosity" code="{N_mom(int,verbosity)}" label="Verbosity level during building of the FT" help="" minOccurs="0" default="0">
		    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  -->
		  <!-- Can be automated for a particular method context, e.g., UQ, but could be retained for Model lacking an Iterator context.
		  <keyword id="polynomial_type" name="polynomial_type" code="{0}" label="Polynomial type" minOccurs="0" default="">
		    <oneOf label="Polynomial Type">
                      <keyword id="legendre" name="legendre" code="{N_mom(utype,polyType_LEGENDRE)}" label="legendre" />
                      <keyword id="chebyshev" name="chebyshev" code="{N_mom(utype,polyType_CHEBYSHEV)}" label="chebyshev" />
                      <keyword id="hermite" name="hermite" code="{N_mom(utype,polyType_HERMITE)}" label="hermite" />
                      <keyword id="standard" name="standard" code="{N_mom(utype,polyType_STANDARD)}" label="standard" />
                      <keyword id="fourier" name="fourier" code="{N_mom(utype,polyType_FOURIER)}" label="fourier" />
		    </oneOf>
		  </keyword>
		  -->
		  <!-- Seems useful for both method and model, but can induce some measure restrictions as for piecewise SC.
		  <keyword id="function_class" name="function_class" code="{0}" label="Function_type" minOccurs="0" default="">
		    <oneOf label="Function Type">
                      <keyword id="piecewise" name="piecewise" code="{N_mom(utype,polyType_PIECEWISE)}" label="piecewise" />
                      <keyword id="polynomial" name="polynomial" code="{N_mom(utype,polyType_POLYNOMIAL)}" label="polynomial" />
                      <keyword id="constelm" name="constelm" code="{N_mom(utype,polyType_CONSTELM)}" label="constelm" />
                      <keyword id="linelm" name="linelm" code="{N_mom(utype,polyType_LINELM)}" label="linelm" />
                      <keyword id="kernel" name="kernel" code="{N_mom(utype,polyType_KERNEL)}" label="kernel" />
		    </oneOf>
		  </keyword>
		  -->
		  <!-- Not ready for this just yet; cross will require the addition of the QoI evaluator API for per-evaluation search.
		  <keyword id="c3_build_type" name="c3_build_type" code="{0}" label="c3_build_type" minOccurs="0" default="regress">
		    <oneOf label="C3 Build Type">
                      <keyword id="cross" name="cross" code="{N_mom(utype, c3BuildType_CROSS_APPROXIMATION)}" label="cross approximation" />
                      <keyword id="regress" name="regress" code="{N_mom(utype,polyType_REGRESSION)}" label="regress" />
		    </oneOf>
		  </keyword>
		  -->
		</keyword>

        <keyword  id="neural_network" name="neural_network" code="{N_mom(lit,surrogateType_global_neural_network)}" label="Artificial Neural Network"  >
          <keyword  id="max_nodes" name="max_nodes" code="{N_mom(shint,annNodes)}" label="Maximum Number of Nodes"  minOccurs="0" default="numTrainingData - 1">
		    <alias name="nodes"/>
            <param type="INTEGER" />
          </keyword>
          <keyword  id="range" name="range" code="{N_mom(Real,annRange)}" label="Random Weights Range"  minOccurs="0" default="" complexity="1">
            <param type="REAL" />
          </keyword>
          <keyword  id="random_weight" name="random_weight" code="{N_mom(shint,annRandomWeight)}" label="Random Weight Control"  minOccurs="0" default="" complexity="1">
            <param type="INTEGER" />
          </keyword>
          &model_full_surfpack_export_format;
	  &model_surrogate_import;
        </keyword>

        <!-- #	    | orthogonal_polynomial {N_mom(lit,surrogateType_global_orthogonal_polynomial)}
                     #	    | interpolation_polynomial {N_mom(lit,surrogateType_global_interpolation_polynomial)}
                 -->
                <keyword  id="radial_basis" name="radial_basis" code="{N_mom(lit,surrogateType_global_radial_basis)}" label="Radial Basis Function (RBF)"  >
                  <keyword  id="bases" name="bases" code="{N_mom(shint,rbfBases)}" label="Initial Number of Bases"  minOccurs="0" default="" >
                    <param type="INTEGER" />
                  </keyword>
                  <keyword  id="max_pts" name="max_pts" code="{N_mom(shint,rbfMaxPts)}" label="Maximum Number of CVT Points"  minOccurs="0" default="" complexity="1">
                    <param type="INTEGER" />
                  </keyword>
                  <keyword  id="min_partition" name="min_partition" code="{N_mom(shint,rbfMinPartition)}" label="Minimum Partition"  minOccurs="0" default="" complexity="1">
                    <param type="INTEGER" />
                  </keyword>
                  <keyword  id="max_subsets" name="max_subsets" code="{N_mom(shint,rbfMaxSubsets)}" label="Number of Trial Subsets"  minOccurs="0" complexity="1">
                    <param type="INTEGER" />
                  </keyword>
                  &model_full_surfpack_export_format;
		  &model_surrogate_import;
                </keyword>

                <keyword  id="polynomial" name="polynomial" code="{N_mom(lit,surrogateType_global_polynomial)}" label="Polynomial"  >
                  <oneOf label="Polynomial Order">
                    <keyword  id="basis_order" name="basis_order" code="{N_mom(shint,polynomialOrder)}" label="Basis Order"  >
                      <param type="INTEGER" constraint=">= 0" />
		    </keyword>
                    <keyword  id="linear3" name="linear" code="{N_mom(order,polynomialOrder_1)}" label="Linear"   />
                    <keyword  id="quadratic1" name="quadratic" code="{N_mom(order,polynomialOrder_2)}" label="Quadratic"   />
                    <keyword  id="cubic1" name="cubic" code="{N_mom(order,polynomialOrder_3)}" label="Cubic"   />
                  </oneOf>
                  &model_full_surfpack_export_format;
		  &model_surrogate_import;
                </keyword>
                <keyword  id="experimental_polynomial" name="experimental_polynomial" code="{N_mom(lit,surrogateType_global_exp_poly)}" label="Experimental Polynomial"  minOccurs="1" >
                  <keyword  id="basis_order" name="basis_order" code="{N_mom(shint,polynomialOrder)}" label="Basis Order" minOccurs="1" >
                    <param type="INTEGER" constraint=">= 0" />
		  </keyword>
		  <keyword  id="options_file" name="options_file" code="{N_mom(str,advancedOptionsFilename)}" label="Advanced Options File"  minOccurs="0" default="no advanced options file" >
		    <param type="INPUT_FILE" />
		  </keyword>
		  &model_partial_surrogate_export_format;
		  &model_surrogate_import;
		</keyword>
              </oneOf>
              <keyword  id="domain_decomposition" name="domain_decomposition" code="{N_mom(true,domainDecomp)}" label="Domain Decomposition"  minOccurs="0" complexity="1">
		<keyword  id="cell_type" name="cell_type" code="{N_mom(str,decompCellType)}" label="Local Cell Type"  minOccurs="0">
		  <param type="STRING" />
		</keyword>
		<keyword  id="support_layers" name="support_layers" code="{N_mom(int,decompSupportLayers)}" label="Layers of Support for Local Basis Function"  minOccurs="0">
		  <param type="INTEGER" />
		</keyword>
		<keyword  id="discontinuity_detection" name="discontinuity_detection" code="{N_mom(true,decompDiscontDetect)}" label="Enable Discontinuity Detection"  minOccurs="0">
		  <oneOf label="Threshold Mode">
		    <keyword  id="jump_threshold" name="jump_threshold" code="{N_mom(Real,discontJumpThresh)}" label="Absolute Function Jump Threshold" >
		      <param type="REAL" />
		    </keyword>
		    <keyword  id="gradient_threshold" name="gradient_threshold" code="{N_mom(Real,discontGradThresh)}" label="Absolute Gradient Threshold" >
		      <param type="REAL" />
		    </keyword>
		  </oneOf>
		</keyword>
              </keyword>
              <optional>
                <oneOf label="Number of Build Points">
                  <keyword  id="total_points" name="total_points" code="{N_mom(int,pointsTotal)}" label="Total Points"   default="recommended_points" >
                    <param type="INTEGER" />
                  </keyword>
                  <keyword  id="minimum_points" name="minimum_points" code="{N_mom(type,pointsManagement_MINIMUM_POINTS)}" label="Minimum Points"   />
                  <keyword  id="recommended_points" name="recommended_points" code="{N_mom(type,pointsManagement_RECOMMENDED_POINTS)}" label="Recommended Points"   />
                </oneOf>
              </optional>
	      <optional>
		<oneOf label="Build Data Source">
		  <keyword  id="dace_method_pointer" name="dace_method_pointer" code="{N_mom(str,subMethodPointer)}" label="Design of Experiments Method Pointer"  default="no design of experiments data" >
                    <param type="STRING" in_taglist="method" />
		    <keyword  id="auto_refinement" name="auto_refinement" code="{N_mom(true,autoRefine)}" label="Automatically Refine Surrogate"  minOccurs="0" default="no refinement" complexity="1">
		      <keyword  id="max_iterations" name="max_iterations" code="{N_mom(sizet,maxIterations)}" label="Max Build Iterations"  minOccurs="0" default="100">
			<param type="INTEGER" constraint="> 0" />
		      </keyword>
		      <keyword  id="max_function_evaluations" name="max_function_evaluations" code="{N_mom(sizet,maxFunctionEvals)}" label="Max Build Evaluations"  minOccurs="0" default="1000">
			<param type="INTEGER" constraint="> 0" />
		      </keyword>
		      <keyword  id="convergence_tolerance" name="convergence_tolerance" code="{N_mom(Real,convergenceTolerance)}" label="Convergence Tolerance"  minOccurs="0" default="1.0e-4" >
			<param type="REAL" />
		      </keyword>
		      <keyword  id="soft_convergence_limit" name="soft_convergence_limit" code="{N_mom(int,softConvergenceLimit)}" label="Soft Convergence Limit"  minOccurs="0" default="0" >
		        <param type="INTEGER" constraint=">= 0" />
		      </keyword>
		      <keyword  id="cross_validation_metric" name="cross_validation_metric" code="{N_mom(str,refineCVMetric)}" label="Cross-Validation Metric Type"  minOccurs="0" default="root-mean-squared error" >
			<param type="STRING" />
			<keyword  id="folds" name="folds" code="{N_mom(int,refineCVFolds)}" label="CV Folds"  minOccurs="0" default="10">
			  <param type="INTEGER" constraint="> 0" />
			</keyword>
		      </keyword>
		      <!-- TODO: soft convergence limit / tolerance, challenge points -->
		    </keyword>
		  </keyword>
		  <keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"  >
                    <alias name="actual_model_pointer"/>
                    <param type="STRING" in_taglist="model" />
		  </keyword>
		</oneOf>
	      </optional>
          <keyword  id="reuse_points3" name="reuse_points" code="{0}" label="Re-use Points"  minOccurs="0" default="all for import; none otherwise">
                <alias name="reuse_samples"/>
                <oneOf label="Reuse Domain">
              <keyword  id="all" name="all" code="{N_mom(lit,approxPointReuse_all)}" label="All"   />
              <keyword  id="region" name="region" code="{N_mom(lit,approxPointReuse_region)}" label="Region"   />
              <keyword  id="none" name="none" code="{N_mom(lit,approxPointReuse_none)}" label="None"   />
                </oneOf>
              </keyword>
          <keyword  id="import_build_points_file17" name="import_build_points_file" code="{N_mom(str,importBuildPtsFile)}" label="File Import of Samples for Global Approximation Builds"  minOccurs="0" default="no point import from a file" >
                <alias name="import_points_file"/>
		<alias name="samples_file"/>
                <param type="INPUT_FILE" />
		<optional>
		  <oneOf label="Tabular Format" >
		    <keyword  id="custom_annotated" name="custom_annotated" code="{N_mom(utype,importBuildFormat_TABULAR_NONE)}" label="Custom Annotated"  >
		      <keyword  id="header" name="header" code="{N_mom(augment_utype,importBuildFormat_TABULAR_HEADER)}" label="Header"  minOccurs="0" >
			<keyword  id="use_variable_labels" name="use_variable_labels" code="{N_mom(true,importUseVariableLabels)}" label="Use/Validate Variables Labels from Header"  minOccurs="0" />
		      </keyword>
		      <keyword  id="eval_id" name="eval_id" code="{N_mom(augment_utype,importBuildFormat_TABULAR_EVAL_ID)}" label="Eval ID"  minOccurs="0" />
		      <keyword  id="interface_id" name="interface_id" code="{N_mom(augment_utype,importBuildFormat_TABULAR_IFACE_ID)}" label="Interface ID"  minOccurs="0"/>
		    </keyword>

		    <keyword  id="annotated" name="annotated" code="{N_mom(utype,importBuildFormat_TABULAR_ANNOTATED)}" label="Annotated"   default="annotated" >
		      <keyword  id="use_variable_labels" name="use_variable_labels" code="{N_mom(true,importUseVariableLabels)}" label="Use/Validate Variables Labels from Header"  minOccurs="0" />
		    </keyword>
		    <keyword  id="freeform" name="freeform" code="{N_mom(utype,importBuildFormat_TABULAR_NONE)}" label="Freeform"   default="annotated" />
		  </oneOf>
		</optional>
		    <keyword  id="active_only20" name="active_only" code="{N_mom(true,importBuildActive)}" label="Active Variables Only"  minOccurs="0" />
              </keyword>
	      <!-- MSE: this option seems undesirable from a design perspective; outer loop evaluations should be handled by Iterators.
              <keyword  id="import_approx_points_file2" name="import_approx_points_file" code="{N_mom(str,importApproxPtsFile)}" label="File import of samples for evaluation on global surrogate"  minOccurs="0" default="no point import from a file" >
		<param type="INPUT_FILE" />
		<optional>
		  <oneOf label="Tabular Format" >
		    <keyword  id="custom_annotated" name="custom_annotated" code="{N_mom(utype,importApproxFormat_TABULAR_NONE)}" label="custom_annotated"  >
		    	<keyword  id="header" name="header" code="{N_mom(augment_utype,importApproxFormat_TABULAR_HEADER)}" label="header"  minOccurs="0" />
		    	<keyword  id="eval_id" name="eval_id" code="{N_mom(augment_utype,importApproxFormat_TABULAR_EVAL_ID)}" label="eval_id"  minOccurs="0" />
		    	<keyword  id="interface_id" name="interface_id" code="{N_mom(augment_utype,importApproxFormat_TABULAR_IFACE_ID)}" label="interface_id"  minOccurs="0" />
		    </keyword>
		    <keyword  id="annotated" name="annotated" code="{N_mom(utype,importApproxFormat_TABULAR_ANNOTATED)}" label="annotated"   default="annotated" />
		    <keyword  id="freeform" name="freeform" code="{N_mom(utype,importApproxFormat_TABULAR_NONE)}" label="freeform"   default="annotated" />
		  </oneOf>
		</optional>
		<keyword  id="active_only21" name="active_only" code="{N_mom(true,importApproxActive)}" label="Active variables only"  minOccurs="0" />
              </keyword>
	      -->
          <keyword  id="export_approx_points_file8" name="export_approx_points_file" code="{N_mom(str,exportApproxPtsFile)}" label="File Export of Global Approximation-Based Sample Results"  minOccurs="0" default="no point export to a file" >
                <alias name="export_points_file"/>
		<param type="OUTPUT_FILE" />
		<optional>
		  <oneOf label="Tabular Format" >
		    <keyword  id="custom_annotated" name="custom_annotated" code="{N_mom(utype,exportApproxFormat_TABULAR_NONE)}" label="Custom Annotated"  >
		      <keyword  id="header" name="header" code="{N_mom(augment_utype,exportApproxFormat_TABULAR_HEADER)}" label="Header"  minOccurs="0" />
		      <keyword  id="eval_id" name="eval_id" code="{N_mom(augment_utype,exportApproxFormat_TABULAR_EVAL_ID)}" label="Eval ID"  minOccurs="0" />
		      <keyword  id="interface_id" name="interface_id" code="{N_mom(augment_utype,exportApproxFormat_TABULAR_IFACE_ID)}" label="Interface ID"  minOccurs="0" />
		    </keyword>
		    <keyword  id="annotated" name="annotated" code="{N_mom(utype,exportApproxFormat_TABULAR_ANNOTATED)}" label="Annotated"   default="annotated" />
		    <keyword  id="freeform" name="freeform" code="{N_mom(utype,exportApproxFormat_TABULAR_NONE)}" label="Freeform"  default="annotated" />
		  </oneOf>
		</optional>
              </keyword>
          <keyword  id="use_derivatives8" name="use_derivatives" code="{N_mom(true,modelUseDerivsFlag)}" label="Gradient Enhancement"  minOccurs="0" default="use function values only" complexity="1" />
          &surrogate_correction;
             <keyword  id="metrics" name="metrics" code="{N_mom(strL,diagMetrics)}" label="Compute Surrogate Diagnostics"  minOccurs="0" default="No diagnostics" >
                <alias name="diagnostics"/>
                <param type="STRINGLIST" />
                <keyword  id="cross_validation4" name="cross_validation" code="{N_mom(true,crossValidateFlag)}" label="Perform Cross Validation"  minOccurs="0" default="No cross validation" >
                  <optional>
                    <oneOf label="Partition Control">
                      <keyword  id="folds" name="folds" code="{N_mom(int,numFolds)}" label="Number Cross Validation Folds"   default="10" >
                        <param type="INTEGER" />
                      </keyword>
                      <keyword  id="percent" name="percent" code="{N_mom(Real,percentFold)}" label="Percent Points per CV Fold"   default="0.1" >
                        <param type="REAL" />
                      </keyword>
                    </oneOf>
                  </optional>
                </keyword>
                <keyword  id="press" name="press" code="{N_mom(true,pressFlag)}" label="Perform PRESS Cross-Validation"  minOccurs="0" default="No PRESS cross validation" />
              </keyword>
              <keyword  id="import_challenge_points_file" name="import_challenge_points_file" code="{N_mom(str,importChallengePtsFile)}" label="Challenge File for Surrogate Metrics"  minOccurs="0" default="no user challenge data" >
                <alias name="challenge_points_file"/>
                <param type="STRING" />
		<optional>
		  <oneOf label="Tabular Format" >
		    <keyword  id="custom_annotated" name="custom_annotated" code="{N_mom(utype,importChallengeFormat_TABULAR_NONE)}" label="Custom Annotated"  >
		      <keyword  id="header" name="header" code="{N_mom(augment_utype,importChallengeFormat_TABULAR_HEADER)}" label="Header"  minOccurs="0" >
			<keyword  id="use_variable_labels" name="use_variable_labels" code="{N_mom(true,importChalUseVariableLabels)}" label="Use/Validate Variables Labels from Header"  minOccurs="0" />
		      </keyword>
		      <keyword  id="eval_id" name="eval_id" code="{N_mom(augment_utype,importChallengeFormat_TABULAR_EVAL_ID)}" label="Eval ID"  minOccurs="0" />
		      <keyword  id="interface_id" name="interface_id" code="{N_mom(augment_utype,importChallengeFormat_TABULAR_IFACE_ID)}" label="Interface ID"  minOccurs="0" />
		    </keyword>
		    <keyword  id="annotated" name="annotated" code="{N_mom(utype,importChallengeFormat_TABULAR_ANNOTATED)}" label="Annotated"   default="annotated" >
		      <keyword  id="use_variable_labels" name="use_variable_labels" code="{N_mom(true,importChalUseVariableLabels)}" label="Use/Validate Variables Labels from Header"  minOccurs="0" />
		    </keyword>
		    <keyword  id="freeform" name="freeform" code="{N_mom(utype,importChallengeFormat_TABULAR_NONE)}" label="Freeform"   default="annotated" />
		  </oneOf>
		</optional>
		          <keyword  id="active_only22" name="active_only" code="{N_mom(true,importChallengeActive)}" label="Active Variables Only"  minOccurs="0" />
              </keyword>
            </keyword>
            <keyword  id="multipoint" name="multipoint" code="{0}" label="Multipoint Approximation"  complexity="1">
              <oneOf label="Multipoint Surrogate" >
                <keyword  id="tana" name="tana" code="{N_mom(lit,surrogateType_multipoint_tana)}" label="Two-point adaptive nonlinear approximation "   />
                <keyword  id="qmea" name="qmea" code="{N_mom(lit,surrogateType_multipoint_qmea)}" label="Quadratic multipoint exponential approximation "   />
              </oneOf>

	      <keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"  >
                <alias name="actual_model_pointer"/>
                <param type="STRING" in_taglist="model" />
	      </keyword>
            </keyword>
            <keyword  id="local" name="local" code="{N_mom(lit,surrogateType_local_taylor)}" label="Local Approximation"  complexity="1">
              <keyword  id="taylor_series" name="taylor_series" code="{0}" label="Taylor Series Local Approximation "   />
	      <keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"  >
                <alias name="actual_model_pointer"/>
                <param type="STRING" in_taglist="model" />
	      </keyword>
            </keyword>
            <keyword  id="ensemble" name="ensemble" code="{N_mom(lit,surrogateType_ensemble)}" label="Ensemble Model Approximation"  >
	      <oneOf label="Ensemble model specification" >
		<!-- Previous "hierarchical" spec: -->
		<keyword  id="ordered_model_fidelities" name="ordered_model_fidelities" code="{N_mom(strL,ensembleModelPointers)}" label="Model Pointers (Ordered by Fidelity)"   >
                  <alias name="model_fidelity_sequence"/>
                  <param type="STRINGLIST" in_taglist="model" />
		  &surrogate_correction;
		</keyword>
		<!-- Previous "non_hierarchical" spec: -->
		<keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"   >
		  <alias name="actual_model_pointer"/>
		  <param type="STRING" in_taglist="model" />
		  <keyword  id="approximation_models" name="approximation_models" code="{N_mom(strL,ensembleModelPointers)}" label="Model Pointers (set of approximation models)"  minOccurs="0"  >
                    <alias name="unordered_model_fidelities"/>
                    <param type="STRINGLIST" in_taglist="model" />
		  </keyword>
		</keyword>
              </oneOf>
	    </keyword>
            </oneOf>
          </keyword>
        <keyword  id="nested2" name="nested" code="{N_mom(lit,modelType_nested)}" label="Nested"  complexity="1">
          <keyword  id="optional_interface_pointer" name="optional_interface_pointer" code="{N_mom(str,interfacePointer)}" label="Optional Interface Set Pointer"  minOccurs="0" default="no optional interface" >
            <param type="STRING" in_taglist="interface" />
            <keyword  id="optional_interface_responses_pointer" name="optional_interface_responses_pointer" code="{N_mom(str,optionalInterfRespPointer)}" label="Responses Pointer for Optional Interfaces"  minOccurs="0" default="reuse of top-level responses specification" >
              <param type="STRING" in_taglist="responses" />
            </keyword>
          </keyword>
          <keyword  id="sub_method_pointer" name="sub_method_pointer" code="{N_mom(str,subMethodPointer)}" label="Sub-Method Pointer"  >
            <param type="STRING" in_taglist="method" />
            <keyword  id="iterator_servers1" name="iterator_servers" code="{N_mom(int,subMethodServers)}" label="Iterator Servers"  minOccurs="0" >
              <param type="INTEGER" constraint="> 0" />
            </keyword>
            <keyword  id="iterator_scheduling1" name="iterator_scheduling" code="{0}" label="Iterator Scheduling"  minOccurs="0" >
              <oneOf label="Server Mode">
                <keyword  id="master1" name="master" code="{N_mom(type,subMethodScheduling_MASTER_SCHEDULING)}" label="Master"   />
                <keyword  id="peer1" name="peer" code="{N_mom(type,subMethodScheduling_PEER_SCHEDULING)}" label="Peer"   />
				<!-- #	      | ( peer {0}
                     #	          dynamic  {N_mom(type,subMethodScheduling_PEER_DYNAMIC_SCHEDULING)}
                     #	      	  | static {N_mom(type,subMethodScheduling_PEER_STATIC_SCHEDULING)} )
				  -->
              </oneOf>
            </keyword>
            <keyword  id="processors_per_iterator1" name="processors_per_iterator" code="{N_mom(int,subMethodProcs)}" label="Processors per Iterator"  minOccurs="0" >
              <param type="INTEGER" constraint="> 0" />
            </keyword>
            <keyword  id="primary_variable_mapping" name="primary_variable_mapping" code="{N_mom(strL,primaryVarMaps)}" label="Primary Variable Mappings"  minOccurs="0" default="default variable insertions based on variable type" >
              <param type="STRINGLIST" />
            </keyword>
            <keyword  id="secondary_variable_mapping" name="secondary_variable_mapping" code="{N_mom(strL,secondaryVarMaps)}" label="Secondary Variable Mappings"  minOccurs="0" default="primary mappings into sub-model variables are value-based" >
              <param type="STRINGLIST" />
            </keyword>
	    <!-- BMA TODO: Identity should be mutually exclusive with pri/sec map. -->
	    <keyword  id="primary_response_mapping" name="primary_response_mapping" code="{N_mom(RealDL,primaryRespCoeffs)}" label="Primary Response Mappings"  minOccurs="0" default="no sub-iterator contribution to primary functions" >
	      <param type="REALLIST" />
	    </keyword>
	    <keyword  id="secondary_response_mapping" name="secondary_response_mapping" code="{N_mom(RealDL,secondaryRespCoeffs)}" label="Secondary Response Mappings"  minOccurs="0" default="no sub-iterator contribution to secondary functions" >
	      <param type="REALLIST" />
	    </keyword>
	    <keyword  id="identity_response_mapping" name="identity_response_mapping" code="{N_mom(true,identityRespMap)}" label="Identity Response Mapping"  minOccurs="0" default="no sub-iterator contribution to nested model functions" />
          </keyword>
        </keyword>
        <keyword  id="active_subspace" name="active_subspace" code="{N_mom(lit,modelType_active_subspace)}" label="Active Subspace"  complexity="1">
          <alias name="subspace"/>

	  <keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"  >
            <alias name="actual_model_pointer"/>
            <param type="STRING" in_taglist="model" />
	  </keyword>
	  <keyword  id="initial_samples" name="initial_samples" code="{N_mom(int,initialSamples)}" label="Initial Samples"  minOccurs="0" default="model-dependent">
	    <param type="INTEGER" />
	  </keyword>
	  <keyword  id="sample_type" name="sample_type" code="{0}" label="Sample Type"  minOccurs="0" default="random" >
	    <oneOf label="Sample Type">
	      <keyword  id="lhs" name="lhs" code="{N_mom(utype,subspaceSampleType_SUBMETHOD_LHS)}" label="LHS"   />
	      <keyword  id="random" name="random" code="{N_mom(utype,subspaceSampleType_SUBMETHOD_RANDOM)}" label="Random"   />
	    </oneOf>
	  </keyword>
	  <keyword id="truncation_method" name="truncation_method" label="Truncation Method" code="{0}" minOccurs="0" default="constantine">
	    <keyword id="bing_li" name="bing_li" label="'Bing Li' Ladle Diagnostic" code="{N_mom(true,subspaceIdBingLi)}" minOccurs="0" />
	    <keyword id="constantine" name="constantine" label="Constantine Diagnostic" code="{N_mom(true,subspaceIdConstantine)}" minOccurs="0" />
	    <keyword id="energy" name="energy" label="Eigenvalue Energy" code="{N_mom(true,subspaceIdEnergy)}" minOccurs="0">
	      <keyword  id="truncation_tolerance" name="truncation_tolerance" label="Truncation Tolerance" code="{N_mom(Real,truncationTolerance)}"  minOccurs="0" >
	        <param type="REAL" />
	      </keyword>
	    </keyword>
	    <keyword id="cross_validation" name="cross_validation" label="Cross Validation" code="{N_mom(true,subspaceIdCV)}" minOccurs="0" default="relative" >
              <optional>
		<oneOf label="CV Selection Criterion">
		  <keyword id="minimum" name="minimum" label="Minimum" code="{N_mom(utype,subspaceIdCVMethod_MINIMUM_METRIC)}" />
		  <keyword id="relative" name="relative" label="Relative" code="{N_mom(utype,subspaceIdCVMethod_RELATIVE_TOLERANCE)}" />
		  <keyword id="decrease" name="decrease" label="Decrease" code="{N_mom(utype,subspaceIdCVMethod_DECREASE_TOLERANCE)}" />
		</oneOf>
              </optional>
              <keyword  id="relative_tolerance" name="relative_tolerance" code="{N_mom(Real,relTolerance)}" label="Relative Tolerance"  minOccurs="0" default="1.0e-6" >
		<param type="REAL" />
              </keyword>
              <keyword  id="decrease_tolerance" name="decrease_tolerance" code="{N_mom(Real,decreaseTolerance)}" label="Decrease Tolerance"  minOccurs="0" default="1.0e-6">
		<param type="REAL" />
              </keyword>
              <keyword  id="max_rank" name="max_rank" label="Max Rank" code="{N_mom(int,subspaceCVMaxRank)}" minOccurs="0" default="number fullspace vars">
		<param type="INTEGER" />
	      </keyword>
	      <keyword id="exhaustive" name="exhaustive" label="Exhaustive" code="{N_mom(false,subspaceCVIncremental)}" minOccurs="0" default="on" />
	    </keyword>
	  </keyword>
	  <keyword  id="dimension" name="dimension" label="Dimension" code="{N_mom(int,subspaceDimension)}" minOccurs="0">
            <param type="INTEGER" />
	  </keyword>
	  <keyword  id="bootstrap_samples" name="bootstrap_samples" label="Bootstrap Samples" code="{N_mom(int,numReplicates)}" minOccurs="0">
            <param type="INTEGER" />
	  </keyword>
	  <keyword id="build_surrogate" name="build_surrogate" label="Build Surrogate" code="{N_mom(true,subspaceBuildSurrogate)}" minOccurs="0">
            <keyword  id="refinement_samples" name="refinement_samples" code="{N_mom(ivec,refineSamples)}" label="Refinement Samples"  minOccurs="0" default="0">
              <param type="INTEGERLIST" />
            </keyword>
	  </keyword>
	  <keyword id="normalization" name="normalization" label="Normalization" code="{0}" minOccurs="0">
	    <oneOf label="Normalize By...">
              <keyword id="mean_value" name="mean_value" label="Mean Value" code="{N_mom(utype,subspaceNormalization_SUBSPACE_NORM_MEAN_VALUE)}" />
              <keyword id="mean_gradient" name="mean_gradient" label="Mean Gradient" code="{N_mom(utype,subspaceNormalization_SUBSPACE_NORM_MEAN_GRAD)}" />
              <keyword id="local_gradient" name="local_gradient" label="Local Gradient" code="{N_mom(utype,subspaceNormalization_SUBSPACE_NORM_LOCAL_GRAD)}" />
	    </oneOf>
	  </keyword>
	</keyword>
	<keyword id="adapted_basis" name="adapted_basis" code="{N_mom(lit,modelType_adapted_basis)}" label="Adapted Basis"  >
	  <keyword  id="truth_model_pointer" name="truth_model_pointer" code="{N_mom(str,truthModelPointer)}" label="Truth Model Pointer"  >
            <alias name="actual_model_pointer"/>
            <param type="STRING" in_taglist="model" />
	  <oneOf label="Expansion Basis Control">
	    <keyword  id="sparse_grid_level" name="sparse_grid_level" code="{N_mom(ushint,adaptedBasisSparseGridLev)}" label="Adapted Basis Sparse Grid Level" >
	      <param type="INTEGER" />
	    </keyword>
	    <keyword  id="expansion_order" name="expansion_order" code="{N_mom(ushint,adaptedBasisExpOrder)}" label="Adapted Basis Expansion Order" >
	      <param type="INTEGER" />
	      <keyword  id="collocation_ratio4" name="collocation_ratio" code="{N_mom(Real,adaptedBasisCollocRatio)}" label="Adapted Basis Collocation Ratio" >
		<param type="REAL" />
	      </keyword>
	    </keyword>
	  </oneOf>
	  <!-- TO DO: adaptation specification for testing higher-order and interaction terms for adapted basis. -->
	  <keyword  id="dimension" name="dimension" label="Dimension" code="{N_mom(int,subspaceDimension)}" minOccurs="0">
            <param type="INTEGER" />
	  </keyword>
          <keyword  id="rotation_method" name="rotation_method" code="{0}" label="Rule for obtaining the rotation matrix in Basis Adaptation"  minOccurs="0" default="norm" >
		<oneOf label="Rotation Method">
		<keyword  id="unranked" name="unranked" code="{N_mom(type,method_rotation_ROTATION_METHOD_UNRANKED)}" label="Unranked Gaussian variables for rotation matrix construction"   />
		<keyword  id="ranked" name="ranked" code="{N_mom(type,method_rotation_ROTATION_METHOD_RANKED)}" label="Ranked Gaussian variables for rotation matrix construction"   />
		</oneOf>
                </keyword>
	  </keyword>
          <keyword  id="truncation_tolerance" name="truncation_tolerance" label="Truncation Tolerance" code="{N_mom(Real,adaptedBasisTruncationTolerance)}"  minOccurs="0" default="0.8" >
              <param type="REAL" />
          </keyword>
	</keyword>
	<keyword  id="random_field" name="random_field" code="{N_mom(lit,modelType_random_field)}" label="Random Field"  complexity="1">
	  <keyword id="build_source" name="build_source" code="{0}" label="Build Source" minOccurs="0">
	    <oneOf label="Build Data Source">
	          <keyword  id="rf_data_file" name="rf_data_file" code="{N_mom(str,rfDataFileName)}" label="Random Field Data File Name" default="none">
		<param type="STRING" />
              </keyword>
	      <keyword  id="dace_method_pointer1" name="dace_method_pointer" code="{N_mom(str,subMethodPointer)}" label="Design of Experiments Method Pointer"  default="no design of experiments data" >
                <param type="STRING" in_taglist="method" />
              </keyword>
	          <keyword id="analytic_covariance" name="analytic_covariance" label="Analytic Covariance" code="{0}" >
	        <oneOf label="Covariance Kernel Form">
	              <keyword id="squared_exponential" name="squared_exponential" label="Squared Covariance" code="{N_mom(utype,analyticCovIdForm_EXP_L2)}" />
	              <keyword id="exponential" name="exponential" label="Exponential" code="{N_mom(utype,analyticCovIdForm_EXP_L1)}" />
	        </oneOf>
	      </keyword>
	    </oneOf>
          </keyword>
	      <keyword id="expansion_form" name="expansion_form" label="Expansion Form" code="{0}" minOccurs="0">
	    <oneOf label="Reduced Basis Type">
	          <keyword id="karhunen_loeve" name="karhunen_loeve" label="Karhunen-Loeve" code="{N_mom(utype,randomFieldIdForm_RF_KARHUNEN_LOEVE)}" />
	          <keyword id="principal_components" name="principal_components" label="Principal Components" code="{N_mom(utype,randomFieldIdForm_RF_PCA_GP)}" />
	    </oneOf>
	  </keyword>
	      <keyword  id="expansion_bases" name="expansion_bases" code="{N_mom(int,subspaceDimension)}" label="Expansion Bases"  minOccurs="0" >
	    <param type="INTEGER" />
	  </keyword>
	      <keyword  id="truncation_tolerance" name="truncation_tolerance" code="{N_mom(Real,truncationTolerance)}" label="Truncation Tolerance"  minOccurs="0" >
	    <param type="REAL" />
	  </keyword>
	      <keyword  id="propagation_model_pointer" name="propagation_model_pointer" code="{N_mom(str,propagationModelPointer)}" label="Pointer to Model Accepting RF"  >
	    <param type="STRING" in_taglist="model" />
	  </keyword>
        </keyword>
    </oneOf>
     <keyword  id="variables_pointer" name="variables_pointer" code="{N_mom(str,variablesPointer)}" label="Variables Pointer"  minOccurs="0" default="model use of last variables parsed" complexity="0">
       <param type="STRING" in_taglist="variables" />
     </keyword>
     <keyword  id="responses_pointer" name="responses_pointer" code="{N_mom(str,responsesPointer)}" label="Responses Pointer"  minOccurs="0" default="model use of last responses parsed" complexity="0">
       <param type="STRING" in_taglist="responses" />
     </keyword>
     <keyword  id="hierarchical_tagging" name="hierarchical_tagging" code="{N_mom(true,hierarchicalTags)}" label="Hierarchical Evaluation Tags"  minOccurs="0" default="no hierarchical tagging" complexity="1" />
    </keyword>

    <!-- **** TOPLEVEL *** -->
    <keyword id="variables" name="variables" maxOccurs="unbounded" code="{N_vam3(start,0,stop)}" label="Variables" >
      <keyword  id="id_variables" name="id_variables" code="{N_vam(str,idVariables)}" label="Variables set identifier"  minOccurs="0" default="use of last variables parsed" >
        <param type="STRING" taglist="variables" />
      </keyword>
      <keyword  id="active" name="active" code="{0}" label="Active variables"  minOccurs="0" default="Infer from response or method specification" >
        <oneOf label="Active Variables">
          <keyword  id="all1" name="all" code="{N_vam(type,varsView_ALL_VIEW)}" label="all"   />
          <keyword  id="design" name="design" code="{N_vam(type,varsView_DESIGN_VIEW)}" label="design"   />
          <keyword  id="uncertain" name="uncertain" code="{N_vam(type,varsView_UNCERTAIN_VIEW)}" label="uncertain"   />
          <keyword  id="aleatory" name="aleatory" code="{N_vam(type,varsView_ALEATORY_UNCERTAIN_VIEW)}" label="aleatory"   />
          <keyword  id="epistemic" name="epistemic" code="{N_vam(type,varsView_EPISTEMIC_UNCERTAIN_VIEW)}" label="epistemic"   />
          <keyword  id="state" name="state" code="{N_vam(type,varsView_STATE_VIEW)}" label="state"   />
        </oneOf>
      </keyword>
      <optional>
        <oneOf label="Variable Domain">
          <keyword  id="mixed" name="mixed" code="{N_vam(type,varsDomain_MIXED_DOMAIN)}" label="mixed"   default="relaxed (branch and bound), mixed (all other methods)" />
          <keyword  id="relaxed" name="relaxed" code="{N_vam(type,varsDomain_RELAXED_DOMAIN)}" label="relaxed"   />
        </oneOf>
      </optional>
      <keyword  id="continuous_design" name="continuous_design" code="{N_vam(sizet,numContinuousDesVars)}" label="Continuous design variables"  minOccurs="0" group="Design Variables" default="no continuous design variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="initial_point" name="initial_point" code="{N_vam(rvec,continuousDesignVars)}" label="Initial point"  minOccurs="0" default="0.0" >
          <alias name="cdv_initial_point"/>
          <param type="REALLIST" constraint="LEN continuous_design" />
        </keyword>
        <keyword  id="lower_bounds" name="lower_bounds" code="{N_vam(rvec,continuousDesignLowerBnds)}" label="Lower bounds"  minOccurs="0" default="-infinity" >
          <alias name="cdv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN continuous_design" />
        </keyword>
        <keyword  id="upper_bounds" name="upper_bounds" code="{N_vam(rvec,continuousDesignUpperBnds)}" label="Upper bounds"  minOccurs="0" default="infinity" >
          <alias name="cdv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN continuous_design" />
        </keyword>
        <keyword  id="scale_types" name="scale_types" code="{N_vam(strL,continuousDesignScaleTypes)}" label="Scaling types"  minOccurs="0" default="vector values = 'none'" >
          <alias name="cdv_scale_types"/>
          <param type="STRINGLIST" constraint="LEN1 continuous_design" />
        </keyword>
        <keyword  id="scales" name="scales" code="{N_vam(rvec,continuousDesignScales)}" label="Scales"  minOccurs="0" default="vector values = 1 . (no scaling)" >
          <alias name="cdv_scales"/>
          <param type="REALLIST" constraint="LEN1 continuous_design" />
        </keyword>
        <keyword  id="descriptors" name="descriptors" code="{N_vam(strL,continuousDesignLabels)}" label="Descriptors"  minOccurs="0" default="cdv_{i}" >
          <alias name="cdv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN continuous_design" />
        </keyword>
      </keyword>
      <keyword  id="discrete_design_range" name="discrete_design_range" code="{N_vam(sizet,numDiscreteDesRangeVars)}" label="Discrete design range variables"  minOccurs="0" group="Design Variables" default="no discrete design variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="initial_point1" name="initial_point" code="{N_vam(ivec,discreteDesignRangeVars)}" label="Initial point"  minOccurs="0" default="0" >
          <alias name="ddv_initial_point"/>
          <param type="INTEGERLIST" constraint="LEN discrete_design_range" />
        </keyword>
        <keyword  id="lower_bounds1" name="lower_bounds" code="{N_vam(ivec,discreteDesignRangeLowerBnds)}" label="Lower bounds"  minOccurs="0" default="INT_MIN" >
          <alias name="ddv_lower_bounds"/>
          <param type="INTEGERLIST" constraint="LEN discrete_design_range" />
        </keyword>
        <keyword  id="upper_bounds1" name="upper_bounds" code="{N_vam(ivec,discreteDesignRangeUpperBnds)}" label="Upper bounds"  minOccurs="0" default="INT_MAX" >
          <alias name="ddv_upper_bounds"/>
          <param type="INTEGERLIST" constraint="LEN discrete_design_range" />
        </keyword>
        <keyword  id="descriptors1" name="descriptors" code="{N_vam(strL,discreteDesignRangeLabels)}" label="Descriptors"  minOccurs="0" default="ddriv_{i}" >
          <alias name="ddv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN discrete_design_range" />
        </keyword>
      </keyword>
      <keyword  id="discrete_design_set" name="discrete_design_set" code="{0}" label="discrete_design_set"  minOccurs="0" group="Design Variables" >
        <keyword  id="integer" name="integer" code="{N_vam(sizet,numDiscreteDesSetIntVars)}" label="integer"  minOccurs="0" default="no discrete design set integer variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_nddsi)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 integer" />
          </keyword>
          <keyword  id="elements" name="elements" code="{N_vam(newivec,Var_Info_ddsi)}" label="elements"   >
            <alias name="set_values"/>
            <param type="INTEGERLIST" />
          </keyword>
          <keyword  id="categorical" name="categorical" code="{N_vam(categorical,discreteDesignSetIntCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN integer" />
              <keyword id="adjacency_matrix" name="adjacency_matrix" code="{N_vam(newivec,Var_Info_ddsia)}" label="adjacency_matrix"  minOccurs="0">
                <param type="INTEGERLIST"/>
              </keyword>
          </keyword>
          <keyword  id="initial_point2" name="initial_point" code="{N_vam(ivec,discreteDesignSetIntVars)}" label="Initial point"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="descriptors2" name="descriptors" code="{N_vam(strL,discreteDesignSetIntLabels)}" label="Descriptors"  minOccurs="0" default="ddsiv_{i}">
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
        </keyword>
        <keyword  id="string" name="string" code="{N_vam(sizet,numDiscreteDesSetStrVars)}" label="string"  minOccurs="0" default="no discrete design set string variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable1" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_nddss)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 string" />
          </keyword>
          <keyword  id="elements1" name="elements" code="{N_vam(newsarray,Var_Info_ddss)}" label="elements"   >
            <alias name="set_values"/>
            <param type="STRINGLIST" />
          </keyword>
          <keyword id="adjacency_matrix1" name="adjacency_matrix" code="{N_vam(newivec,Var_Info_ddssa)}" label="adjacency_matrix"  minOccurs="0">
            <param type="INTEGERLIST"/>
          </keyword>
          <keyword  id="initial_point3" name="initial_point" code="{N_vam(strL,discreteDesignSetStrVars)}" label="Initial point"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="descriptors3" name="descriptors" code="{N_vam(strL,discreteDesignSetStrLabels)}" label="Descriptors"  minOccurs="0"  default="ddssv_{i}" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
        </keyword>
        <keyword  id="real" name="real" code="{N_vam(sizet,numDiscreteDesSetRealVars)}" label="real"  minOccurs="0" default="no discrete design set real variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable2" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_nddsr)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 real" />
          </keyword>
          <keyword  id="elements2" name="elements" code="{N_vam(newrvec,Var_Info_ddsr)}" label="elements"   >
            <alias name="set_values"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="categorical1" name="categorical" code="{N_vam(categorical,discreteDesignSetRealCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN integer" />
            <keyword id="adjacency_matrix2" name="adjacency_matrix" code="{N_vam(newivec,Var_Info_ddsra)}" label="adjacency_matrix"  minOccurs="0">
              <param type="INTEGERLIST"/>
            </keyword>
          </keyword>
          <keyword  id="initial_point4" name="initial_point" code="{N_vam(rvec,discreteDesignSetRealVars)}" label="initial_point"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="REALLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="descriptors4" name="descriptors" code="{N_vam(strL,discreteDesignSetRealLabels)}" label="Descriptors"  minOccurs="0"  default="ddsrv_{i}" >
            <param type="STRINGLIST" constraint="LEN real" />
          </keyword>
        </keyword>
      </keyword>
      <keyword  id="normal_uncertain" name="normal_uncertain" code="{N_vam(sizet,numNormalUncVars)}" label="normal uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no normal uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="means" name="means" code="{N_vam(rvec,normalUncMeans)}" label="normal uncertain means"   >
          <alias name="nuv_means"/>
          <param type="REALLIST" constraint="LEN normal_uncertain" />
        </keyword>
        <keyword  id="std_deviations" name="std_deviations" code="{N_vam(RealLb,normalUncStdDevs)}" label="normal uncertain standard deviations"   >
          <alias name="nuv_std_deviations"/>
          <param type="REALLIST" constraint="LEN normal_uncertain" />
        </keyword>
        <keyword  id="lower_bounds2" name="lower_bounds" code="{N_vam(rvec,normalUncLowerBnds)}" label="Distribution lower bounds"  minOccurs="0" default="-infinity" >
          <alias name="nuv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN normal_uncertain" />
        </keyword>
        <keyword  id="upper_bounds2" name="upper_bounds" code="{N_vam(rvec,normalUncUpperBnds)}" label="Distribution upper bounds"  minOccurs="0" default="infinity" >
          <alias name="nuv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN normal_uncertain" />
        </keyword>
        <keyword  id="initial_point5" name="initial_point" code="{N_vam(rvec,normalUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN normal_uncertain" />
        </keyword>
        <keyword  id="descriptors5" name="descriptors" code="{N_vae(caulbl,CAUVar_normal)}" label="Descriptors"  minOccurs="0" default="nuv_{i}" >
          <alias name="nuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN normal_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="lognormal_uncertain" name="lognormal_uncertain" code="{N_vam(sizet,numLognormalUncVars)}" label="lognormal uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no lognormal uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <oneOf label="Lognormal Characterization">
          <keyword  id="lambdas" name="lambdas" code="{N_vam(rvec,lognormalUncLambdas)}" label="lognormal uncertain lambdas"  >
            <alias name="lnuv_lambdas"/>
            <param type="REALLIST" constraint="LEN lognormal_uncertain" />
            <keyword  id="zetas" name="zetas" code="{N_vam(RealLb,lognormalUncZetas)}" label="lognormal uncertain zetas"   >
              <alias name="lnuv_zetas"/>
              <param type="REALLIST" constraint="LEN lognormal_uncertain" />
            </keyword>
          </keyword>
          <keyword  id="means1" name="means" code="{N_vam(RealLb,lognormalUncMeans)}" label="lognormal uncertain means"  >
            <alias name="lnuv_means"/>
            <param type="REALLIST" constraint="LEN lognormal_uncertain" />
            <oneOf label="Spread">
              <keyword  id="std_deviations1" name="std_deviations" code="{N_vam(RealLb,lognormalUncStdDevs)}" label="lognormal uncertain standard deviations"   >
                <alias name="lnuv_std_deviations"/>
                <param type="REALLIST" constraint="LEN lognormal_uncertain" />
              </keyword>
              <keyword  id="error_factors" name="error_factors" code="{N_vam(RealLb,lognormalUncErrFacts)}" label="lognormal uncertain error factors"   >
                <alias name="lnuv_error_factors"/>
                <param type="REALLIST" constraint="LEN lognormal_uncertain" />
              </keyword>
            </oneOf>
          </keyword>
        </oneOf>
        <keyword  id="lower_bounds3" name="lower_bounds" code="{N_vam(RealLb,lognormalUncLowerBnds)}" label="Distribution lower bounds"  minOccurs="0" default="0" >
          <alias name="lnuv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN lognormal_uncertain" />
        </keyword>
        <keyword  id="upper_bounds3" name="upper_bounds" code="{N_vam(RealUb,lognormalUncUpperBnds)}" label="Distribution upper bounds"  minOccurs="0" default="infinity" >
          <alias name="lnuv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN lognormal_uncertain" />
        </keyword>
        <keyword  id="initial_point6" name="initial_point" code="{N_vam(RealLb,lognormalUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN lognormal_uncertain" />
        </keyword>
        <keyword  id="descriptors6" name="descriptors" code="{N_vae(caulbl,CAUVar_lognormal)}" label="Descriptors"  minOccurs="0" default="lnuv_{i}" >
          <alias name="lnuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN lognormal_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="uniform_uncertain" name="uniform_uncertain" code="{N_vam(sizet,numUniformUncVars)}" label="uniform uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no uniform uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="lower_bounds4" name="lower_bounds" code="{N_vam(RealLb,uniformUncLowerBnds)}" label="Distribution lower bounds"   >
          <alias name="uuv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN uniform_uncertain" />
        </keyword>
        <keyword  id="upper_bounds4" name="upper_bounds" code="{N_vam(RealUb,uniformUncUpperBnds)}" label="Distribution upper bounds"   >
          <alias name="uuv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN uniform_uncertain" />
        </keyword>
        <keyword  id="initial_point7" name="initial_point" code="{N_vam(rvec,uniformUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN uniform_uncertain" />
        </keyword>
        <keyword  id="descriptors7" name="descriptors" code="{N_vae(caulbl,CAUVar_uniform)}" label="Descriptors"  minOccurs="0" default="uuv_{i}" >
          <alias name="uuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN uniform_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="loguniform_uncertain" name="loguniform_uncertain" code="{N_vam(sizet,numLoguniformUncVars)}" label="loguniform uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no loguniform uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="lower_bounds5" name="lower_bounds" code="{N_vam(RealLb,loguniformUncLowerBnds)}" label="Distribution lower bounds"   >
          <alias name="luuv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN loguniform_uncertain" />
        </keyword>
        <keyword  id="upper_bounds5" name="upper_bounds" code="{N_vam(RealUb,loguniformUncUpperBnds)}" label="Distribution upper bounds"   >
          <alias name="luuv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN loguniform_uncertain" />
        </keyword>
        <keyword  id="initial_point8" name="initial_point" code="{N_vam(RealLb,loguniformUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN loguniform_uncertain" />
        </keyword>
        <keyword  id="descriptors8" name="descriptors" code="{N_vae(caulbl,CAUVar_loguniform)}" label="Descriptors"  minOccurs="0" default="luuv_{i}" >
          <alias name="luuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN loguniform_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="triangular_uncertain" name="triangular_uncertain" code="{N_vam(sizet,numTriangularUncVars)}" label="triangular uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no triangular uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="modes" name="modes" code="{N_vam(rvec,triangularUncModes)}" label="triangular uncertain modes"   >
          <alias name="tuv_modes"/>
          <param type="REALLIST" constraint="LEN triangular_uncertain" />
        </keyword>
        <keyword  id="lower_bounds6" name="lower_bounds" code="{N_vam(RealLb,triangularUncLowerBnds)}" label="Distribution lower bounds"   >
          <alias name="tuv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN triangular_uncertain" />
        </keyword>
        <keyword  id="upper_bounds6" name="upper_bounds" code="{N_vam(RealUb,triangularUncUpperBnds)}" label="Distribution upper bounds"   >
          <alias name="tuv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN triangular_uncertain" />
        </keyword>
        <keyword  id="initial_point9" name="initial_point" code="{N_vam(rvec,triangularUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN triangular_uncertain" />
        </keyword>
        <keyword  id="descriptors9" name="descriptors" code="{N_vae(caulbl,CAUVar_triangular)}" label="Descriptors"  minOccurs="0" default="tuv_{i}" >
          <alias name="tuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN triangular_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="exponential_uncertain" name="exponential_uncertain" code="{N_vam(sizet,numExponentialUncVars)}" label="exponential uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no exponential uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="betas" name="betas" code="{N_vam(RealLb,exponentialUncBetas)}" label="exponential uncertain betas"   >
          <alias name="euv_betas"/>
          <param type="REALLIST" constraint="LEN exponential_uncertain" />
        </keyword>
        <keyword  id="initial_point10" name="initial_point" code="{N_vam(RealLb,exponentialUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN exponential_uncertain" />
        </keyword>
        <keyword  id="descriptors10" name="descriptors" code="{N_vae(caulbl,CAUVar_exponential)}" label="Descriptors"  minOccurs="0" default="euv_{i}" >
          <alias name="euv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN exponential_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="beta_uncertain" name="beta_uncertain" code="{N_vam(sizet,numBetaUncVars)}" label="beta uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no beta uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="alphas" name="alphas" code="{N_vam(RealLb,betaUncAlphas)}" label="beta uncertain alphas"   >
          <alias name="buv_alphas"/>
          <param type="REALLIST" constraint="LEN beta_uncertain" />
        </keyword>
        <keyword  id="betas1" name="betas" code="{N_vam(RealLb,betaUncBetas)}" label="beta uncertain betas"   >
          <alias name="buv_betas"/>
          <param type="REALLIST" constraint="LEN beta_uncertain" />
        </keyword>
        <keyword  id="lower_bounds7" name="lower_bounds" code="{N_vam(rvec,betaUncLowerBnds)}" label="Distribution lower bounds"   >
          <alias name="buv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN beta_uncertain" />
        </keyword>
        <keyword  id="upper_bounds7" name="upper_bounds" code="{N_vam(rvec,betaUncUpperBnds)}" label="Distribution upper bounds"   >
          <alias name="buv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN beta_uncertain" />
        </keyword>
        <keyword  id="initial_point11" name="initial_point" code="{N_vam(rvec,betaUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN beta_uncertain" />
        </keyword>
        <keyword  id="descriptors11" name="descriptors" code="{N_vae(caulbl,CAUVar_beta)}" label="Descriptors"  minOccurs="0" default="buv_{i}" >
          <alias name="buv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN beta_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="gamma_uncertain" name="gamma_uncertain" code="{N_vam(sizet,numGammaUncVars)}" label="gamma uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no gamma uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="alphas1" name="alphas" code="{N_vam(RealLb,gammaUncAlphas)}" label="gamma uncertain alphas"   >
          <alias name="gauv_alphas"/>
          <param type="REALLIST" constraint="LEN gamma_uncertain" />
        </keyword>
        <keyword  id="betas2" name="betas" code="{N_vam(RealLb,gammaUncBetas)}" label="gamma uncertain betas"   >
          <alias name="gauv_betas"/>
          <param type="REALLIST" constraint="LEN gamma_uncertain" />
        </keyword>
        <keyword  id="initial_point12" name="initial_point" code="{N_vam(RealLb,gammaUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN gamma_uncertain" />
        </keyword>
        <keyword  id="descriptors12" name="descriptors" code="{N_vae(caulbl,CAUVar_gamma)}" label="Descriptors"  minOccurs="0" default="gauv_{i}" >
          <alias name="gauv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN gamma_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="gumbel_uncertain" name="gumbel_uncertain" code="{N_vam(sizet,numGumbelUncVars)}" label="gumbel uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no gumbel uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="alphas2" name="alphas" code="{N_vam(RealLb,gumbelUncAlphas)}" label="gumbel uncertain alphas"   >
          <alias name="guuv_alphas"/>
          <param type="REALLIST" constraint="LEN gumbel_uncertain" />
        </keyword>
        <keyword  id="betas3" name="betas" code="{N_vam(rvec,gumbelUncBetas)}" label="gumbel uncertain betas"   >
          <alias name="guuv_betas"/>
          <param type="REALLIST" constraint="LEN gumbel_uncertain" />
        </keyword>
        <keyword  id="initial_point13" name="initial_point" code="{N_vam(rvec,gumbelUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN gumbel_uncertain" />
        </keyword>
        <keyword  id="descriptors13" name="descriptors" code="{N_vae(caulbl,CAUVar_gumbel)}" label="Descriptors"  minOccurs="0" default="guuv_{i}" >
          <alias name="guuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN gumbel_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="frechet_uncertain" name="frechet_uncertain" code="{N_vam(sizet,numFrechetUncVars)}" label="frechet uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no frechet uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="alphas3" name="alphas" code="{N_vam(RealLb,frechetUncAlphas)}" label="frechet uncertain alphas"   >
          <alias name="fuv_alphas"/>
          <param type="REALLIST" constraint="LEN frechet_uncertain" />
        </keyword>
        <keyword  id="betas4" name="betas" code="{N_vam(rvec,frechetUncBetas)}" label="frechet uncertain betas"   >
          <alias name="fuv_betas"/>
          <param type="REALLIST" constraint="LEN frechet_uncertain" />
        </keyword>
        <keyword  id="initial_point14" name="initial_point" code="{N_vam(rvec,frechetUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN frechet_uncertain" />
        </keyword>
        <keyword  id="descriptors14" name="descriptors" code="{N_vae(caulbl,CAUVar_frechet)}" label="Descriptors"  minOccurs="0" default="fuv_{i}" >
          <alias name="fuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN frechet_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="weibull_uncertain" name="weibull_uncertain" code="{N_vam(sizet,numWeibullUncVars)}" label="weibull uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no weibull uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="alphas4" name="alphas" code="{N_vam(RealLb,weibullUncAlphas)}" label="weibull uncertain alphas"   >
          <alias name="wuv_alphas"/>
          <param type="REALLIST" constraint="LEN weibull_uncertain" />
        </keyword>
        <keyword  id="betas5" name="betas" code="{N_vam(RealLb,weibullUncBetas)}" label="weibull uncertain betas"   >
          <alias name="wuv_betas"/>
          <param type="REALLIST" constraint="LEN weibull_uncertain" />
        </keyword>
        <keyword  id="initial_point15" name="initial_point" code="{N_vam(RealLb,weibullUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN weibull_uncertain" />
        </keyword>
        <keyword  id="descriptors15" name="descriptors" code="{N_vae(caulbl,CAUVar_weibull)}" label="Descriptors"  minOccurs="0" default="wuv_{i}" >
          <alias name="wuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN weibull_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="histogram_bin_uncertain" name="histogram_bin_uncertain" code="{N_vam(sizet,numHistogramBinUncVars)}" label="histogram bin uncertain variables"  minOccurs="0" group="Continuous Aleatory Uncertain" default="no histogram bin uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="pairs_per_variable3" name="pairs_per_variable" code="{N_vam(newiarray,Var_Info_nhbp)}" label="key to apportionment among bin-based histogram variables"  minOccurs="0" default="equal distribution" >
          <alias name="num_pairs"/>
          <param type="INTEGERLIST" constraint="LEN histogram_bin_uncertain" />
        </keyword>
        <keyword  id="abscissas" name="abscissas" code="{N_vam(newrvec,Var_Info_hba)}" label="sets of abscissas for bin-based histogram variables"   >
          <alias name="huv_bin_abscissas"/>
          <param type="REALLIST" />
        </keyword>
        <oneOf label="Density Values">
          <keyword  id="ordinates" name="ordinates" code="{N_vam(newrvec,Var_Info_hbo)}" label="sets of ordinates for bin-based histogram variables"   >
            <alias name="huv_bin_ordinates"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="counts" name="counts" code="{N_vam(newrvec,Var_Info_hbc)}" label="sets of counts for bin-based histogram variables"   >
            <alias name="huv_bin_counts"/>
            <param type="REALLIST" />
          </keyword>
        </oneOf>
        <keyword  id="initial_point16" name="initial_point" code="{N_vam(rvec,histogramBinUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN histogram_bin_uncertain" />
        </keyword>
        <keyword  id="descriptors16" name="descriptors" code="{N_vae(caulbl,CAUVar_histogram_bin)}" label="Descriptors"  minOccurs="0" default="hbuv_{i}" >
          <alias name="huv_bin_descriptors"/>
          <param type="STRINGLIST" constraint="LEN histogram_bin_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="poisson_uncertain" name="poisson_uncertain" code="{N_vam(sizet,numPoissonUncVars)}" label="poisson uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no poisson uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="lambdas1" name="lambdas" code="{N_vam(RealLb,poissonUncLambdas)}" label="poisson uncertain lambdas"   >
          <param type="REALLIST" constraint="LEN poisson_uncertain" />
        </keyword>
        <keyword  id="initial_point17" name="initial_point" code="{N_vam(IntLb,poissonUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN poisson_uncertain" />
        </keyword>
        <keyword  id="descriptors17" name="descriptors" code="{N_vae(dauilbl,DAUIVar_poisson)}" label="Descriptors"  minOccurs="0" default="puv_{i}" >
          <param type="STRINGLIST" constraint="LEN poisson_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="binomial_uncertain" name="binomial_uncertain" code="{N_vam(sizet,numBinomialUncVars)}" label="binomial uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no binomial uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="probability_per_trial" name="probability_per_trial" code="{N_vam(rvec,binomialUncProbPerTrial)}" label="probability_per_trial"   >
          <alias name="prob_per_trial"/>
          <param type="REALLIST" constraint="LEN binomial_uncertain" />
        </keyword>
        <keyword  id="num_trials1" name="num_trials" code="{N_vam(IntLb,binomialUncNumTrials)}" label="binomial uncertain num_trials"   >
          <param type="INTEGERLIST" constraint="LEN binomial_uncertain" />
        </keyword>
        <keyword  id="initial_point18" name="initial_point" code="{N_vam(IntLb,binomialUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN binomial_uncertain" />
        </keyword>
        <keyword  id="descriptors18" name="descriptors" code="{N_vae(dauilbl,DAUIVar_binomial)}" label="Descriptors"  minOccurs="0" default="biuv_{i}" >
          <param type="STRINGLIST" constraint="LEN binomial_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="negative_binomial_uncertain" name="negative_binomial_uncertain" code="{N_vam(sizet,numNegBinomialUncVars)}" label="negative binomial uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no negative binomial uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="probability_per_trial1" name="probability_per_trial" code="{N_vam(rvec,negBinomialUncProbPerTrial)}" label="probability_per_trial"   >
          <alias name="prob_per_trial"/>
          <param type="REALLIST" constraint="LEN negative_binomial_uncertain" />
        </keyword>
        <keyword  id="num_trials2" name="num_trials" code="{N_vam(IntLb,negBinomialUncNumTrials)}" label="negative binomial uncertain success num_trials"   >
          <param type="INTEGERLIST" constraint="LEN negative_binomial_uncertain" />
        </keyword>
        <keyword  id="initial_point19" name="initial_point" code="{N_vam(IntLb,negBinomialUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN negative_binomial_uncertain" />
        </keyword>
        <keyword  id="descriptors19" name="descriptors" code="{N_vae(dauilbl,DAUIVar_negative_binomial)}" label="Descriptors"  minOccurs="0" default="nbuv_{i}" >
          <param type="STRINGLIST" constraint="LEN negative_binomial_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="geometric_uncertain" name="geometric_uncertain" code="{N_vam(sizet,numGeometricUncVars)}" label="geometric uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no geometric uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="probability_per_trial2" name="probability_per_trial" code="{N_vam(rvec,geometricUncProbPerTrial)}" label="probability_per_trial"   >
          <alias name="prob_per_trial"/>
          <param type="REALLIST" constraint="LEN geometric_uncertain" />
        </keyword>
        <keyword  id="initial_point20" name="initial_point" code="{N_vam(IntLb,geometricUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN geometric_uncertain" />
        </keyword>
        <keyword  id="descriptors20" name="descriptors" code="{N_vae(dauilbl,DAUIVar_geometric)}" label="Descriptors"  minOccurs="0" default="geuv_{i}" >
          <param type="STRINGLIST" constraint="LEN geometric_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="hypergeometric_uncertain" name="hypergeometric_uncertain" code="{N_vam(sizet,numHyperGeomUncVars)}" label="hypergeometric uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no hypergeometric uncertain variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="total_population" name="total_population" code="{N_vam(IntLb,hyperGeomUncTotalPop)}" label="hypergeometric uncertain total_population"   >
          <param type="INTEGERLIST" constraint="LEN hypergeometric_uncertain" />
        </keyword>
        <keyword  id="selected_population" name="selected_population" code="{N_vam(IntLb,hyperGeomUncSelectedPop)}" label="hypergeometric uncertain selected_population"   >
          <param type="INTEGERLIST" constraint="LEN hypergeometric_uncertain" />
        </keyword>
        <keyword  id="num_drawn" name="num_drawn" code="{N_vam(IntLb,hyperGeomUncNumDrawn)}" label="hypergeometric uncertain num_drawn "   >
          <param type="INTEGERLIST" constraint="LEN hypergeometric_uncertain" />
        </keyword>
        <keyword  id="initial_point21" name="initial_point" code="{N_vam(IntLb,hyperGeomUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN hypergeometric_uncertain" />
        </keyword>
        <keyword  id="descriptors21" name="descriptors" code="{N_vae(dauilbl,DAUIVar_hypergeometric)}" label="Descriptors"  minOccurs="0" default="hguv_{i}" >
          <param type="STRINGLIST" constraint="LEN hypergeometric_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="histogram_point_uncertain" name="histogram_point_uncertain" code="{0}" label="histogram point uncertain variables"  minOccurs="0" group="Discrete Aleatory Uncertain" default="no histogram point uncertain variables" >
        <keyword  id="integer1" name="integer" code="{N_vam(sizet,numHistogramPtIntUncVars)}" label="integer"  minOccurs="0" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="pairs_per_variable" name="pairs_per_variable" code="{N_vam(newiarray,Var_Info_nhpip)}" label="pairs_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_pairs"/>
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="abscissas1" name="abscissas" code="{N_vam(newivec,Var_Info_hpia)}" label="sets of abscissas for point-based histogram variables"   >
            <param type="INTEGERLIST" />
          </keyword>
          <keyword  id="counts1" name="counts" code="{N_vam(newrvec,Var_Info_hpic)}" label="sets of counts for point-based histogram variables"   >
            <param type="REALLIST" />
          </keyword>
          <keyword  id="initial_point22" name="initial_point" code="{N_vam(ivec,histogramPointIntUncVars)}" label="initial_point"  minOccurs="0" >
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="descriptors22" name="descriptors" code="{N_vae(dauilbl,DAUIVar_histogram_point_int)}" label="Descriptors"  minOccurs="0" default="hpiv_{i}" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
        </keyword>
        <keyword  id="string1" name="string" code="{N_vam(sizet,numHistogramPtStrUncVars)}" label="string"  minOccurs="0" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="pairs_per_variable1" name="pairs_per_variable" code="{N_vam(newiarray,Var_Info_nhpsp)}" label="pairs_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_pairs"/>
            <param type="INTEGERLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="abscissas2" name="abscissas" code="{N_vam(newsarray,Var_Info_hpsa)}" label="abscissas"   >
            <param type="STRINGLIST" />
          </keyword>
          <keyword  id="counts2" name="counts" code="{N_vam(newrvec,Var_Info_hpsc)}" label="counts"   >
            <param type="REALLIST" />
          </keyword>
          <keyword  id="initial_point23" name="initial_point" code="{N_vam(strL,histogramPointStrUncVars)}" label="initial_point"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="descriptors23" name="descriptors" code="{N_vae(dauslbl,DAUSVar_histogram_point_str)}" label="Descriptors"  minOccurs="0" default="hpsv_{i}" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
        </keyword>
        <keyword  id="real1" name="real" code="{N_vam(sizet,numHistogramPtRealUncVars)}" label="real"  minOccurs="0" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="pairs_per_variable2" name="pairs_per_variable" code="{N_vam(newiarray,Var_Info_nhprp)}" label="pairs_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_pairs"/>
            <param type="INTEGERLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="abscissas3" name="abscissas" code="{N_vam(newrvec,Var_Info_hpra)}" label="abscissas"   >
            <param type="REALLIST" />
          </keyword>
          <keyword  id="counts3" name="counts" code="{N_vam(newrvec,Var_Info_hprc)}" label="counts"   >
            <param type="REALLIST" />
          </keyword>
          <keyword  id="initial_point24" name="initial_point" code="{N_vam(rvec,histogramPointRealUncVars)}" label="initial_point"  minOccurs="0" >
            <param type="REALLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="descriptors24" name="descriptors" code="{N_vae(daurlbl,DAURVar_histogram_point_real)}" label="Descriptors"  minOccurs="0" default="hpruv_{i}" >
            <param type="STRINGLIST" constraint="LEN real" />
          </keyword>
        </keyword>
      </keyword>
      <keyword  id="uncertain_correlation_matrix" name="uncertain_correlation_matrix" code="{N_vam(newrvec,Var_Info_ucm)}" label="correlations in aleatory uncertain variables"  minOccurs="0" group="Aleatory Uncertain Correlations" default="identity matrix (uncorrelated)" >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="continuous_interval_uncertain" name="continuous_interval_uncertain" code="{N_vam(sizet,numContinuousIntervalUncVars)}" label="continuous interval uncertain variables"  minOccurs="0" group="Epistemic Uncertain" default="no continuous interval uncertain variables" >
        <alias name="interval_uncertain"/>
        <!-- <alias name="continuous_uncertain_range"/> Interval consists of multiple BPA ranges -->
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="num_intervals" name="num_intervals" code="{N_vam(newiarray,Var_Info_nCI)}" label="number of intervals defined for each continuous interval variable"  minOccurs="0" default="Equal apportionment of intervals among variables" >
          <alias name="iuv_num_intervals"/>
          <param type="INTEGERLIST" constraint="LEN continuous_interval_uncertain" />
        </keyword>
        <keyword  id="interval_probabilities" name="interval_probabilities" code="{N_vam(newrvec,Var_Info_CIp)}" label="basic probability assignments per continuous interval"  minOccurs="0" default="Equal probability assignments for each interval (1/num_intervals[i])" >
          <alias name="interval_probs"/>
          <alias name="iuv_interval_probs"/>
          <param type="REALLIST" />
        </keyword>
        <keyword  id="lower_bounds8" name="lower_bounds" code="{N_vam(newrvec,Var_Info_CIlb)}" label="lower bounds of continuous intervals"   >
          <param type="REALLIST" />
        </keyword>
        <keyword  id="upper_bounds8" name="upper_bounds" code="{N_vam(newrvec,Var_Info_CIub)}" label="upper bounds of continuous intervals"   >
          <param type="REALLIST" />
        </keyword>
        <keyword  id="initial_point25" name="initial_point" code="{N_vam(rvec,continuousIntervalUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="REALLIST" constraint="LEN continuous_interval_uncertain" />
        </keyword>
        <keyword  id="descriptors25" name="descriptors" code="{N_vae(ceulbl,CEUVar_interval)}" label="Descriptors"  minOccurs="0" default="ciuv_{i}" >
          <alias name="iuv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN continuous_interval_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="discrete_interval_uncertain" name="discrete_interval_uncertain" code="{N_vam(sizet,numDiscreteIntervalUncVars)}" label="Discrete interval uncertain variables"  minOccurs="0" group="Epistemic Uncertain" default="No discrete interval uncertain variables" >
        <!-- <alias name="discrete_uncertain_range"/> Interval consists of multiple BPA ranges -->
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="num_intervals1" name="num_intervals" code="{N_vam(newiarray,Var_Info_nDI)}" label="Number of intervals defined for each interval variable"  minOccurs="0" default="Equal apportionment of intervals among variables" >
          <param type="INTEGERLIST" constraint="LEN discrete_interval_uncertain" />
        </keyword>
        <keyword  id="interval_probabilities1" name="interval_probabilities" code="{N_vam(newrvec,Var_Info_DIp)}" label="Basic probability assignments per interval"  minOccurs="0" default="Equal probability assignments for each interval (1/num_intervals[i])" >
          <alias name="interval_probs"/>
          <alias name="range_probabilities"/>
          <alias name="range_probs"/>
          <param type="REALLIST" />
        </keyword>
        <keyword  id="lower_bounds9" name="lower_bounds" code="{N_vam(newivec,Var_Info_DIlb)}" label="Lower bounds"   >
          <param type="INTEGERLIST" />
        </keyword>
        <keyword  id="upper_bounds9" name="upper_bounds" code="{N_vam(newivec,Var_Info_DIub)}" label="Upper bounds"   >
          <param type="INTEGERLIST" />
        </keyword>
        <keyword  id="initial_point26" name="initial_point" code="{N_vam(ivec,discreteIntervalUncVars)}" label="initial_point"  minOccurs="0" >
          <param type="INTEGERLIST" constraint="LEN discrete_interval_uncertain" />
        </keyword>
        <keyword  id="descriptors26" name="descriptors" code="{N_vae(deuilbl,DEUIVar_interval)}" label="Descriptors"  minOccurs="0" default="diuv_{i}" >
          <param type="STRINGLIST" constraint="LEN discrete_interval_uncertain" />
        </keyword>
      </keyword>
      <keyword  id="discrete_uncertain_set" name="discrete_uncertain_set" code="{0}" label="discrete_uncertain_set"  minOccurs="0" group="Epistemic Uncertain" >
        <keyword  id="integer2" name="integer" code="{N_vam(sizet,numDiscreteUncSetIntVars)}" label="integer"  minOccurs="0" default="no discrete uncertain set integer variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable3" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_ndusi)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="elements3" name="elements" code="{N_vam(newivec,Var_Info_dusi)}" label="elements"   >
            <alias name="set_values"/>
            <param type="INTEGERLIST" />
          </keyword>
          <!-- BMA TODO: change these semantics from probability to epistemic terms? -->
          <keyword  id="set_probabilities" name="set_probabilities" code="{N_vam(newrvec,Var_Info_DSIp)}" label="Probabilities for each set member"  minOccurs="0" default="Equal probability assignments for each set member (1/num_set_values[i])" >
            <alias name="set_probs"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="categorical2" name="categorical" code="{N_vam(categorical,discreteUncSetIntCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="initial_point27" name="initial_point" code="{N_vam(ivec,discreteUncSetIntVars)}" label="initial_point"  minOccurs="0" >
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="descriptors27" name="descriptors" code="{N_vae(deuilbl,DEUIVar_set_int)}" label="Descriptors"  minOccurs="0" default="dusiv_{i}" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
        </keyword>
        <keyword  id="string2" name="string" code="{N_vam(sizet,numDiscreteUncSetStrVars)}" label="string"  minOccurs="0" default="no discrete uncertain set string variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable4" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_nduss)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="elements4" name="elements" code="{N_vam(newsarray,Var_Info_duss)}" label="elements"   >
            <alias name="set_values"/>
            <param type="STRINGLIST" />
          </keyword>
          <!-- BMA TODO: change these semantics from probability to epistemic terms? -->
          <keyword  id="set_probabilities1" name="set_probabilities" code="{N_vam(newrvec,Var_Info_DSSp)}" label="Probabilities for each set member"  minOccurs="0" default="Equal probability assignments for each set member (1/num_set_values[i])" >
            <alias name="set_probs"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="initial_point28" name="initial_point" code="{N_vam(strL,discreteUncSetStrVars)}" label="initial_point"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="descriptors28" name="descriptors" code="{N_vae(deuslbl,DEUSVar_set_str)}" label="Descriptors"  minOccurs="0" default="dussv_{i}" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
        </keyword>
        <keyword  id="real2" name="real" code="{N_vam(sizet,numDiscreteUncSetRealVars)}" label="real"  minOccurs="0" default="no discrete uncertain set real variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable5" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_ndusr)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="elements5" name="elements" code="{N_vam(newrvec,Var_Info_dusr)}" label="elements"   >
            <alias name="set_values"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="set_probabilities2" name="set_probabilities" code="{N_vam(newrvec,Var_Info_DSRp)}" label="set_probabilities"  minOccurs="0" default="Equal probability assignments for each set member (1/num_set_values[i])" >
            <alias name="set_probs"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="categorical3" name="categorical" code="{N_vam(categorical,discreteUncSetRealCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="initial_point29" name="initial_point" code="{N_vam(rvec,discreteUncSetRealVars)}" label="initial_point"  minOccurs="0" >
            <param type="REALLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="descriptors29" name="descriptors" code="{N_vae(deurlbl,DEURVar_set_real)}" label="Descriptors"  minOccurs="0" default="dusrv_{i}" >
            <param type="STRINGLIST" constraint="LEN real" />
          </keyword>
        </keyword>
      </keyword>
      <keyword  id="continuous_state" name="continuous_state" code="{N_vam(sizet,numContinuousStateVars)}" label="Continuous state variables"  minOccurs="0" group="State Variables" default="No continuous state variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="initial_state" name="initial_state" code="{N_vam(rvec,continuousStateVars)}" label="Initial states"  minOccurs="0" default="0.0" >
          <alias name="csv_initial_state"/>
          <param type="REALLIST" constraint="LEN continuous_state" />
        </keyword>
        <keyword  id="lower_bounds10" name="lower_bounds" code="{N_vam(rvec,continuousStateLowerBnds)}" label="Lower bounds"  minOccurs="0" default="-infinity" >
          <alias name="csv_lower_bounds"/>
          <param type="REALLIST" constraint="LEN continuous_state" />
        </keyword>
        <keyword  id="upper_bounds10" name="upper_bounds" code="{N_vam(rvec,continuousStateUpperBnds)}" label="Upper bounds"  minOccurs="0" default="infinity" >
          <alias name="csv_upper_bounds"/>
          <param type="REALLIST" constraint="LEN continuous_state" />
        </keyword>
        <keyword  id="descriptors30" name="descriptors" code="{N_vam(strL,continuousStateLabels)}" label="descriptors"  minOccurs="0" default="csv_{i}" >
          <alias name="csv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN continuous_state" />
        </keyword>
      </keyword>
      <keyword  id="discrete_state_range" name="discrete_state_range" code="{N_vam(sizet,numDiscreteStateRangeVars)}" label="Discrete state range variables"  minOccurs="0" group="State Variables" default="No discrete state variables" >
        <param type="INTEGER" constraint="> 0" />
        <keyword  id="initial_state1" name="initial_state" code="{N_vam(ivec,discreteStateRangeVars)}" label="Initial states"  minOccurs="0" default="0" >
          <alias name="dsv_initial_state"/>
          <param type="INTEGERLIST" constraint="LEN discrete_state_range" />
        </keyword>
        <keyword  id="lower_bounds11" name="lower_bounds" code="{N_vam(ivec,discreteStateRangeLowerBnds)}" label="Lower bounds"  minOccurs="0" default="INT_MIN" >
          <alias name="dsv_lower_bounds"/>
          <param type="INTEGERLIST" constraint="LEN discrete_state_range" />
        </keyword>
        <keyword  id="upper_bounds11" name="upper_bounds" code="{N_vam(ivec,discreteStateRangeUpperBnds)}" label="Upper bounds"  minOccurs="0" default="INT_MAX" >
          <alias name="dsv_upper_bounds"/>
          <param type="INTEGERLIST" constraint="LEN discrete_state_range" />
        </keyword>
        <keyword  id="descriptors31" name="descriptors" code="{N_vam(strL,discreteStateRangeLabels)}" label="descriptors"  minOccurs="0" default="dsriv_{i}" >
          <alias name="dsv_descriptors"/>
          <param type="STRINGLIST" constraint="LEN discrete_state_range" />
        </keyword>
      </keyword>
      <keyword  id="discrete_state_set" name="discrete_state_set" code="{0}" label="discrete_state_set"  minOccurs="0" group="State Variables" >
        <keyword  id="integer3" name="integer" code="{N_vam(sizet,numDiscreteStateSetIntVars)}" label="integer"  minOccurs="0" default="no discrete state set integer variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable6" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_ndssi)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 integer" />
          </keyword>
          <keyword  id="elements6" name="elements" code="{N_vam(newivec,Var_Info_dssi)}" label="elements"   >
            <alias name="set_values"/>
            <param type="INTEGERLIST" />
          </keyword>
          <keyword  id="categorical4" name="categorical" code="{N_vam(categorical,discreteStateSetIntCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="initial_state2" name="initial_state" code="{N_vam(ivec,discreteStateSetIntVars)}" label="Initial state"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="INTEGERLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="descriptors32" name="descriptors" code="{N_vam(strL,discreteStateSetIntLabels)}" label="descriptors"  minOccurs="0" default="dssiv_{i}" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
        </keyword>
        <keyword  id="string3" name="string" code="{N_vam(sizet,numDiscreteStateSetStrVars)}" label="string"  minOccurs="0" default="no discrete state set string variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable7" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_ndsss)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 string" />
          </keyword>
          <keyword  id="elements7" name="elements" code="{N_vam(newsarray,Var_Info_dsss)}" label="elements"   >
            <alias name="set_values"/>
            <param type="STRINGLIST" />
          </keyword>
          <keyword  id="initial_state3" name="initial_state" code="{N_vam(strL,discreteStateSetStrVars)}" label="Initial state"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
          <keyword  id="descriptors33" name="descriptors" code="{N_vam(strL,discreteStateSetStrLabels)}" label="descriptors"  minOccurs="0" default="dsssv_{i}" >
            <param type="STRINGLIST" constraint="LEN string" />
          </keyword>
        </keyword>
        <keyword  id="real3" name="real" code="{N_vam(sizet,numDiscreteStateSetRealVars)}" label="real"  minOccurs="0" default="no discrete state set real variables" >
          <param type="INTEGER" constraint="> 0" />
          <keyword  id="elements_per_variable8" name="elements_per_variable" code="{N_vam(newiarray,Var_Info_ndssr)}" label="elements_per_variable"  minOccurs="0" default="equal distribution" >
            <alias name="num_set_values"/>
            <param type="INTEGERLIST" constraint="LEN1 real" />
          </keyword>
          <keyword  id="elements8" name="elements" code="{N_vam(newrvec,Var_Info_dssr)}" label="elements"   >
            <alias name="set_values"/>
            <param type="REALLIST" />
          </keyword>
          <keyword  id="categorical5" name="categorical" code="{N_vam(categorical,discreteStateSetRealCat)}" label="categorical"  minOccurs="0" >
            <param type="STRINGLIST" constraint="LEN integer" />
          </keyword>
          <keyword  id="initial_state4" name="initial_state" code="{N_vam(rvec,discreteStateSetRealVars)}" label="initial_state"  minOccurs="0" default="middle set value, or rounded down" >
            <param type="REALLIST" constraint="LEN real" />
          </keyword>
          <keyword  id="descriptors34" name="descriptors" code="{N_vam(strL,discreteStateSetRealLabels)}" label="descriptors"  minOccurs="0" default="dssrv_{i}" >
            <param type="STRINGLIST" constraint="LEN real" />
          </keyword>
        </keyword>
      </keyword>
      <keyword  id="linear_inequality_constraint_matrix" name="linear_inequality_constraint_matrix" code="{N_vam(rvec,linearIneqConstraintCoeffs)}" label="linear_inequality_constraint_matrix"  minOccurs="0" default="no linear inequality constraints" >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_inequality_lower_bounds" name="linear_inequality_lower_bounds" code="{N_vam(rvec,linearIneqLowerBnds)}" label="linear_inequality_lower_bounds"  minOccurs="0" default="vector values = -infinity" >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_inequality_upper_bounds" name="linear_inequality_upper_bounds" code="{N_vam(rvec,linearIneqUpperBnds)}" label="linear_inequality_upper_bounds"  minOccurs="0" default="vector values = 0 ." >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_inequality_scale_types" name="linear_inequality_scale_types" code="{N_vam(strL,linearIneqScaleTypes)}" label="linear_inequality_scale_types"  minOccurs="0" default="vector values = &quot;none&quot;" >
        <param type="STRINGLIST" />
      </keyword>
      <keyword  id="linear_inequality_scales" name="linear_inequality_scales" code="{N_vam(rvec,linearIneqScales)}" label="linear_inequality_scales"  minOccurs="0" default="vector values = 1 . (no scaling)" >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_equality_constraint_matrix" name="linear_equality_constraint_matrix" code="{N_vam(rvec,linearEqConstraintCoeffs)}" label="linear_equality_constraint_matrix"  minOccurs="0" default="no linear equality constraints" >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_equality_targets" name="linear_equality_targets" code="{N_vam(rvec,linearEqTargets)}" label="linear_equality_targets"  minOccurs="0" default="vector values = 0 ." >
        <param type="REALLIST" />
      </keyword>
      <keyword  id="linear_equality_scale_types" name="linear_equality_scale_types" code="{N_vam(strL,linearEqScaleTypes)}" label="linear_equality_scale_types"  minOccurs="0" default="vector values = &quot;none&quot;" >
        <param type="STRINGLIST" />
      </keyword>
      <keyword  id="linear_equality_scales" name="linear_equality_scales" code="{N_vam(rvec,linearEqScales)}" label="linear_equality_scales"  minOccurs="0" default="vector values = 1 . (no scaling)" >
        <param type="REALLIST" />
      </keyword>
    </keyword>


    <!-- **** TOPLEVEL *** -->
    <keyword id="interface" name="interface" maxOccurs="unbounded" code="{N_ifm3(start,0,stop)}" label="Interface" >
      <keyword  id="id_interface" name="id_interface" code="{N_ifm(str,idInterface)}" label="Interface Set Identifier"  minOccurs="0" default="use of last interface parsed" complexity="0">
        <param type="STRING" taglist="interface" />
      </keyword>
      <keyword  id="analysis_drivers" name="analysis_drivers" code="{N_ifm(strL,analysisDrivers)}" label="Analysis Drivers"  minOccurs="0" complexity="0">
        <param type="STRINGLIST" />
        <keyword  id="input_filter" name="input_filter" code="{N_ifm(str,inputFilter)}" label="Input Filter"  minOccurs="0" default="no input filter" complexity="1">
          <param type="STRING" />
        </keyword>
        <keyword  id="output_filter" name="output_filter" code="{N_ifm(str,outputFilter)}" label="Output Filter"  minOccurs="0" default="no output filter" complexity="1">
          <param type="STRING" />
        </keyword>
        <oneOf label="Interface Type">
          <keyword id="system9" name="system" code="{N_ifm(type,interfaceType_SYSTEM_INTERFACE)}" label="System"  complexity="0">
	        <keyword id="parameters_file" name="parameters_file" code="{N_ifm(str,parametersFile)}" label="Parameters File"  minOccurs="0" default="Unix temp files" complexity="0">
              <param type="STRING" />
            </keyword>
	        <keyword id="results_file" name="results_file" code="{N_ifm(str,resultsFile)}" label="Results File"  minOccurs="0" default="Unix temp files" complexity="0">
              <param type="STRING" />
            </keyword>
	        <keyword id="file_tag" name="file_tag" code="{N_ifm(true,fileTagFlag)}" label="File Tag"  minOccurs="0" default="no tagging" complexity="0"/>
	        <keyword id="file_save" name="file_save" code="{N_ifm(true,fileSaveFlag)}" label="File Save"  minOccurs="0" default="file cleanup" complexity="0"/>
	        <keyword id="labeled" name="labeled" code="{N_ifm(type,resultsFileFormat_LABELED_RESULTS)}" label="Labeled" minOccurs="0" default="Function value labels optional" complexity="0"/>
	        <keyword id="aprepro" name="aprepro" code="{N_ifm(true,apreproFlag)}" label="APREPRO"  minOccurs="0" default="standard parameters file format" complexity="0">
              <alias name="dprepro" />
            </keyword>
	        <keyword id="work_directory" name="work_directory" code="{N_ifm(true,useWorkdir)}" label="Work Directory"  minOccurs="0" default="no work directory" complexity="0">
              <keyword id="named" name="named" code="{N_ifm(str,workDir)}" label="Named"  minOccurs="0" default="dakota_work_xxxxxxxx" complexity="0">
                <param type="STRING" />
              </keyword>
              <keyword id="directory_tag" name="directory_tag" code="{N_ifm(true,dirTag)}" label="Directory Tag"  minOccurs="0" default="no work directory tagging" complexity="0">
                <alias name="dir_tag" />
              </keyword>
              <keyword id="directory_save" name="directory_save" code="{N_ifm(true,dirSave)}" label="Directory Save"  minOccurs="0" default="remove work directory" complexity="0">
                <alias name="dir_save" />
              </keyword>
              <keyword id="link_files" name="link_files" code="{N_ifm(strL,linkFiles)}" label="Files to Link"  minOccurs="0" default="no linked files" complexity="0">
                <param type="STRINGLIST" />
              </keyword>
              <keyword id="copy_files" name="copy_files" code="{N_ifm(strL,copyFiles)}" label="Files to Copy"  minOccurs="0" default="no copied files" complexity="0">
                <param type="STRINGLIST" />
              </keyword>
              <keyword id="replace" name="replace" code="{N_ifm(true,templateReplace)}" label="Replace"  minOccurs="0" default="do not overwrite files" complexity="1"/>
            </keyword>
	        <keyword id="allow_existing_results" name="allow_existing_results" code="{N_ifm(true,allowExistingResultsFlag)}" label="Allow Existing Results"  minOccurs="0" default="results files removed before each evaluation" complexity="1"/>
	        <keyword id="verbatim" name="verbatim" code="{N_ifm(true,verbatimFlag)}" label="Verbatim"  minOccurs="0" default="driver/filter invocation syntax augmented with file names" complexity="1"/>
	        <!-- <keyword id="results_format" name="results_format" code="{0}" label="results_format" minOccurs="0" maxOccurs="1" default="Flexible format">
		    <oneOf>
              <keyword id="flexible" name="flexible" code="{N_ifm(type,resultsFileFormat_FLEXIBLE_RESULTS)}" label="flexible" />
		    </oneOf>
	        </keyword>
	        -->
	      </keyword>
          <keyword id="fork" name="fork" code="{N_ifm(type,interfaceType_FORK_INTERFACE)}" label="Fork Interface "  complexity="0">
            <keyword id="parameters_file" name="parameters_file" code="{N_ifm(str,parametersFile)}" label="Parameters File"  minOccurs="0" default="Unix temp files" complexity="0">
              <param type="STRING" />
            </keyword>
	        <keyword id="results_file" name="results_file" code="{N_ifm(str,resultsFile)}" label="Results File"  minOccurs="0" default="Unix temp files" complexity="0">
              <param type="STRING" />
            </keyword>
	        <keyword id="file_tag" name="file_tag" code="{N_ifm(true,fileTagFlag)}" label="File Tag"  minOccurs="0" default="no tagging" complexity="0"/>
	        <keyword id="file_save" name="file_save" code="{N_ifm(true,fileSaveFlag)}" label="File Save"  minOccurs="0" default="file cleanup" complexity="0"/>
	        <keyword id="labeled" name="labeled" code="{N_ifm(type,resultsFileFormat_LABELED_RESULTS)}" label="Labeled" minOccurs="0" default="Function value labels optional" complexity="0"/>
	        <keyword id="aprepro" name="aprepro" code="{N_ifm(true,apreproFlag)}" label="APREPRO"  minOccurs="0" default="standard parameters file format" complexity="0">
              <alias name="dprepro" />
            </keyword>
	        <keyword id="work_directory" name="work_directory" code="{N_ifm(true,useWorkdir)}" label="Work Directory"  minOccurs="0" default="no work directory" complexity="0">
              <keyword id="named" name="named" code="{N_ifm(str,workDir)}" label="Named"  minOccurs="0" default="dakota_work_xxxxxxxx" complexity="0">
                <param type="STRING" />
              </keyword>
              <keyword id="directory_tag" name="directory_tag" code="{N_ifm(true,dirTag)}" label="Directory Tag"  minOccurs="0" default="no work directory tagging" complexity="0">
                <alias name="dir_tag" />
              </keyword>
              <keyword id="directory_save" name="directory_save" code="{N_ifm(true,dirSave)}" label="Directory Save"  minOccurs="0" default="remove work directory" complexity="0">
                <alias name="dir_save" />
              </keyword>
              <keyword id="link_files" name="link_files" code="{N_ifm(strL,linkFiles)}" label="Files to Link"  minOccurs="0" default="no linked files" complexity="0">
                <param type="STRINGLIST" />
              </keyword>
              <keyword id="copy_files" name="copy_files" code="{N_ifm(strL,copyFiles)}" label="Files to Copy"  minOccurs="0" default="no copied files" complexity="0">
                <param type="STRINGLIST" />
              </keyword>
              <keyword id="replace" name="replace" code="{N_ifm(true,templateReplace)}" label="Replace"  minOccurs="0" default="do not overwrite files" complexity="1"/>
            </keyword>
	        <keyword id="allow_existing_results" name="allow_existing_results" code="{N_ifm(true,allowExistingResultsFlag)}" label="Allow Existing Results"  minOccurs="0" default="results files removed before each evaluation" complexity="1"/>
	        <keyword id="verbatim" name="verbatim" code="{N_ifm(true,verbatimFlag)}" label="Verbatim"  minOccurs="0" default="driver/filter invocation syntax augmented with file names" complexity="1"/>
	        <!-- <keyword id="results_format" name="results_format" code="{0}" label="results_format" minOccurs="0" maxOccurs="1" default="Flexible format">
		      <oneOf>
                <keyword id="flexible" name="flexible" code="{N_ifm(type,resultsFileFormat_FLEXIBLE_RESULTS)}" label="flexible" />
		      </oneOf>
	        </keyword>
	        -->
          </keyword>
          <keyword id="direct" name="direct" code="{N_ifm(type,interfaceType_TEST_INTERFACE)}" label="Direct Function Interface "  complexity="0">
            <keyword id="processors_per_analysis" name="processors_per_analysis" code="{N_ifm(int,procsPerAnalysis)}" label="Number of Processors per Analysis Server"  minOccurs="0" default="automatic (see discussion)" complexity="1">
              <param type="INTEGER" constraint="> 0" />
            </keyword>
          </keyword>
          <keyword id="plugin" name="plugin" code="{N_ifm(type,interfaceType_PLUGIN_INTERFACE)}" label="Plugin Evaluator Interface "  complexity="0">
	    <keyword id="library_path" name="library_path" code="{N_ifm(str,pluginLibraryPath)}" label="Path to Plugin Library"  minOccurs="1" default="none">
	      <param type="INPUT_FILE"/>
	    </keyword>
          </keyword>
	      <!-- TODO: processors per analysis? -->
	      <keyword id="matlab" name="matlab" code="{N_ifm(type,interfaceType_MATLAB_INTERFACE)}" label="Matlab Interface "  complexity="1"/>
	      <keyword id="python" name="python" code="{N_ifm(type,interfaceType_PYTHON_INTERFACE)}" label="Python Interface "  complexity="1">
                <keyword id="numpy" name="numpy" code="{N_ifm(true,numpyFlag)}" label="Python NumPy Dataflow"  minOccurs="0" default="Python list dataflow" complexity="1"/>
              </keyword>
	      <!-- #	  | modelcenter {N_ifm(type,interfaceType_MC_INTERFACE)}
               #	  | plugin {N_ifm(type,interfaceType_PLUGIN_INTERFACE)}
	      -->
	      <keyword id="legacy_python" name="legacy_python" code="{N_ifm(type,interfaceType_LEGACY_PYTHON_INTERFACE)}" label="Legacy Python Interface "  complexity="1">
            <keyword id="numpy" name="numpy" code="{N_ifm(true,numpyFlag)}" label="Python NumPy Dataflow"  minOccurs="0" default="Python list dataflow" complexity="1"/>
          </keyword>
	      <keyword id="scilab" name="scilab" code="{N_ifm(type,interfaceType_SCILAB_INTERFACE)}" label="Scilab Interface "  complexity="1"/>
	      <keyword id="grid2" name="grid" code="{N_ifm(type,interfaceType_GRID_INTERFACE)}" label="Grid Interface "  complexity="1"/>
	    </oneOf>
	    <keyword id="analysis_components" name="analysis_components" code="{N_ifm(str2D,analysisComponents)}" label="Additional Identifiers for Use by the Analysis Drivers"  minOccurs="0" default="no additional identifiers" complexity="1">
          <param type="STRINGLIST" />
	    </keyword>
      </keyword>
      <keyword id="algebraic_mappings" name="algebraic_mappings" code="{N_ifm(str,algebraicMappings)}" label="Algebraic Mappings File"  minOccurs="0" default="no algebraic mappings" complexity="1">
	    <param type="STRING" />
      </keyword>
      <keyword  id="failure_capture" name="failure_capture" code="{0}" label="Failure Capturing"  minOccurs="0" default="abort" complexity="0">
	    <oneOf label="Failure Mitigation">
          <keyword  id="abort" name="abort" code="{N_ifm(lit,failAction_abort)}" label="Abort"   complexity="0"/>
          <keyword  id="retry" name="retry" code="{N_ifm(ilit,TYPE_DATA_failAction_retry)}" label="Retry"   complexity="0">
            <param type="INTEGER" />
          </keyword>
          <keyword  id="recover" name="recover" code="{N_ifm(Rlit,TYPE_DATA_failAction_recover)}" label="Recover"   complexity="0">
            <param type="REALLIST" />
          </keyword>
          <keyword  id="continuation" name="continuation" code="{N_ifm(lit,failAction_continuation)}" label="Continuation"   complexity="1"/>
	    </oneOf>
      </keyword>
      <keyword  id="deactivate" name="deactivate" code="{0}" label="Feature Deactivation"  minOccurs="0" default="Active set vector control, function evaluation cache, and restart file features are active" complexity="0">
	    <keyword  id="active_set_vector" name="active_set_vector" code="{N_ifm(false,activeSetVectorFlag)}" label="Active Set Vector"  minOccurs="0" complexity="0"/>
	    <keyword  id="evaluation_cache" name="evaluation_cache" code="{N_ifm(false,evalCacheFlag)}" label="Evaluation Cache"  minOccurs="0" complexity="1"/>
	    <keyword  id="strict_cache_equality" name="strict_cache_equality" code="{N_ifm(true,nearbyEvalCacheFlag)}" label="Strict Cache Equality"  minOccurs="0" complexity="1">
          <keyword  id="cache_tolerance" name="cache_tolerance" code="{N_ifm(Real,nearbyEvalCacheTol)}" label="Cache Tolerance"  minOccurs="0" complexity="1">
            <param type="REAL" />
          </keyword>
	    </keyword>
	    <keyword  id="restart_file" name="restart_file" code="{N_ifm(false,restartFileFlag)}" label="Restart File"  minOccurs="0" complexity="1"/>
      </keyword>
      <optional>
        <oneOf>
  	<keyword id="batch" name="batch" code="{N_ifm(true,batchEvalFlag)}" label="Batch Interface Usage"  default="sequential interface usage" complexity="0">
    	    <keyword id="size" name="size" code="{N_ifm(int,asynchLocalEvalConcurrency)}" label="Batch size"  minOccurs="0" default="local: unlimited batch size, hybrid: zero batch size" complexity="0">
              <param type="INTEGER" constraint="> 0" />
    	    </keyword>
          </keyword>
          <keyword id="asynchronous" name="asynchronous" code="{N_ifm(true, asynchFlag)}" label="Asynchronous Interface Usage"  default="synchronous interface usage" complexity="0">
    	    <keyword id="evaluation_concurrency" name="evaluation_concurrency" code="{N_ifm(int,asynchLocalEvalConcurrency)}" label="Asynchronous Evaluation Concurrency"  minOccurs="0" default="local: unlimited concurrency, hybrid: no concurrency" complexity="0">
              <param type="INTEGER" constraint="> 0" />
    	    </keyword>
    	    <keyword id="local_evaluation_scheduling" name="local_evaluation_scheduling" code="{0}" label="Local Evaluation Scheduling"  minOccurs="0" default="dynamic" complexity="1">
              <oneOf label="Scheduling Mode">
                <keyword id="dynamic" name="dynamic" code="{N_ifm(type,asynchLocalEvalScheduling_DYNAMIC_SCHEDULING)}" label="Dynamic"  complexity="1" />
                <keyword id="static" name="static" code="{N_ifm(type,asynchLocalEvalScheduling_STATIC_SCHEDULING)}" label="Static"  complexity="1" />
              </oneOf>
    	    </keyword>
    	    <keyword id="analysis_concurrency" name="analysis_concurrency" code="{N_ifm(int,asynchLocalAnalysisConcurrency)}" label="Asynchronous Analysis Concurrency"  minOccurs="0" default="local: unlimited concurrency, hybrid: no concurrency" complexity="1">
              <param type="INTEGER" constraint="> 0" />
    	    </keyword>
          </keyword>
        </oneOf>
      </optional>
      <group label="Parallel Configuration">
	    <keyword id="evaluation_servers" name="evaluation_servers" code="{N_ifm(int,evalServers)}" label="Number of Evaluation Servers"  minOccurs="0" default="automatic (see discussion)" complexity="1">
          <param type="INTEGER" constraint="> 0" />
	    </keyword>
		<keyword id="evaluation_scheduling" name="evaluation_scheduling" code="{0}" label="Message Passing Configuration for Scheduling of Evaluations"  minOccurs="0" default="automatic (see discussion)" complexity="1">
	      <oneOf label="Server Mode">
	        <keyword id="master2" name="master" code="{N_ifm(type,evalScheduling_MASTER_SCHEDULING)}" label="Master"  complexity="1" />
	        <keyword id="peer2" name="peer" code="{0}" label="Peer Scheduling of Evaluations"  complexity="1">
	          <oneOf label="Scheduling Mode">
		        <keyword id="dynamic1" name="dynamic" code="{N_ifm(type,evalScheduling_PEER_DYNAMIC_SCHEDULING)}" label="Dynamic"  default="dynamic (see discussion)" complexity="1" />
		        <keyword id="static1" name="static" code="{N_ifm(type,evalScheduling_PEER_STATIC_SCHEDULING)}" label="Static"  complexity="1" />
	          </oneOf>
	        </keyword>
	       </oneOf>
		</keyword>
	    <keyword id="processors_per_evaluation" name="processors_per_evaluation" code="{N_ifm(int,procsPerEval)}" label="Number of Processors per Evaluation Server"  minOccurs="0" default="automatic (see discussion)" complexity="1">
          <param type="INTEGER" constraint="> 0" />
	    </keyword>
	    <keyword id="analysis_servers" name="analysis_servers" code="{N_ifm(int,analysisServers)}" label="Number of Analysis Servers"  minOccurs="0" default="automatic (see discussion)" complexity="1">
          <param type="INTEGER" constraint="> 0" />
	    </keyword>
	    <keyword id="analysis_scheduling" name="analysis_scheduling" code="{0}" label="Message Passing Configuration for Scheduling of Analyses"  minOccurs="0" default="automatic (see discussion)" complexity="1">
	      <oneOf label="Scheduling Mode">
	        <keyword id="master3" name="master" code="{N_ifm(type,analysisScheduling_MASTER_SCHEDULING)}" label="Master"  complexity="1" />
	        <keyword id="peer3" name="peer" code="{N_ifm(type,analysisScheduling_PEER_SCHEDULING)}" label="Peer"  complexity="1" />
	        <!-- #	  | ( peer {0}
			#	      dynamic  {N_ifm(type,analysisScheduling_PEER_DYNAMIC_SCHEDULING)}
			#	      | static {N_ifm(type,analysisScheduling_PEER_STATIC_SCHEDULING)} )
	        -->
	      </oneOf>
	    </keyword>
      </group>
    </keyword>

    <!-- **** TOPLEVEL *** -->
    <keyword id="responses" name="responses" maxOccurs="unbounded" code="{N_rem3(start,0,stop)}" label="Responses" >
      <keyword  id="id_responses" name="id_responses" code="{N_rem(str,idResponses)}" label="Responses set identifier"  minOccurs="0" default="use of last responses parsed" >
        <param type="STRING" taglist="responses" />
      </keyword>
      <keyword  id="descriptors35" name="descriptors" code="{N_rem(strL,responseLabels)}" label="Response labels"  minOccurs="0" default="root strings plus numeric identifiers" >
        <alias name="response_descriptors"/>
        <param type="STRINGLIST" />
      </keyword>
      <!-- # Note: since NIDR does not support BOOLLIST or ENUMLIST, we employ one of two different approaches below for array alternation:
           #       (1) id_* lists used when there are conditional sub-specifications (e.g., mixed grads, mixed Hessians)
           #       (2) STRINGLISTs used for alternation without conditional sub-specifications (e.g., scale_types)
        -->
      <oneOf label="Response Type">
        <keyword  id="objective_functions" name="objective_functions" code="{N_rem(sizet,numObjectiveFunctions)}" label="Optimization"  >
          <alias name="num_objective_functions"/>
          <param type="INTEGER" constraint=">= 0" />
	  <!-- sense must be length 1 or num objective functions (groups), not per field element -->
          <keyword  id="sense" name="sense" code="{N_rem(strL,primaryRespFnSense)}" label="Optimization sense"  minOccurs="0" default="vector values = 'minimize'" >
            <param type="STRINGLIST" constraint="LEN1 objective_functions" />
          </keyword>
	  <!-- scale types must be length 1 or num objective functions (groups), not per field element
    	       "none" is no longer allowed to to ambiguity in scale values -->
          <keyword  id="primary_scale_types" name="primary_scale_types" code="{N_rem(strL,primaryRespFnScaleTypes)}" label="Objective function scaling types"  minOccurs="0" default="no scaling" >
            <alias name="objective_function_scale_types"/>
            <param type="STRINGLIST" constraint="LEN1 objective_functions" />
          </keyword>
	  <!-- scales must be length 1, num objective functions (groups), or per-element (scalar + field lengths) -->
          <keyword  id="primary_scales" name="primary_scales" code="{N_rem(RealDL,primaryRespFnScales)}" label="Objective function scales"  minOccurs="0" default="1.0 (no scaling)" >
            <alias name="objective_function_scales"/>
            <param type="REALLIST" />  <!-- constraint="LEN1 objective_functions" --> 
          </keyword>
	  <!-- weights combine objectives and when specified are only per objective function (group), not field element -->
          <keyword  id="weights" name="weights" code="{N_rem(RealDL,primaryRespFnWeights)}" label="Multi-objective weightings"  minOccurs="0" default="equal weights" >
            <alias name="multi_objective_weights"/>
            <param type="REALLIST" constraint="LEN objective_functions" />
          </keyword>
          <keyword  id="nonlinear_inequality_constraints" name="nonlinear_inequality_constraints" code="{N_rem(sizet,numNonlinearIneqConstraints)}" label="Number of nonlinear inequality constraints"  minOccurs="0" default="0" >
            <alias name="num_nonlinear_inequality_constraints"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="lower_bounds12" name="lower_bounds" code="{N_rem(RealDL,nonlinearIneqLowerBnds)}" label="Nonlinear inequality constraint lower bounds"  minOccurs="0" default="vector values = -infinity" >
              <alias name="nonlinear_inequality_lower_bounds"/>
              <param type="REALLIST" constraint="LEN nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="upper_bounds12" name="upper_bounds" code="{N_rem(RealDL,nonlinearIneqUpperBnds)}" label="Nonlinear inequality constraint upper bounds"  minOccurs="0" default="vector values = 0 ." >
              <alias name="nonlinear_inequality_upper_bounds"/>
              <param type="REALLIST" constraint="LEN nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="scale_types1" name="scale_types" code="{N_rem(strL,nonlinearIneqScaleTypes)}" label="Nonlinear constraint scaling types (for inequalities or equalities)"  minOccurs="0" default="no scaling" >
              <alias name="nonlinear_inequality_scale_types"/>
              <param type="STRINGLIST" constraint="LEN1 nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="scales1" name="scales" code="{N_rem(RealDL,nonlinearIneqScales)}" label="Nonlinear constraint scales (for inequalities or equalities)"  minOccurs="0" default="1.0 (no scaling)" >
              <alias name="nonlinear_inequality_scales"/>
              <param type="REALLIST" constraint="LEN1 nonlinear_inequality_constraints" />
            </keyword>
          </keyword>
          <keyword  id="nonlinear_equality_constraints" name="nonlinear_equality_constraints" code="{N_rem(sizet,numNonlinearEqConstraints)}" label="Number of nonlinear equality constraints"  minOccurs="0" default="0" >
            <alias name="num_nonlinear_equality_constraints"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="targets" name="targets" code="{N_rem(RealDL,nonlinearEqTargets)}" label="Nonlinear equality constraint targets"  minOccurs="0" default="vector values = 0 ." >
              <alias name="nonlinear_equality_targets"/>
              <param type="REALLIST" constraint="LEN nonlinear_equality_constraints" />
            </keyword>
            <keyword  id="scale_types2" name="scale_types" code="{N_rem(strL,nonlinearEqScaleTypes)}" label="Nonlinear scaling types (for inequalities or equalities)"  minOccurs="0" default="no scaling" >
              <alias name="nonlinear_equality_scale_types"/>
              <param type="STRINGLIST" constraint="LEN1 nonlinear_equality_constraints" />
            </keyword>
            <keyword  id="scales2" name="scales" code="{N_rem(RealDL,nonlinearEqScales)}" label="Nonlinear scales (for inequalities or equalities)"  minOccurs="0" default="1.0 (no scaling)" >
              <alias name="nonlinear_equality_scales"/>
              <param type="REALLIST" constraint="LEN1 nonlinear_equality_constraints" />
            </keyword>
          </keyword>
          <keyword  id="scalar_objectives" name="scalar_objectives" code="{N_rem(sizet,numScalarObjectiveFunctions)}" label="scalar_objectives"  minOccurs="0" >
            <alias name="num_scalar_objectives"/>
            <param type="INTEGER" constraint=">= 0" />
          </keyword>
          <keyword  id="field_objectives" name="field_objectives" code="{N_rem(sizet,numFieldObjectiveFunctions)}" label="field_objectives"  minOccurs="0" >
            <alias name="num_field_objectives"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="lengths" name="lengths" code="{N_rem(ivec,fieldLengths)}" label="lengths"   >
              <param type="INTEGERLIST" constraint="LEN field_objectives"/>
            </keyword>
            <keyword  id="num_coordinates_per_field" name="num_coordinates_per_field" code="{N_rem(ivec,numCoordsPerField)}" label="num_coordinates_per_field"  minOccurs="0" >
              <param type="INTEGERLIST" />
            </keyword>
	    <keyword  id="read_field_coordinates1" name="read_field_coordinates" code="{N_rem(true,readFieldCoords)}" label="whether to read field coordinate files"  minOccurs="0" />
          </keyword>
        </keyword>
        <keyword  id="calibration_terms" name="calibration_terms" code="{N_rem(sizet,numLeastSqTerms)}" label="Calibration (Least squares)"  >
          <alias name="least_squares_terms"/>
          <alias name="num_least_squares_terms"/>
          <param type="INTEGER" constraint=">= 0" />
          <keyword  id="scalar_calibration_terms" name="scalar_calibration_terms" code="{N_rem(sizet,numScalarLeastSqTerms)}" label="scalar_calibration_terms"  minOccurs="0" >
            <param type="INTEGER" constraint=">= 0" />
          </keyword>
          <keyword  id="field_calibration_terms" name="field_calibration_terms" code="{N_rem(sizet,numFieldLeastSqTerms)}" label="field_calibration_terms"  minOccurs="0" >
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="lengths1" name="lengths" code="{N_rem(ivec,fieldLengths)}" label="lengths"   >
              <param type="INTEGERLIST" constraint="LEN field_calibration_terms"/>
            </keyword>
            <keyword  id="num_coordinates_per_field1" name="num_coordinates_per_field" code="{N_rem(ivec,numCoordsPerField)}" label="num_coordinates_per_field"  minOccurs="0" >
              <param type="INTEGERLIST" />
            </keyword>
	    <keyword  id="read_field_coordinates1" name="read_field_coordinates" code="{N_rem(true,readFieldCoords)}" label="whether to read field coordinate files"  minOccurs="0" />
	  </keyword>
	  <!-- scale types are no longer supported since removal of "none"; only value scaling supported
               leaving for possible return to log scaling if sensible:
          <keyword  id="primary_scale_types1" name="primary_scale_types" code="{N_rem(strL,primaryRespFnScaleTypes)}" label="Calibration scaling types"  minOccurs="0" default="no scaling" >
            <alias name="calibration_term_scale_types"/>
            <alias name="least_squares_term_scale_types"/>
            <param type="STRINGLIST" constraint="LEN1 calibration_terms" />
          </keyword>
	  -->
	  <!-- scales must be length 1, num calibration terms (groups), or per-element (scalar + field lengths) -->
          <keyword  id="primary_scales1" name="primary_scales" code="{N_rem(RealDL,primaryRespFnScales)}" label="Calibration scales"  minOccurs="0" default="1.0 (no scaling)" >
            <alias name="calibration_term_scales"/>
            <alias name="least_squares_term_scales"/>
            <param type="REALLIST" /> <!-- constraint="LEN1 calibration_terms" --> 
          </keyword>
	  <!-- weights combine terms and when specified are only per calibration term (group), not field element -->
          <keyword  id="weights1" name="weights" code="{N_rem(RealDL,primaryRespFnWeights)}" label="Calibration term weights"  minOccurs="0" default="equal weights" >
            <alias name="calibration_weights"/>
            <alias name="least_squares_weights"/>
            <param type="REALLIST" constraint="LEN calibration_terms" />
          </keyword>
          <!-- #           ( calibration_data_arrays {0}
               #             [ num_experiments INTEGER >= 0 {N_rem(sizet,numExperiments)} ]
               #             [ experimental_config_variables REALLIST {N_rem(RealDL,expConfigVars)} ]
               #	      [ experimental_observations REALLIST {N_rem(RealDL,expObservations)} ]
               #	      [ experimental_std_deviations REALLIST {N_rem(RealDL,expStdDeviations)} ]
               #             )
               #  	    |
               # The required group immediately inside an optional group with only one alternate was tripping up the Reference manual generation
               #  	    (
           -->
	  <optional>
	    <oneOf label="Calibration Data">
              <keyword  id="calibration_data1" name="calibration_data" code="{N_rem(true,calibrationDataFlag)}" label="calibration data"  >
		<keyword  id="data_directory" name="data_directory" code="{N_rem(str,dataPathPrefix)}" label="Path to prepend to any data file names"  minOccurs="0" >
		  <param type="STRING" />
		</keyword>
		<keyword  id="num_experiments" name="num_experiments" code="{N_rem(sizet,numExperiments)}" label="Experiments in file"  minOccurs="0" default="1" >
                  <param type="INTEGER" constraint=">= 0" />
		</keyword>

		<keyword  id="num_config_variables" name="num_config_variables" code="{N_rem(sizet,numExpConfigVars)}" label="Configuration variable columns in file"  minOccurs="0" default="0" >
                  <param type="INTEGER" constraint=">= 0" />
		</keyword>

		<keyword  id="experiment_variance_type1" name="experiment_variance_type" code="{N_rem(strL,varianceType)}" label="Type of measurement error (none, scalar, diagonal, matrix)"  minOccurs="0" default="none" >
		  <alias name="variance_type"/>
                  <param type="STRINGLIST" constraint="LEN1 field_calibration_terms" />
		</keyword>

		<keyword  id="scalar_data_file" name="scalar_data_file" code="{N_rem(str,scalarDataFileName)}" label="Scalar calibration data file name"  minOccurs="0" >
		  <param type="STRING" />
		  &response_scalar_data_format;
		</keyword>
		<keyword  id="interpolate1" name="interpolate" code="{N_rem(true,interpolateFlag)}" label="Interpolate between simulation and experiment data"  minOccurs="0" />
              </keyword>
	      <!-- Legacy data specification option -->
	      <keyword  id="calibration_data_file" name="calibration_data_file" code="{N_rem(str,scalarDataFileName)}" label="Calibration data file name"  default="none" >
		<alias name="least_squares_data_file"/>
		<param type="STRING" />
		&response_scalar_data_format;
		<keyword  id="num_experiments" name="num_experiments" code="{N_rem(sizet,numExperiments)}" label="Experiments in file"  minOccurs="0" default="1" >
		  <param type="INTEGER" constraint=">= 0" />
		</keyword>
		<keyword  id="num_config_variables" name="num_config_variables" code="{N_rem(sizet,numExpConfigVars)}" label="Configuration variable columns in file"  minOccurs="0" default="0" >
		  <param type="INTEGER" constraint=">= 0" />
		</keyword>
		<keyword  id="experiment_variance_type" name="experiment_variance_type" code="{N_rem(strL,varianceType)}" label="Type of measurement error (none, scalar)"  minOccurs="0" default="none" >
		  <alias name="variance_type"/>
		  <param type="STRINGLIST" constraint="LEN1 calibration_terms" />
		</keyword>
              </keyword>
	    </oneOf>
	  </optional>
          <!-- #              )
               # The required group immediately inside an optional group with only one alternate was tripping up the Reference manual generation
            -->
          <keyword id="simulation_variance" name="simulation_variance" code="{N_rem(RealL,simVariance)}" label="Additive model error"  minOccurs="0" default="no variance" >
             <param type="REALLIST" constraint="LEN1 calibration_terms" />
          </keyword>
          <keyword  id="nonlinear_inequality_constraints1" name="nonlinear_inequality_constraints" code="{N_rem(sizet,numNonlinearIneqConstraints)}" label="Number of nonlinear inequality constraints"  minOccurs="0" default="0" >
            <alias name="num_nonlinear_inequality_constraints"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="lower_bounds13" name="lower_bounds" code="{N_rem(RealDL,nonlinearIneqLowerBnds)}" label="Nonlinear inequality lower bounds"  minOccurs="0" default="vector values = -infinity" >
              <alias name="nonlinear_inequality_lower_bounds"/>
              <param type="REALLIST" constraint="LEN nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="upper_bounds13" name="upper_bounds" code="{N_rem(RealDL,nonlinearIneqUpperBnds)}" label="Nonlinear inequality upper bounds"  minOccurs="0" default="vector values = 0 ." >
              <alias name="nonlinear_inequality_upper_bounds"/>
              <param type="REALLIST" constraint="LEN nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="scale_types3" name="scale_types" code="{N_rem(strL,nonlinearIneqScaleTypes)}" label="scale_types"  minOccurs="0" default="no scaling" >
              <alias name="nonlinear_inequality_scale_types"/>
              <param type="STRINGLIST" constraint="LEN1 nonlinear_inequality_constraints" />
            </keyword>
            <keyword  id="scales3" name="scales" code="{N_rem(RealDL,nonlinearIneqScales)}" label="scales"  minOccurs="0" default="1.0 (no scaling)" >
              <alias name="nonlinear_inequality_scales"/>
              <param type="REALLIST" constraint="LEN1 nonlinear_inequality_constraints" />
            </keyword>
          </keyword>
          <keyword  id="nonlinear_equality_constraints1" name="nonlinear_equality_constraints" code="{N_rem(sizet,numNonlinearEqConstraints)}" label="Number of nonlinear equality constraints"  minOccurs="0" default="0" >
            <alias name="num_nonlinear_equality_constraints"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="targets1" name="targets" code="{N_rem(RealDL,nonlinearEqTargets)}" label="Nonlinear equality targets"  minOccurs="0" default="vector values = 0 ." >
              <alias name="nonlinear_equality_targets"/>
              <param type="REALLIST" constraint="LEN nonlinear_equality_constraints" />
            </keyword>
            <keyword  id="scale_types4" name="scale_types" code="{N_rem(strL,nonlinearEqScaleTypes)}" label="scale_types"  minOccurs="0" default="no scaling" >
              <alias name="nonlinear_equality_scale_types"/>
              <param type="STRINGLIST" constraint="LEN1 nonlinear_equality_constraints" />
            </keyword>
            <keyword  id="scales4" name="scales" code="{N_rem(RealDL,nonlinearEqScales)}" label="scales"  minOccurs="0" default="1.0 (no scaling)" >
              <alias name="nonlinear_equality_scales"/>
              <param type="REALLIST" constraint="LEN1 nonlinear_equality_constraints" />
            </keyword>
          </keyword>
        </keyword>
        <keyword  id="response_functions" name="response_functions" code="{N_rem(sizet,numResponseFunctions)}" label="Generic responses"  >
          <alias name="num_response_functions"/>
          <param type="INTEGER" constraint=">= 0" />
          <keyword  id="scalar_responses" name="scalar_responses" code="{N_rem(sizet,numScalarResponseFunctions)}" label="scalar_responses"  minOccurs="0" >
            <alias name="num_scalar_responses"/>
            <param type="INTEGER" constraint=">= 0" />
          </keyword>
          <keyword  id="field_responses" name="field_responses" code="{N_rem(sizet,numFieldResponseFunctions)}" label="field_responses"  minOccurs="0" >
            <alias name="num_field_responses"/>
            <param type="INTEGER" constraint=">= 0" />
            <keyword  id="lengths2" name="lengths" code="{N_rem(ivec,fieldLengths)}" label="lengths"   >
              <param type="INTEGERLIST" constraint="LEN field_responses" />
            </keyword>
            <keyword  id="num_coordinates_per_field2" name="num_coordinates_per_field" code="{N_rem(ivec,numCoordsPerField)}" label="num_coordinates_per_field"  minOccurs="0" >
              <param type="INTEGERLIST" />
            </keyword>
	    <keyword  id="read_field_coordinates1" name="read_field_coordinates" code="{N_rem(true,readFieldCoords)}" label="whether to read field coordinate files"  minOccurs="0" />
          </keyword>
        </keyword>
      </oneOf>
      &response_gradients;
      &response_hessians;
      <keyword  id="metadata" name="metadata" code="{N_rem(strL,metadataLabels)}" label="metadata labels"  minOccurs="0" default="no metadata" >
        <param type="STRINGLIST"/>
      </keyword>
    </keyword>

  </input>
</document>
