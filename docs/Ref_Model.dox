namespace Dakota {

/** \page ModelCommands Model Commands

\htmlonly
<b>Model Commands Table of Contents</b>
<ul>
<li> <a href="ModelCommands.html#ModelDescr">Model Description</a>
<li> <a href="ModelCommands.html#ModelSpec">Model Specification</a>
<li> <a href="ModelCommands.html#ModelIndControl">Model Independent Controls</a>
<li> <a href="ModelCommands.html#ModelSingle">Single Model Controls</a>
<li> <a href="ModelCommands.html#ModelSurrogate">Surrogate Model Controls</a>
  <ul>
  <li> <a href="ModelCommands.html#ModelSurrG">Global approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrMP">Multipoint approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrL">Local approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrH">Hierarchical approximations</a>
  </ul>
<li> <a href="ModelCommands.html#ModelNested">Nested Model Controls</a>
</ul>
\endhtmlonly


\section ModelDescr Model Description


A DAKOTA model specifies how variables are mapped into a set of
responses in support of an iterative method and the model
specification in an input file dictates the components to be used in
constructing a particular model instance. This specification selects a
Model from the model hierarchy, which includes SingleModel,
DataFitSurrModel, HierarchSurrModel, and NestedModel derived classes.
Depending on the type of derived model, different sub-specifications
are needed to construct different components of the model.

Several examples follow. The first example shows a minimal
specification for a single model, which is the default model when no
models are specified by the user.
\verbatim
model,
	single
\endverbatim
This example does not provide any pointer strings and therefore relies
on the default behavior of constructing the model with the last
variables, interface, and responses specifications parsed.

The next example displays a surrogate model specification which
selects a quadratic polynomial from among the global approximation
methods.  It uses a pointer to a design of experiments method for
generating the data needed for building the global approximation, reuses
any old data available for the current approximation region, and
employs the first-order multiplicative approach to correcting the
approximation at the center of the current approximation region.

\verbatim
model,
	id_model = 'M1'
	variables_pointer = 'V1'
	responses_pointer = 'R1'
	surrogate global
	  polynomial quadratic
	  dace_method_pointer = 'DACE'
	  reuse_samples region
	  correction multiplicative first_order
\endverbatim
This example demonstrates the use of identifiers and pointers.  It
provides the optional model independent specifications for model
identifier, variables pointer, and responses pointer (see \ref
ModelIndControl) as well as model dependent specifications for 
global surrogates (see \ref ModelSurrG).

Finally, an advanced nested model example would be
\verbatim
model,
	id_model = 'M1'
	variables_pointer = 'V1'
	responses_pointer = 'R1'
	nested
	  optional_interface_pointer = 'OI1'
	    optional_interface_responses_pointer = 'OIR1'
	  sub_method_pointer = 'SM1'
	    primary_variable_mapping   = ''  ''  'X'     'Y'
	    secondary_variable_mapping = ''  ''  'mean'  'mean'
	    primary_response_mapping   = 1. 0. 0. 0. 0. 0. 0. 0. 0.
	    secondary_response_mapping = 0. 0. 0. 1. 3. 0. 0. 0. 0.
					 0. 0. 0. 0. 0. 0. 1. 3. 0.
\endverbatim 
This example also supplies model independent controls for model
identifier, variables pointer, and responses pointer (see \ref
ModelIndControl), and supplies model dependent controls for specifying
details of the nested mapping (see \ref ModelNested).


\section ModelSpec Model Specification


As alluded to in the examples above, the model specification 
has the following structure:
\verbatim
model,
	<model independent controls>
	<model selection>
	  <model dependent controls>
\endverbatim

The <tt>\<model independent controls\></tt> are those controls which
are valid for all models. Referring to dakota.input.summary, these
controls are defined externally from and prior to the model selection
blocks. The model selection blocks are all required group
specifications separated by logical OR's, where the model selection
must be \c single OR \c surrogate OR \c nested. If a \c surrogate
model is specified, a secondary selection must be made for its type:
\c global, \c multipoint, \c local, or \c hierarchical.  The
<tt>\<model dependent controls\></tt> are those controls which are
only meaningful for a specific model.  These controls are defined
within each model selection block. Defaults for model independent and
model dependent controls are defined in DataModel.  The following
sections provide additional detail on the model independent controls
followed by the model selections and their corresponding model
dependent controls.


\section ModelIndControl Model Independent Controls


The model independent controls include a model identifier string,
pointers to variables and responses specifications, and a model type
specification.  The model identifier string is supplied with \c
id_model and is used to provide a unique identifier string for use
within method specifications (refer to \c model_pointer in \ref
MethodIndControl).

The type of model can be \c single, \c nested, or \c surrogate.  Each of
these model specifications supports \c variables_pointer and \c
responses_pointer strings for identifying the variables and responses
specifications used in constructing the model (by cross-referencing
with \c id_variables and \c id_responses strings from particular
variables and responses keyword specifications).  These pointers are
valid for each model type since each model contains a set of variables
that is mapped into a set of responses -- only the specifics of the
mapping differ.  Additional pointers are used for each model type for
constructing the components of the variable to response mapping.  As a
strategy specification identifies one or more methods and a method
specification identifies a model, a model specification identifies
variables, interface, and responses specifications.  This top-down
flow specifies all of the object interrelationships.

For each of these pointer specifications, if a pointer string is
specified and no corresponding id string is available, DAKOTA will
exit with an error message. If the pointer is optional and no pointer
string is specified, then the last specification parsed will be
used. It is appropriate to omit optional cross-referencing whenever
the relationships are unambiguous due to the presence of only one
specification.

Table \ref T6d1 "6.1" provides the specification detail for the model
independent controls involving identifiers, model type controls, and
pointers.

\anchor T6d1 
<table>
<caption align = "top">
\htmlonly
Table 6.1
\endhtmlonly
Specification detail for the model independent controls: identifiers, 
model types, and pointers
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Model set identifier
<td>\c id_model
<td>string
<td>Optional
<td>method use of last model parsed
<tr>
<td>%Model type
<td>\c single | \c surrogate | \c nested
<td>none
<td>Required group
<td>N/A (\c single if no model specification)
<tr>
<td>%Variables set pointer
<td>\c variables_pointer
<td>string
<td>Optional
<td>model use of last variables parsed
<tr>
<td>Responses set pointer
<td>\c responses_pointer
<td>string
<td>Optional
<td>model use of last responses parsed
</table>


\section ModelSingle Single Model Controls


In the \c single model case, a single interface is used to map the
variables into responses.  The optional \c interface_pointer
specification identifies this interface by cross-referencing with the
\c id_interface string input from a particular interface keyword
specification.

Table \ref T6d2 "6.2" provides the specification detail for single
models.

\anchor T6d2 
<table>
<caption align = "top">
\htmlonly
Table 6.2
\endhtmlonly
Specification detail for single models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Interface set pointer
<td>\c interface_pointer
<td>string
<td>Optional
<td>model use of last interface parsed
</table>


\section ModelSurrogate Surrogate Model Controls


In the \c surrogate model case, the specification first allows a
mixture of surrogate and actual response mappings through the use of
the optional \c id_surrogates specification.  This identifies the
subset of the response functions by number that are to be approximated
(the default is all functions).  The valid response function
identifiers range from 1 through the total number of response
functions (see \ref RespFn).  Next, the specification selects a
global, multipoint, local, or hierarchical approximation.  Table 
\ref T6d3 "6.3" provides the specification detail for surrogate models.

\anchor T6d3 
<table>
<caption align = "top">
\htmlonly
Table 6.3
\endhtmlonly
Specification detail for the surrogate models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Surrogate response ids
<td>\c id_surrogates
<td>list of integers
<td>Optional
<td>All response functions are approximated
<tr>
<td>Surrogate type selection
<td>\c global | \c multipoint | \c local | \c hierarchical
<td>none
<td>Required group
<td>N/A
</table>

Each of these surrogate types provides an approximate representation
of a "truth" model which is used to perform the parameter to response
mappings. This approximation is built and updated using data from the
truth model.  This data is generated in some cases using a design of
experiments iterator applied to the truth model (global approximations
with a \c dace_method_pointer).  In other cases, truth model data from
a single point (local, hierarchical approximations), from a few
previously evaluated points (multipoint approximations), or from the
restart database (global approximations with \c reuse_samples) can be
used.  Surrogate models are used extensively in the surrogate-based
optimization and least squares methods (see SurrBasedMinimizer and its
derived classes and \ref MethodSB), in which the goals are to reduce
expense by minimizing the number of truth function evaluations and to
smooth out noisy data with a global data fit.  However, the use of
surrogate models is not restricted to optimization techniques;
uncertainty quantification and optimization under uncertainty methods
are other primary users.

The following sections present the \c global, \c multipoint, \c local,
and \c hierarchical specification groups in further detail.


\subsection ModelSurrG Global approximations

The global surrogate model requires specification of one of the
following approximation types: \c polynomial, \c gaussian_process
(Kriging), \c neural_network, \c mars, \c moving_least_squares, <!--
\c orthogonal_polynomial, --> or \c radial_basis.  These
specifications will create a polynomial, Gaussian process (Kriging
interpolation), layered perceptron artificial neural network
approximation, multivariate adaptive regression spline, moving least
squares, <!-- an orthogonal polynomial (Hermite, Legendre, Laguerre,
Jacobi, and/or generalized Laguerre) approximation, --> or radial
basis function approximation, respectively.  All these approximations
are implemented in \ref Giunta2006 "SurfPack" except an alternate
Gaussian process model, which is implemented directly in DAKOTA.

In the polynomial case, the order of the polynomial (linear,
quadratic, or cubic) must be specified. 

While historically the DAKOTA and Surfpack Gaussian process (GP)
models were drastically different, as of DAKOTA 5.1, their features
and implementations are more similar.  The trend function of both the
GP models is selected using the \c trend keyword, with options 
\c constant, \c linear, or \c reduced_quadratic (default).  The 
Surfpack GP approximation has the additional option of (full) 
\c quadratic.  The \c reduced_quadratic trend function includes the
main effects, but not mixed/interaction terms.  NOTE: prior to DAKOTA
5.1, reduced_quadratic was selected for the DAKOTA Gaussian process
via the \c quadratic option.

For a GP approximation, the correlation parameters are typically
chosen by an internal global optimization procedure.  Ill-conditioning
is a common challenge in the construction of Gaussian process models.
The DAKOTA GP (\c gaussian_process \c dakota) deals with
ill-conditioning in two ways.  First, when it encounters a
non-invertible correlation matrix it iteratively increases the size of
a "nugget," but in such cases the resulting approximation smooths
rather than interpolates the data. Second, the DAKOTA GP has an option
for \c point_selection to avoid ill-conditioning when the number of
points becomes large.  This option uses a greedy algorithm to choose a
subset of points with which to build the Gaussian process.  These
points are "optimal" in terms of creating a Gaussian process with low
prediction error.  By default, there is no point selection.
Typically, one should not need point selection in trust-region methods
because a small number of points are used to develop a surrogate
within each trust region.  Point selection is most beneficial when
constructing with a "large" number of points, typically more than
order one hundred, though this depends on the number of variables and
spacing of the sample points.

By default, the Surfpack GP (Kriging) model (\c gaussian_process \c
surfpack) uses a global optimization algorithm to determine the
correlation parameters, however one may force a particular approach by
specifying \c optimization_method followed by any of \c 'global', \c
'local', \c 'sampling', or \c 'none'.  Alternately, a vector of \c
correlation_lengths can be specified, bypassing their automatic
determination.  (A correlation parameter equals one-half divided by
the square of the corresponding correlation length. This definition of
the correlation lengths makes their effect on the Gaussian correlation
function directly analogous to that of the standard deviation of a
Gaussian (normal) distribution.)  When performing optimization to
determine correlation parameters, the Surfpack Kriging model searches
in a much smaller "feasible region" of correlation lengths.  If the \c
'none' option is selected, and \c correlation_lengths are not directly
specified, then the center (in log scale) of the feasible region will
be selected. This center is also used as the starting point for \c
'local' optimization.  The small feasible region typically contains
small/large enough correlation lengths to include both
well-conditioned correlation matrices and either the globally optimal,
or at least a near-optimal, correlation matrix. Note that a matrix
being ill-conditioned means that its rows or columns contain a
significant amount of duplicate information.  As of DAKOTA 5.2, within
the maximum likelihood optimization loop, the Surfpack Kriging model
will perform a pivoted Cholesky factorization of ill-conditioned
matrices.  This ranks the sample points according to how much unique
information they contain.  A bisection search is used to efficiently
determine how many low information points need to be discarded to
tightly meet the constraint on the condition number estimate.  If
necessary, the trend order will automatically be decreased until there
are fewer unknowns than equations.  The (possibly improper) subset of
points used to build the kriging model will be the ones associated
with the most likely set of correlation lengths.  Since the points
that are discarded contain the least unique information, they should
be the ones that are easiest to predict and provide maximum
improvement to the condition number.  Note that the model:
will interpolate all of the retained points; is not guaranteed to
exactly interpolate the discarded points; and typically predicts the
discarded points well enough to be visually indistinguishable from a
surface that interpolates them.  Warning: when two points that are
very close together are on opposite sides of a discontinuity, one of
them may be discarded. The \c max_trials option limits the number of
internal likelihood function evaluations used in constructing the
model. As of DAKOTA 5.2, the \c use_derivatives keyword, when
used in conjunction with the Surfpack GP model, will cause a Gradient
Enhanced Kriging (GEK) model to be constructed.  This is only
beneficial when: the derivatives are accurate; the derivatives are not
infinite or nearly so; and the function value plus gradient can be
obtained at a cost comparable to the function value by itself.  This
means that derivatives obtained by finite differences are not cost
effective; in test problems their accuracy was also insufficient.
However, derivatives obtained analytically, or through automatic
differentiation or continuous adjoint techniques are appropriate and
beneficial. For GEK, a pivoted Cholesky factorization of Kriging's
correlation matrix (which is a small sub-matrix within GEK's
correlation matrix) is performed to rank points according to their
information content.  This reordering is applied to whole points (a
function value at a point immediately followed by its derivatives) in
GEK's correlation matrix. Then a non-pivoted Cholesky factorization is
performed on the reordered GEK correlation matrix and bisection is
used to determine the last reordered equation which meets the
condition number constraint.  Subsequent equations are discarded.  The
GEK model will exactly interpolate all points and derivative equations
that were retained but is not guaranteed to interpolate those that
were discarded.


<!-- TODO: document MARS, ANN, and RBF controls -->
Tables \ref T6d4 "6.4" and \ref T6d5 "6.5" summarize the global 
approximation selection specifications.

\anchor T6d4
<table>
<caption align = "top">
\htmlonly
Table 6.4
\endhtmlonly
Specification detail for global approximations: global 
approximation type, Part I
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Global approximations 
<td>\c global
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Polynomial
<td>\c polynomial
<td>\c linear | \c quadratic | \c cubic
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>DAKOTA Gaussian process
<td>\c gaussian_process
<td>dakota
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>GP trend function
<td>\c trend
<td>\c constant | \c linear | \c reduced_quadratic
<td>Optional
<td>reduced_quadratic trend
<tr>
<td>GP point selection
<td>\c point_selection
<td>none
<td>Optional
<td>no point selection
<tr>
<td>Surfpack Gaussian process (Kriging)
<td>\c gaussian_process
<td>surfpack
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>Surfpack GP trend function
<td>\c trend
<td>\c constant | \c linear | \c reduced_quadratic | \c quadratic
<td>Optional
<td>reduced_quadratic trend
<td>
<tr>
<td>Surfpack GP correlation lengths
<td>\c correlation_lengths
<td>list of reals
<td>Optional
<td>internally computed correlation_lengths
<tr>
<td>Surfpack GP optimization method
<td>\c optimization_method
<td>\c 'global' | \c 'local' | \c 'sampling' | \c 'none'
<td>Optional 
<td>global 
<tr>
<td>Surfpack GP maximum trials
<td>\c max_trials
<td>integer
<td>Optional
<td>
<tr>
<td>Surfpack GP gradient enhancement
<td>\c use_derivatives
<td>none
<td>Optional
<td>no gradient enhancement
<tr>
<td>Artificial neural network
<td>\c neural_network
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>ANN number nodes
<td>\c nodes
<td>integer
<td>Optional
<td>
<tr>
<td>ANN range
<td>\c range
<td>real
<td>Optional
<td>
<tr>
<td>ANN random weight
<td>\c random_weight
<td>integer
<td>Optional
<td>
</table>

\anchor T6d5
<table>
<caption align = "top">
\htmlonly
Table 6.5
\endhtmlonly
Specification detail for global approximations: global 
approximation type, Part II
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Multivariate adaptive regression splines
<td>\c mars
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>MARS maximum bases
<td>\c max_bases
<td>integer
<td>Optional
<td>
<tr>
<td>MARS interpolation
<td>\c interpolation
<td>\c linear | \c cubic
<td>Optional
<td>
<tr>
<td>Moving least squares
<td>\c moving_least_squares
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>MLS polynomial order
<td>\c poly_order
<td>integer
<td>Optional
<td>
<tr>
<td>MLS weight function
<td>\c weight_function
<td>integer
<td>Optional
<td>
<!--
<tr>
<td>Orthogonal polynomial
<td>\c orthogonal_polynomial
<td>none
<td>Required (1 of 7 selections)
<td>N/A
-->
<tr>
<td>Radial basis functions
<td>\c radial_basis_functions
<td>none
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>RBF number of bases
<td>\c bases
<td>integer
<td>Optional
<td>
<tr>
<td>RBF maximum points
<td>\c max_pts
<td>integer
<td>Optional
<td>
<tr>
<td>RBF minimum partitions
<td>\c min_partition
<td>integer
<td>Optional
<td>
<tr>
<td>RBF maximum subsets
<td>\c bases
<td>integer
<td>Optional
<td>
</table>

Table \ref T6d6 "6.6" summarizes the remaining (optional) global
approximation specifications, including controls for the number of
points requested to build the surrogate, the source of the points (\c
dace_method_pointer and \c reuse_samples), the use of derivative
information in constructions (\c use_derivatives), calculation of
fitness metrics, and the \c correction method.

The number of points used in building a global approximation is
determined by three point counts:

\li #Model points: Each global surrogate type has an associated
minimum reasonable and recommended number of build points, selected
via \c minimum_points and \c recommended_points (default),
respectively, within a global surrogate model specification.
Alternately an integer \c total_points may be specified to request a
specific number of points in each surrogate build (a lower bound of
minimum points is enforced).  This count, then, can be summarized as
#Model points = (minimum | recommended | max(minimum, total)).

\li Reused points: any samples available for reuse via the \c
reuse_samples keyword (described below) are always used to build.
This count defaults to zero.

\li #Iterator points: \c samples specified within the DACE method 
specification (identified via \c dace_method_pointer) always
provide a lower bound on the number of fresh DACE samples used to
build the surrogate.  This count defaults to zero.

The number of new points to be evaluated by the DACE method is defined
by New points = max(#Model points - Reused points, #Iterator points),
using the logic that the number of points needed is #Model points minus
Reused points, but respecting a lower bound DACE samples specification
when present.  The total number of points used in the surrogate build
is then New points + Reused points.  The DACE iterator will only be
invoked if it has new samples to perform, and if new samples are
required and no DACE iterator has been provided, an error will result.

The \c dace_method_pointer links to design of experiments iterator
used to generate truth model data for building a global data fit.  The
\c reuse_samples specification can be used to employ old data (either
from previous function evaluations performed in the run or from
function evaluations read from a restart database or text file) in the
building of new global approximations.  The default is no reuse of old
data (since this can induce directional bias), and the settings of \c
all, \c region, and \c samples_file result in reuse of all available
data, reuse of all data available in the current trust region, and
reuse of all data from a specified text file, respectively.  Both \c
dace_method_pointer and \c reuse_samples are optional specifications,
which gives the user maximum flexibility in using design of
experiments data, restart/text file data, or both.

The \c use_derivatives flag specifies that any available derivative
information should be used in global approximation builds. This
capability is currently supported in SurrBasedLocalMinimizer,
Pecos::SurrogateDataPoint, and \ref Approximation::build
"Approximation::build()", and will soon be supported for \c
global_kriging models, but is not yet supported in any global
approximation derived class redefinitions of build().

To assess the goodness of fit of a global surrogate, a variety of 
diagnostics are available for the following global approximation methods: 
polynomial regressions, kriging, mars, moving least squares, neural 
networks, and radial basis functions.  The diagnostics are specified 
by the keyword \c diagnostics, followed by a list of strings specifying 
the actual metrics.  The diagnostic metrics available are: \c sum_squared,
\c mean_squared, \c root_mean_squared, \c max_squared, \c sum_scaled, 
\c max_scaled, \c sum_abs, \c mean_abs, \c max_abs, \c press, \c cv, 
and \c rsquared.  Most of these diagnostics refer to some operation 
on the residuals (the difference between the surrogate model and the 
truth model at the data points upon which the surrogate is built).
For example, \c sum_squared refers to the sum of the squared residuals,
\c mean_abs refers to the mean of the absolute value of the residuals, 
and \c max_scaled refers to the maximum scaled value of the residual, 
where the scaled value is taken by dividing the residual by the 
true function value at that point.  In addition, \c press refers to a 
leave-one-out cross validation metric, and \c cv refers to a general 
cross validation metric.  \c rsquared refers to the R-squared value 
typically used in regression analysis (the proportion of the variability
in the response that can be accounted for by the surrogate model).

The \c correction specification specifies that the approximation will
be corrected to match truth data, either matching truth values in the
case of \c zeroth_order matching, matching truth values and gradients
in the case of \c first_order matching, or matching truth values,
gradients, and Hessians in the case of \c second_order matching.  For
\c additive and \c multiplicative corrections, the correction is local
in that the truth data is matched at a single point, typically the
center of the approximation region.  The \c additive correction adds a
scalar offset (\c zeroth_order), a linear function (\c first_order),
or a quadratic function (\c second_order) to the approximation to
match the truth data at the point, and the \c multiplicative
correction multiplies the approximation by a scalar (\c zeroth_order),
a linear function (\c first_order), or a quadratic function (\c
second_order) to match the truth data at the point.  The \c additive
\c first_order case is due to [\ref Lewis2000 "Lewis and Nash, 2000"]
and the \c multiplicative \c first_order case is commonly known as
beta correction [\ref Haftka1991 "Haftka, 1991"].  For the \c combined
correction, the use of both additive and multiplicative corrections
allows the satisfaction of an additional matching condition, typically
the truth function values at the previous correction point (e.g., the
center of the previous trust region).  The \c combined correction is
then a multipoint correction, as opposed to the local \c additive and
\c multiplicative corrections.  Each of these correction capabilities
is described in detail in [\ref Eldred2004a "Eldred et al., 2004a"].


\anchor T6d6
<table>
<caption align = "top">
\htmlonly
Table 6.6
\endhtmlonly
Specification detail for global approximations: build and correction controls
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Number of build points
<td>\c total_points | \c minimum_points | \c recommended_points 
<td>integer | none | none
<td>Optional
<td>recommended_points
<tr>
<td>Design of experiments method pointer
<td>\c dace_method_pointer
<td>string
<td>Optional
<td>no design of experiments data
<tr>
<td>Sample reuse in global approximation
<td>\c reuse_samples
<td>\c all | \c region | \c none
<td>Optional group
<td>\c all if \c samples_file defined, \c none otherwise
<tr>
<td>File import of samples for global approximation builds
<td>\c samples_file
<td>string
<td>Optional
<td>no sample import from a file
<tr>
<td>Use of gradient data in global approximation builds
<td>\c use_gradients
<td>none
<td>Optional
<td>gradient data not used in global approximation builds
<tr>
<td>Print diagnostic metrics about the surrogate goodness of fit
<td>\c diagnostics
<td>string list (as many as desired): \c sum_squared, \c mean_squared, \c root_mean_squared, \c max_squared, 
\c sum_scaled, \c max_scaled, \c sum_abs, \c mean_abs, \c max_abs, 
\c press, \c cv, and \c rsquared 
<td>Optional
<td>No diagnostics printed
<tr>
<td>Surrogate correction approach
<td>\c correction
<td>\c additive or \c multiplicative or \c combined, \c zeroth_order or \c first_order or \c second_order
<td>Optional group
<td>no surrogate correction
</table>


\subsection ModelSurrMP Multipoint approximations

Multipoint approximations use data from previous design points to
improve the accuracy of local approximations.  Currently, the
Two-point Adaptive Nonlinearity %Approximation (TANA-3) method of
[\ref Xu1998 "Xu and Grandhi, 1998"] is supported. This method
requires response value and gradient information from two points, and
uses a first-order Taylor series if only one point is available.  The
truth model to be used to generate the value/gradient data used in the
approximation is identified through the required \c
actual_model_pointer specification.  \ref T6d7 "Table 6.7" summarizes
the multipoint approximation specifications.

\anchor T6d7
<table>
<caption align = "top">
\htmlonly
Table 6.7
\endhtmlonly
Specification detail for multipoint approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Multipoint approximation
<td>\c multipoint
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Two-point adaptive nonlinear approximation 
<td>\c tana
<td>none
<td>Required
<td>N/A
<tr>
<td>Pointer to the truth model specification
<td>\c actual_model_pointer
<td>string
<td>Required
<td>N/A
</table>


\subsection ModelSurrL Local approximations

Local approximations use value, gradient, and possibly Hessian data
from a single point to form a series expansion for approximating data
in the vicinity of this point.  The currently available local
approximation is the \c taylor_series selection.  The order of the
Taylor series may be either first-order or second-order, which is
automatically determined from the gradient and Hessian specifications
in the responses specification (see \ref RespGrad and \ref RespHess)
for the truth model.
<!-- The first-order Taylor series expansion is known as the -->
<!-- "linear approximation" in the optimization literature.  Other local -->
<!-- approximations, such as the "reciprocal" and "conservative/convex" -->
<!-- approximations, may become available in the future. -->
The truth model to be used to generate the value/gradient/Hessian data
used in the series expansion is identified through the required \c
actual_model_pointer specification.  The use of a model pointer (as
opposed to an interface pointer) allows additional flexibility in
defining the approximation.  In particular, the derivative
specification for the truth model may differ from the derivative
specification for the approximation , and the truth model results
being approximated may involve a model recursion (e.g., the
values/gradients from a nested model).  \ref T6d8 "Table 6.8"
summarizes the local approximation interface specifications.

\anchor T6d8
<table>
<caption align = "top">
\htmlonly
Table 6.8
\endhtmlonly
Specification detail for local approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Local approximation
<td>\c local
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Taylor series local approximation 
<td>\c taylor_series
<td>none
<td>Required
<td>N/A
<tr>
<td>Pointer to the truth model specification
<td>\c actual_model_pointer
<td>string
<td>Required
<td>N/A
</table>


\subsection ModelSurrH Hierarchical approximations

Hierarchical approximations use corrected results from a low fidelity
model as an approximation to the results of a high fidelity "truth"
model.  These approximations are also known as model hierarchy,
multifidelity, variable fidelity, and variable complexity
approximations.  The required \c low_fidelity_model_pointer
specification points to the low fidelity model specification.  This
model is used to generate low fidelity responses which are then
corrected and returned to an iterator.  The required \c
high_fidelity_model_pointer specification points to the specification
for the high fidelity truth model.  This model is used only for
verifying low fidelity results and updating low fidelity corrections.
The \c correction specification specifies which correction technique
will be applied to the low fidelity results in order to match the high
fidelity results at one or more points.  In the hierarchical case (as
compared to the global case), the \c correction specification is
required, since the omission of a correction technique would
effectively eliminate the purpose of the high fidelity model.  If it
is desired to use a low fidelity model without corrections, then a
hierarchical approximation is not needed and a \c single model should
be used.  Refer to \ref ModelSurrG for additional information on
available correction approaches.  \ref T6d9 "Table 6.9" summarizes the
hierarchical approximation specifications.

\anchor T6d9
<table>
<caption align = "top">
\htmlonly
Table 6.9
\endhtmlonly
Specification detail for hierarchical approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Hierarchical approximation 
<td>\c hierarchical
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Pointer to the low fidelity model specification
<td>\c low_fidelity_model_pointer
<td>string
<td>Required
<td>N/A
<tr>
<td>Pointer to the high fidelity model specification
<td>\c high_fidelity_model_pointer
<td>string
<td>Required
<td>N/A
<tr>
<td>Surrogate correction approach
<td>\c correction
<td>\c additive or \c multiplicative or \c combined, \c zeroth_order or \c first_order or \c second_order
<td>Required group
<td>N/A
</table>


\section ModelNested Nested Model Controls

Instead of appealing directly to a primary interface, a nested model
maps parameters to responses by executing a sub-iterator for each
evaluation of the nested model; the sub-iterator in turn operates on a
sub-model.  The sub-iterator responses may be combined with those from
an optional interface specification.

In the \c nested model case, a \c sub_method_pointer must be provided
in order to specify the nested iterator, and \c
optional_interface_pointer and \c optional_interface_responses_pointer
provide an optional group specification for the optional interface
portion of nested models (where \c optional_interface_pointer points
to the interface specification and \c
optional_interface_responses_pointer points to a responses
specification describing the data to be returned by this interface).
This interface is used to provide non-nested data, which is then
combined with data from the nested iterator using the \c
primary_response_mapping and \c secondary_response_mapping inputs (see
mapping discussion below).

Table \ref T6d10 "6.10" provides the specification detail for nested
model pointers.

\anchor T6d10
<table>
<caption align = "top">
\htmlonly
Table 6.10
\endhtmlonly
Specification detail for nested models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Optional interface set pointer
<td>\c optional_interface_pointer
<td>string
<td>Optional group
<td>no optional interface
<tr>
<td>Responses pointer for nested model optional interfaces
<td>\c optional_interface_responses_pointer
<td>string
<td>Optional
<td>reuse of top-level responses specification
<tr>
<td>Sub-method pointer for nested models
<td>\c sub_method_pointer
<td>string
<td>Required
<td>N/A
</table>

Nested models may employ mappings for both the variable inputs to the
sub-model and the response outputs from the sub-model.  In the former
case, the \c primary_variable_mapping and \c
secondary_variable_mapping specifications are used to map from the
active top-level variables into the sub-model variables, and in the
latter case, the \c primary_response_mapping and \c
secondary_response_mapping specifications are used to compute the
sub-model response contributions to the top-level responses.  For the
variable mappings, the primary and secondary specifications provide
lists of strings which are used to target specific sub-model variables
and their sub-parameters, respectively.  The primary strings are
matched to continuous or discrete variable labels such as \c 'cdv_1'
(either user-supplied or default labels), and the secondary strings
are matched to either real or integer random variable distribution
parameters such as \c 'mean' or \c 'num_trials' (the form of the
uncertain distribution parameter keyword that is appropriate for a
single variable instance) or continuous or discrete design/state
variable sub-parameters such as \c 'lower_bound' or \c 'upper_bound'
(again, keyword form appropriate for a single variable instance).  No
coercion of types is supported, so real-valued top-level variables
should map to either real-valued sub-model variables or real-valued
sub-parameters and integer-valued top-level variables should map to
either integer-valued sub-model variables or integer-valued
sub-parameters.  As long as these real versus integer constraints are
satisfied, mappings are free to cross variable types (design, aleatory
uncertain, epistemic uncertain, state) and domain types (continuous,
discrete).  Both \c primary_variable_mapping and \c
secondary_variable_mapping specifications are optional, which is
designed to support the following three possibilities:

-# If both primary and secondary variable mappings are specified,
   then an active top-level variable value will be inserted into the
   identified sub-parameter (the secondary mapping) for the identified 
   sub-model variable (the primary mapping).
-# If a primary mapping is specified but a secondary mapping is not,
   then an active top-level variable value will be inserted into the
   identified sub-model variable value (the primary mapping).
-# If a primary mapping is not specified (corresponding secondary 
   mappings, if specified, are ignored), then an active top-level 
   variable value will be inserted into a corresponding sub-model 
   variable, based on matching of variable types (e.g., top-level 
   and sub-model variable specifications both allocate a set of \c 
   'continuous_design' variables which are active at the top level).  
   Multiple sub-model variable types may be updated in this manner, 
   provided that they are all active in the top-level variables.
   Since there is a direct variable correspondence for these default
   insertions, sub-model bounds and labels are also updated from the
   top-level bounds and labels in order to eliminate the need for
   redundant input file specifications.  Thus, it is typical for the
   sub-model variables specification to only contain the minimal
   required information, such as the number of variables, for these
   insertion targets.  The sub-model must allocate enough space for
   each of the types that will accept default insertions, and the
   leading set of matching sub-model variables are updated (i.e., the
   sub-model may allocate more than needed and the trailing set will
   be unmodified).

These different variable mapping possibilities may be used in any
combination by employing empty strings (\c '') for particular omitted
mappings (the number of strings in user-supplied primary and secondary
variable mapping specifications must equal the total number of active
top-level variables, including both continuous and discrete types).
The ordering of the active variables is the same as shown in
dakota.input.summary and as presented in \ref VarCommands.

If inactive variables are present at the outer level, then the default
type 3 mapping is used for these variables; that is, outer loop
inactive variables are inserted into inner loop variables (active or
inactive) based on matching of variable types, top-level bounds and
labels are also propagated, the inner loop must allocate sufficient
space to receive the outer loop values, and the leading subset within
this inner loop allocation is updated.  This capability is important
for allowing nesting beyond two levels, since an active variable at the
outer-most loop may become inactive at the next lower level, but still
need to be further propagated down the recursion.

For the response mappings, the primary and secondary specifications
provide real-valued multipliers to be applied to sub-iterator response
results. The idea is that the responses from the inner loop are mapped to the outer loop.  For example, if the nested model is an uncertainty quantification, aleatory statistics from the inner loop such as the mean inner loop response are mapped to the outer level, where they are treated epistemically, so that intervals on the mean (for example) are calculated. The response mapping defines a vector which multiplies the values from the inner loop to the outer loop.  Each row of the mapping corresponds to one outer loop response, where each column of the mapping corresponds to a value from the inner loop.  Depending on the number of responses and the particular attributes calculated on the inner loop, there will be a vector of inner loop response values that need to be accounted for in the mapping.   The sub-iterator response results are defined as follows for
different sub-iterator types:

- optimization: the final objective function(s) and nonlinear constraints
- nonlinear least squares: the final least squares terms and nonlinear 
  constraints
- aleatory uncertainty quantification (UQ): for each response function, a mean 
  statistic, a standard deviation statistic, and all 
  probability/reliability/generalized reliability/response level results 
  for any user-specified \c response_levels, \c probability_levels, 
  \c reliability_levels, and/or \c gen_reliability_levels, in that order.
- epistemic and mixed aleatory/epistemic UQ using interval estimation
  methods: lower and upper interval bounds for each response function.
- epistemic and mixed aleatory/epistemic UQ using evidence methods: for 
  each response function, lower and upper interval bounds (belief and
  plausibility) for all probability/reliability/generalized
  reliability/response level results computed from any user-specified \c
  response_levels, \c probability_levels, \c reliability_levels, and/or 
  \c gen_reliability_levels, in that order.
- parameter studies and design of experiments: for optimization and
  least squares response data sets, the best solution found (lowest
  constraint violation if infeasible, lowest composite objective function
  if feasible). For generic response data sets, a best solution metric is 
  not defined, so sub-iterator response results are not defined in this case.

The primary values map sub-iterator response results into top-level
objective functions, least squares terms, or generic response
functions, depending on the declared top-level response set.  The
secondary values map sub-iterator response results into top-level
nonlinear inequality and equality constraints.  Refer to \ref
NestedModel::response_mapping "NestedModel::response_mapping()" for
additional details.  

An example of variable and response mappings is provided below:
\verbatim
primary_variable_mapping   = ''  ''  'X'     'Y'
secondary_variable_mapping = ''  ''  'mean'  'mean'
primary_response_mapping   = 1. 0. 0. 0. 0. 0. 0. 0. 0.
secondary_response_mapping = 0. 0. 0. 1. 3. 0. 0. 0. 0.
                             0. 0. 0. 0. 0. 0. 1. 3. 0.
\endverbatim
The variable mappings correspond to 4 top-level variables, the first
two of which employ the default mappings from active top-level
variables to sub-model variables of the same type (option 3 above) and
the latter two of which are inserted into the mean distribution
parameters of sub-model variables \c 'X' and \c 'Y' (option 1 above).
In this particular example, there are 9 inner loop response attributes and 3 outer loop response functions (one primary response function and 2 secondary functions, such as one objective and two constraints).  Each row of the response mapping is a vector which is multiplied (e.g. dot-product) against the 9 sub-iterator values to determine the outer loop function.  For example, the primary response mapping only picks up the first value from the inner loop.  This first value is the mean of the first response function on the inner loop. 
The response mappings correspond to 9 sub-iterator response functions
(e.g., there are 3 response functions, each with a set of UQ final statistics:  each has a mean, a standard deviation, and a level mapping in this example.  If no probability or reliability levels are specified, the responses would only have a mean and standard deviation).  The primary
response mapping maps the first sub-iterator response function (mean)
into a single objective function, least squares term, or generic
response function (as dictated by the top-level response
specification), and the secondary response mapping maps the fourth
sub-iterator response function plus 3 times the fifth sub-iterator
response function (mean plus 3 standard deviations) into one top-level
nonlinear constraint and the seventh sub-iterator response function
plus 3 times the eighth sub-iterator response function (mean plus 3
standard deviations) into another top-level nonlinear constraint
(these top-level nonlinear constraints may be inequality or equality,
as dictated by the top-level response specification). Note that in many cases, each particular sub-iterator response will be mapped to a unique outer loop response (for example, in the nested UQ case where one wants to determine an interval on each inner loop statistic).  In these cases, the response mapping will be the identity matrix.  That is, the primary response mapping will have N rows and N columns corresponding to the N sub-iterator response values, and the mapping matrix will have a value of one along the diagonal and zeros elsewhere.

Table \ref T6d11 "6.11" provides the specification detail for the model
independent controls involving nested model mappings.

\anchor T6d11
<table>
<caption align = "top">
\htmlonly
Table 6.11
\endhtmlonly
Specification detail for the model independent controls: nested model mappings
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Primary variable mappings for nested models
<td>\c primary_variable_mapping
<td>list of strings
<td>Optional
<td>default variable insertions based on variable type
<tr>
<td>Secondary variable mappings for nested models
<td>\c secondary_variable_mapping
<td>list of strings
<td>Optional
<td>primary mappings into sub-model variables are value-based
<tr>
<td>Primary response mappings for nested models
<td>\c primary_response_mapping
<td>list of reals
<td>Optional
<td>no sub-iterator contribution to primary functions
<tr>
<td>Secondary response mappings for nested models
<td>\c secondary_response_mapping
<td>list of reals
<td>Optional
<td>no sub-iterator contribution to secondary functions
</table>

\htmlonly
<hr>
<br><b><a href="MethodCommands.html#MethodCommands">Previous chapter</a></b>
<br>
<br><b><a href="VarCommands.html#VarCommands">Next chapter</a></b>
\endhtmlonly

*/

} // namespace Dakota
